* Core Setup
  This section contains the core configuration settings which are needed in
  order to have my init.el file work.

  Before running for the first time, you should

  1. Create the directory ~/.emacs.d if it doesn't already exist
  2. Put the files ~init.org~, ~setup.el~ and ~setup.sh~ in that directory.
  3. Make sure that ~setup.sh~ is executable by running ~chmod u+x setup.sh~

  Then, from inside the ~.emacs.d~ directory, run

  ~./setup.sh~

  This should create the init.el and other files used in the configuration as
  well as setup any necessary directories. Once this has been done, you can run
  emacs and all should work.

  Note that on the first run, emacs will need to download a number of packages
  from MELPA. Depending on how fast your internet connection is, this could take
  a while. Once it has completed, you may want to exit emacs and re-start to
  ensure everything is loaded correctly. Check the ~*Messages*~ buffer for any
  errors or warnings.

* load path
  The following adds additional directories to the emacs load-path so that
  emacs can find various additional libraries etc

  Add the directories which my init files live

  #+BEGIN_SRC emacs-lisp
    (message "Loading local init")

    (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))

  #+END_SRC

  Add the directory I use for locally installed elisp libraries or packages

  #+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "lib" user-emacs-directory))
  #+END_SRC

* Set some constants
  I set a couple of constants which can then be used to control configuration
  settings in my init file.

  I run emacs on both OSX and Linux. To handle differences in configuration
  settings for the two platforms, I set a constant which determines if emacs is
  running on OSX or not

  #+BEGIN_SRC emacs-lisp
    (defconst *is-a-mac* (eq system-type 'darwin)
      "t if emacs is running under OSX, nil otherwise")
  #+END_SRC

  Set a constant to determine if spell checking is to be enabled

  #+BEGIN_SRC emacs-lisp
    (defconst *spell-check-support-enabled* t
      "t if we want spell checking support enabled, nil otherwise")
  #+END_SRC

  Force emacs to UTF-8 as the default.

  #+BEGIN_SRC emacs-lisp
    (prefer-coding-system 'utf-8)
    (set-default-coding-systems 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    ;; backwards compatibility as default-buffer-file-coding-system
    ;; is deprecated in 23.2.
    (if (boundp 'buffer-file-coding-system)
        (setq-default buffer-file-coding-system 'utf-8)
      (setq default-buffer-file-coding-system 'utf-8))

    ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
  #+END_SRC

* Emacspeak
 Now load Emacspeak. As Emacspeak makes extensive use of Emacs' =defacvice=
 facility, it is important that it is loaded as early as possible in the Emacs boot
 process.

 If we are running under Linux, I also use an environment variable to enable
 emacspeak. This makes it easy to disable emacspeak at emacs boot time by
 unsetting the variable at the shell. I don't do this under OSX because I run
 OSX from the Launcher and there seems to be a trick to having local
 environment variables read during startup (I'm sure there is a fix for this,
 just haven't had time to find it). Word of warning, be vary careful googling
 for an answer. I just did a 10 minute search and there is a lot more incorrect
 or bad advice out there than correct advice. In fact, I find OSX forums seem
 to have a very high ratio of bad answers compared to good ones. I suspect the
 solution to this issue is to use launchctl to set the variables.
 #+BEGIN_SRC emacs-lisp
   ;; (if *is-a-mac*
   ;;     (require 'init-emacspeak)
   ;;   (if (getenv "RUN_EMACSPEAK")
   ;;       (require 'init-emacspeak)))

 #+END_SRC

 I don't run make install when I've finished compiling emacspeak. I
 prefer to keep all the emacspeak sources under my home
 directory. This makes it easy to run multiple source trees and use
 symbolic links to determine which source tree is loaded. One of the
 advantages of doing this is that I can try a new emacspeak version
 without loosing an existing, older but working version.

 This is an /older/ approach, which I tend to use less now that
 emacspeak is under Git version control. A more common approach is to
 now just keep track of the last working commit I was happy with. If
 I then do an update and find the new version has some problems, I
 can just revert the git repo to the last known good commit. I tend
 to also use my own local branches.

 First, setup a constant which tells emacs where to look for the
 emacspeak distro

 #+BEGIN_SRC emacs-lisp 
     (defconst *emacspeak-src-dir* "~/git/emacspeak/trunk"
       "Where emacs will find the emacspeak distro")
   #+END_SRC

 Need to load different speech servers depending on the platform

 #+BEGIN_SRC emacs-lisp 
     (if *is-a-mac*
         (defconst *emacspeak-server* "mac")
       (defconst *emacspeak-server* "outloud"))
   #+END_SRC

 Add the EmacsSpeak info documentation to the info search path. From
 within Info, you can hit ~g~ and then enter ~(emacspeak)~ at the
 prompt to open the Emacspeak info documentation

 #+BEGIN_SRC emacs-lisp 
   (add-to-list 'Info-default-directory-list (concat *emacspeak-src-dir* "/info"))
 #+END_SRC

 When emacs is not being run in batch mode and when emacspeak is not
 yet loaded, then load it

 #+BEGIN_SRC emacs-lisp 
   (when (and (not noninteractive)
              (not (featurep 'emacspeak)))
     (add-to-list 'load-path *emacspeak-src-dir*)
     (setenv "EMACSPEAK_DIR" *emacspeak-src-dir*)
     (setenv "DTK_PROGRAM" *emacspeak-server*)
     (if *is-a-mac*
         (setq emacspeak-wizards-available-browsers
               '(eww-browse-url browse-url-default-macosx-browser))
       (setq emacspeak-wizards-available-browsers
             '(eww-browse-url browse-url-default-browser)))
     (setq dtk-program *emacspeak-server*)
     (setq dtk-use-tones nil)
     (setq emacspeak-mail-alert nil)
     (setq tts-default-speech-rate 90)
     (setq outloud-default-speech-rate 90)
     (setq emacspeak-vm-use-raman-settings nil)
     (setq mac-default-speech-rate 400)
     (setq emacspeak-erc-my-nick "theophilusx")
     (setq emacspeak-erc-speak-all-participants t)
     (setq emacspeak-play-program "/home/tcross/bin/play")
     (setq emacspeak-play-args nil)
     (if *is-a-mac*
         (progn
           (setq emacspeak-soxplay-command "/usr/local/bin/play -v 1.2 %s earwax &")
           (setq sox-play "/usr/local/bin/play"))
       (setq emacspeak-soxplay-command "/usr/bin/play -v 1.2 %s earwax &")
       (setq sox-play "/usr/bin/play"))
     (setq emacspeak-auditory-icon-function
           'emacspeak-soxplay-auditory-icon)
     (add-hook 'emacspeak-startup-hook
               (lambda ()
                 (dtk-set-rate tts-default-speech-rate 1)
                 (dtk-interp-sync)
                 (emacspeak-sounds-select-theme "3d/")))
     (load-file (concat *emacspeak-src-dir* "/lisp/emacspeak-setup.el")))
 #+END_SRC

* ELPA

  ELPA has made managing add-on elisp packages *much* easier than it use to
  be. The trick is to only load packages you really want/need and not get
  carried away loading lots of additional packages /just in case/.

  A word of warning regarding the use of packages from archives such as
  melpa. There is no consistent testing or analysis of packages added to
  various emacs package archives (with the only exception perhaps being the
  official GNU archive). This is a security risk. Theoretically, it would be
  possible to install a package which either deliberately or accidentally
  compromises your security. Probably the best thing to do if you don't have
  time to review the code or don't have the skills to do this is rely on
  reputation. Probably always a good idea to google a package before adding it
  to see what other users have found while using the package. As packages can
  vary in quality, this will also identify packages which may not be well
  written or have numerous bugs etc.

  I just found John Wiegley's use-package macro, which I think is a really
  convenient way to manage the installation and configuration of ELPA
  packages. Therefore, I plan to migrate my configuration to use that package.

   First, we need to load package.el and then we need to add some additional package
   repositories. I add

   - The Org repository so that I can use most recent org-plus-contrib package
   - The melpa repository

   #+BEGIN_SRC emacs-lisp
     (require 'package)

     (setq package-enable-at-startup nil)
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
     (add-to-list 'package-archives `("melpa" . "https://melpa.org/packages/"))
     (package-initialize)

   #+END_SRC

   We have a slight bootstrap or /chicken and egg/ problem, we need the
   use-package package from ELPA before we can use it, but it is what we want
   to use to install the package. Therefore, need a simple light weight way to
   get that package. Lets do the simple way

   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))
     ;;(setq use-package-verbose t)
     (eval-when-compile
       (require 'use-package))
     (require 'diminish)
     (require 'bind-key)
   #+END_SRC

   Use the ~fullframe~ package to ensure that the package listing uses one window
   which fills the current frame

   #+BEGIN_SRC emacs-lisp
     (use-package fullframe
       :ensure t
       :config (fullframe list-packages quit-window))
   #+END_SRC

* Editing Tweaks

  Some simple functions and bindings stolen from
  [[http://github.com/purcell/emacs.d]] which adds some editing tweaks

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "RET") 'newline-and-indent)

    (defun tx/newline-at-end-of-line ()
      "Move to end of line, enter a newline, and reindent."
      (interactive)
      (move-end-of-line 1)
      (newline-and-indent))

    (global-set-key (kbd "S-<return>") 'tx/newline-at-end-of-line)

    (global-set-key (kbd "C-c j") 'join-line)
    (global-set-key (kbd "C-c J") (lambda () (interactive) (join-line 1)))

    (defun kill-back-to-indentation ()
      "Kill from point back to the first non-whitespace character on the line."
      (interactive)
      (let ((prev-pos (point)))
        (back-to-indentation)
        (kill-region (point) prev-pos)))

    (global-set-key (kbd "C-M-<backspace>") 'kill-back-to-indentation)

    (defun tx/open-line-with-reindent (n)
      "A version of `open-line' which reindents the start and end positions.
          If there is a fill prefix and/or a `left-margin', insert them
          on the new line if the line would have been blank.
          With arg N, insert N newlines."
      (interactive "*p")
      (let* ((do-fill-prefix (and fill-prefix (bolp)))
             (do-left-margin (and (bolp) (> (current-left-margin) 0)))
             (loc (point-marker))
             ;; Don't expand an abbrev before point.
             (abbrev-mode nil))
        (delete-horizontal-space t)
        (newline n)
        (indent-according-to-mode)
        (when (eolp)
          (delete-horizontal-space t))
        (goto-char loc)
        (while (> n 0)
          (cond ((bolp)
                 (if do-left-margin (indent-to (current-left-margin)))
                 (if do-fill-prefix (insert-and-inherit fill-prefix))))
          (forward-line 1)
          (setq n (1- n)))
        (goto-char loc)
        (end-of-line)
        (indent-according-to-mode)))

    (global-set-key (kbd "C-o") 'tx/open-line-with-reindent)
  #+END_SRC

* Some simple ELPA packages and basic defaults
  Load some basic elpa packages which don't require additional
  configuration. Also add some standard modes and tweak a few defaults.

** Exec path
   Set up the exec path for emacs

   #+BEGIN_SRC emacs-lisp
    (use-package exec-path-from-shell
      :ensure t
      :init
      (setq exec-path-from-shell-check-startup-files nil)
      :config
      (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID"
                     "GPG_AGENT_INFO" "LANG" "LC_CTYPE"))
        (add-to-list 'exec-path-from-shell-variables var))
      (when (memq window-system '(mac ns x))
        (exec-path-from-shell-initialize)))
   #+END_SRC

** Tool tips and popups
   #+BEGIN_SRC emacs-lisp
     ;; (use-package pos-tip
     ;;   :ensure t)

     ;; (use-package popup
     ;;   :ensure t
     ;;   :config
     ;;   (use-package popup-complete
     ;;     :ensure t
     ;;     :commands (popup-complete--in-region)))
   #+END_SRC

** Ido
   #+BEGIN_SRC emacs-lisp
     (use-package ido
       :init
       (setq ido-enable-flex-matching t)
       (setq ido-everywhere t)
       (setq ido-use-filename-at-point nil)
       (setq ido-auto-merge-work-directories-length 0)
       (setq ido-use-virtual-buffers t)
       (setq ido-create-new-buffer 'always)
       (setq ido-file-extensions-order '(".org" ".txt" ".clj" ".cljs" ".py" 
                                         ".emacs" ".xml" ".el" ".cfg" ".cnf"))
       (setq ido-default-buffer-method 'selected-window)
       (setq ido-enable-dot-prefix t)
       (add-hook 'ido-setup-hook (lambda ()
                                   (define-key ido-completion-map [up]
                                     'previous-history-element)))
       :config
       (ido-mode 1)
       (use-package ido-ubiquitous
         :ensure t
         :config
         (ido-ubiquitous-mode t))
       (use-package smex
         :ensure t
         :init
         (smex-initialize)
         (setq smex-save-file (expand-file-name ".smex-items" user-emacs-directory))
         (bind-key "M-x" 'smex)
         (bind-key "M-X" 'smex-major-mode-commands)
         (bind-key "C-c C-c M-x" 'execute-extended-command))

     )
   #+END_SRC
** Recentf
   Use recentf to find files I've opened recently quickly

   #+BEGIN_SRC emacs-lisp
     (use-package recentf
       :init
       (setq recentf-max-saved-items 50)
       :config
       (defun ido-recentf-open ()
         "Use `ido-completing-read' to \\[find-file] a recent file"
         (interactive)
         (if (find-file (ido-completing-read "Find recent file: " recentf-list))
             (message "Opening file...")
           (message "Aborting")))
       (recentf-mode t)
       (bind-key "C-x C-r" 'ido-recentf-open))
   #+END_SRC

** Better Defaults
  Start with the better-defaults package as a base. See
  [[https://github.com/technomancy/better-defaults][better-defaults on GitHub]]

  #+BEGIN_SRC emacs-lisp
    (use-package better-defaults
      :ensure t)
  #+END_SRC

** Scroll Bars
  I also want to disable scrollbars 

  #+BEGIN_SRC emacs-lisp
    ;; (when (fboundp 'scroll-bar-mode)
    ;;   (scroll-bar-mode -1))
  #+END_SRC

** Setq and Setq-defaults
  Set some defaults

  #+BEGIN_SRC emacs-lisp 
    (setq auth-sources '("~/.authinfo.gpg" "~/.authinfo" "~/.netrc")
          backup-directory-alist `(("." . ,(concat user-emacs-directory
                                                   "backups")))
          delete-by-moving-to-trash t
          inhibit-startup-message t
          line-move-visual nil
          message-log-max 2048)
    (setq kill-buffer-query-functions (remq 'process-kill-buffer-query-function
                                            kill-buffer-query-functions))
    (setq-default save-place t
                  show-trailing-whitespace t
                  fill-column 80)
  #+END_SRC

** Browse Kill Ring
  Add the ~browse-kill-ring~ package to make it easier to retrieve killed content history

  #+BEGIN_SRC emacs-lisp
  (use-package browse-kill-ring
    :ensure t
    :bind ("M-Y" . browse-kill-ring)
    :init
    (setq browse-kill-ring-separator "\f")
    :config
    (bind-key "C-g" browse-kill-ring-quit browse-kill-ring-mode-map)
    (bind-key "M-n" browse-kill-ring-forward browse-kill-ring-mode-map)
    (bind-key "M-p" browse-kill-ring-previous browse-kill-ring-mode-map))
  #+END_SRC

** Delete Selection
  When the selection is active and I type, I want what I type to
  replace the currently highlighted selection.

  #+BEGIN_SRC emacs-lisp
  (delete-selection-mode)
  #+END_SRC

** Undo Tree
   Add the ~undo-tree~ package for managing undo/redo

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :ensure t
       :diminish undo-tree-mode
       :config (global-undo-tree-mode))
   #+END_SRC

** Page Break Lines Mode
   Display lines to show where page breaks are. Useful in making the
   browse-kill-ring mode look a little better. See [[https://github.com/purcell/page-break-lines][page-break-lines on GitHub]]

   #+BEGIN_SRC emacs-lisp
     (use-package page-break-lines
       :ensure t
       :diminish page-break-lines-mode
       :config
       (global-page-break-lines-mode)
       (push 'browse-kill-ring-mode page-break-lines-modes)
       (push 'sql-mode page-break-lines-modes)
       (push 'text-mode page-break-lines-modes))

   #+END_SRC

** Fix the mark
   Enable setting of mark without setting of transient mark mode

   #+BEGIN_SRC emacs-lisp
     (defun push-mark-no-activate ()
       "Pushes `point' to `mark-ring' and does not activate the region
        Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
       (interactive)
       (push-mark (point) t nil)
       (message "Pushed mark to ring"))

     (bind-key "C-`" 'push-mark-no-activate)

     (defun jump-to-mark ()
       "Jumps to the local mark, respecting the `mark-ring' order.
       This is the same as using \\[set-mark-command] with the prefix argument."
       (interactive)
       (set-mark-command 1))

     (bind-key "M-`" 'jump-to-mark)

     (defun exchange-point-and-mark-no-activate ()
       "Identical to \\[exchange-point-and-mark] but will not activate the region."
       (interactive)
       (exchange-point-and-mark)
       (deactivate-mark nil))

     (define-key global-map [remap exchange-point-and-mark]
       'exchange-point-and-mark-no-activate)
   #+END_SRC
** Basic Modes
  Enable some modes I want on by default

  #+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (global-auto-revert-mode)
  (transient-mark-mode t)
  (when (fboundp 'global-prettify-symbols-mode)
    (global-prettify-symbols-mode))
  #+END_SRC

** Highlight symbol Mode
   Highlight symbols and enable navigation by symbol in programming modes. See
   [[http://nschum.de/src/emacs/highlight-symbol/]].

   #+BEGIN_SRC emacs-lisp
     (use-package highlight-symbol
       :ensure t
       :diminish highlight-symbol-mode
       :config
       (dolist (hook '(prog-mode-hook html-mode-hook css-mode-hook))
         (add-hook hook 'highlight-symbol-mode)
         (add-hook hook 'highlight-symbol-nav-mode))
       (defadvice highlight-symbol-temp-highlight (around sanityinc/maybe-suppress
                                                          activate)
         "Suppress symbol highlighting while isearching."
         (unless (or isearch-mode
                     (and (boundp 'multiple-cursors-mode)
                          multiple-cursors-mode))
           ad-do-it)))
   #+END_SRC

** Move Or Duplicate Lines
   Add the ability to move lines up/down or duplicate lines. 

   #+BEGIN_SRC emacs-lisp
     (use-package move-dup
       :ensure t
       :bind (("M-S-<up>" . md/move-lines-up)
              ("M-S-<down>" . md/move-lines-down)
              ("C-c p" . md/duplicate-down)
              ("C-c P" . md/duplicate-up)))
   #+END_SRC
** Whole line or region
   Allow region oriented commands to work on the current line if no region is
   defined.

   #+BEGIN_SRC emacs-lisp
     (use-package whole-line-or-region
       :ensure t
       :diminish whole-line-or-region-mode
       :config
       (whole-line-or-region-mode t)
       (make-variable-buffer-local 'whole-line-or-region-mode))

   #+END_SRC

** Yes or No
  Lets shorten that irritating yes-or-no and unnecessary prompts. 

  #+BEGIN_SRC emacs-lisp 
    (fset 'yes-or-no-p 'y-or-n-p)
    (setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function
             kill-buffer-query-functions))
  #+END_SRC

** Enable Disabled Commands
  Now lets enable some of those handy commands which are disabled by default

  #+BEGIN_SRC emacs-lisp
    (put 'narrow-to-region 'disabled nil)
    (put 'narrow-to-page 'disabled nil)
    (put 'narrow-to-defun 'disabled nil)
    (put 'upcase-region 'disabled nil)
    (put 'downcase-region 'disabled nil)

  #+END_SRC

** Electric Pair Mode
  Most of my time is spent programming. I rarely want to enter a
  bracket or paren without also entering its closing one, so lets turn
  on ~electric-pair-mode~ mode if it exists

  #+BEGIN_SRC emacs-lisp 
    (when (fboundp 'electric-pair-mode)
      (electric-pair-mode))
  #+END_SRC

** Go To Address
  Lets make addresses action buttons when we find them in comments in
  programming buffers

  #+BEGIN_SRC emacs-lisp
    (dolist (hook (if (fboundp 'prog-mode)
                      '(prog-mode-hook ruby-mode-hook)
                    '(find-file-hooks)))
      (add-hook hook 'goto-address-prog-mode))
  #+END_SRC

** Make Scripts Executable
  When we create a script, we want the saved file to be made executable

  #+BEGIN_SRC emacs-lisp
    (add-hook 'after-save-hook
              'executable-make-buffer-file-executable-if-script-p)
  #+END_SRC

** Text Mode Stuff
  Lets enable some modes for text-mode

  #+BEGIN_SRC emacs-lisp 
    (add-hook 'text-mode-hook 'goto-address-mode)  
    (add-hook 'text-mode-hook 'turn-on-auto-fill)

  #+END_SRC

** Grep and Wgrep
  The ~wgrep~ package allows for writing of grep buffers back to file. See
  [[http://github.com/mhayashi1120/Emacs-wgrep][wgrep on GitHub]]

  #+BEGIN_SRC emacs-lisp
    (use-package grep
      :init
      (setq-default grep-highlight-matches t
                   grep-scroll-output t)
      (when *is-a-mac* 
        (setq-default locate-command "mdfind"))
      (use-package wgrep
        :ensure t
        :commands (wgrep-setup))
      :config
      (add-hook 'grep-setup-hook 'wgrep-setup))

  #+END_SRC

** Diminish Mode
  The ~diminish~ package allows us to remove or change minor mode entries in
  the mode-line. See [[https://github.com/myrjola/diminish.el][diminish on GitHub]]

  #+BEGIN_SRC emacs-lisp
    (use-package diminish
      :ensure t
      :config
      (diminish 'voice-lock-mode)
      (diminish 'auto-fill-function))

  #+END_SRC

** Scratch Buffers
  Use the ~scratch~ package to easily create a scratch buffer in the same mode
  as current buffer

  #+BEGIN_SRC emacs-lisp
    (use-package scratch
      :ensure t
      :commands (scratch))

  #+END_SRC

** Unfill
  Add the ~unfill~ package to enable doing the reverse of filling

  #+BEGIN_SRC emacs-lisp
    (use-package unfill
      :ensure t
      :commands (unfill-paragraph unfill-region toggle-fill-unfill))

  #+END_SRC

** Fill Column Indicator
   #+BEGIN_SRC emacs-lisp
     (use-package fill-column-indicator
       :ensure t
       :config
       (add-hook 'prog-mode-hook 'fci-mode)
       (add-hook 'text-mode-hook 'fci-mode)
       (add-hook 'org-mode-hook 'fci-mode))
   #+END_SRC
** Expand Region
  Add the ~expand-region~ package to make it easy to expand/contract the region
  based on the semantic units for the current mode.

  #+BEGIN_SRC emacs-lisp
    (use-package expand-region
      :ensure t
      :bind ("C-=" . er/expand-region))

  #+END_SRC

** Lua
  Add support for editing lua scripts

  #+BEGIN_SRC emacs-lisp
    (use-package lua-mode
      :ensure t
      :commands (lua-mode)
      :mode "\\.lua\\'"
      :interpreter "lua")

  #+END_SRC

** Htmlize
  Add the ~htmlize~ package to provide an easy way to turn buffer contents into
  HTML. See [[http://fly.srk.fer.hr/~hniksic/emacs/htmlize.git]].

  #+BEGIN_SRC emacs-lisp
    (use-package htmlize
      :ensure t
      :commands (htmlize-buffer htmlize-region htmlize-file
                                htmlize-many-files htmlize-many-files-dired))
  #+END_SRC

** Regex Tool
  Add the handy ~regex-tool~ package

  #+BEGIN_SRC emacs-lisp
    (use-package regex-tool
      :ensure t
      :commands (regex-tool))

  #+END_SRC

** Stack Exchange
  When I'm a bit bored or want a break from my own problems, I sometimes like
  to look at stack overflow. See [[https://github.com/vermiculus/sx.el/][sx on GitHub]].

  #+BEGIN_SRC emacs-lisp
    (use-package sx
      :ensure t
      :commands (sx-bug-report sx-authenticate sx-inbox sx-inbox-notifications
                               sx-org-get-link sx-ask sx-search
                               sx-search-tag-at-point sx-tab-all-questions
                               sx-tab-unanswered sx-tab-unanswered-my-tags
                               sx-tab-featured sx-tab-starred
                               sx-tab-frontpage sx-tab-newest
                               sx-tab-topvoted sx-tab-hot
                               sx-tab-week sx-tab-month))

  #+END_SRC

** Auctex
  Use the ~auctex~ package for writing LaTeX.

  #+BEGIN_SRC emacs-lisp
    (use-package tex
      :ensure auctex)

  #+END_SRC

** OSX Stuff
  Add some packages which are useful when running under OSX

  #+BEGIN_SRC emacs-lisp
    (when *is-a-mac*
      (use-package osx-lib
        :disabled t
        :ensure t
        :commands (osx-lib-run-osascript osx-lib-osx-version 
                   osx-lib-run-js osx-lib-do-beep 
                   osx-lib-notify2 osx-lib-notify3 
                   osx-lib-copy-to-clipboard osx-lib-reveal-in-finder-as 
                   osx-lib-reveal-in-finder osx-lib-vpn-connect 
                   osx-lib-vpn-disconnect osx-lib-say))
      (use-package osx-plist
        :disabled t
        :ensure t
        :commands (osx-plist-update-environment osx-plist-parse-file))
      (setq mac-command-modifier 'meta)
      (setq mac-option-modifier 'none)
      (setq default-input-method "MacOSX")
      ;; Make mouse wheel / trackpad scrolling less jerky
      (setq mouse-wheel-scroll-amount '(1
                                        ((shift) . 5)
                                        ((control))))
      (dolist (multiple '("" "double-" "triple-"))
        (dolist (direction '("right" "left"))
          (global-set-key (read-kbd-macro
                           (concat "<" multiple "wheel-" direction ">")) 'ignore)))
      ;;(global-set-key (kbd "M-`") 'ns-next-frame)
      ;;(global-set-key (kbd "M-h") 'ns-do-hide-emacs)
      ;;(global-set-key (kbd "M-˙") 'ns-do-hide-others)
      ;; what describe-key reports for cmd-option-h
      ;;(global-set-key (kbd "M-ˍ") 'ns-do-hide-others))
      )

  #+END_SRC

** Timestamps
   Surprises me how often people ask for this functionality without realizing it
   is already built-in. 

   #+BEGIN_SRC emacs-lisp
     (use-package time-stamp
       :init
       (setq time-stamp-active t
             time-stamp-format "%:a, %02d %:b %:y %02I:%02M %#P %Z"
             time-stamp-start "\\(Time-stamp:[         ]+\\\\?[\"<]+\\|Last Modified:[
                ]\\)"
             time-stamp-end "\\\\?[\">]\\|$"
             time-stamp-line-limit 10)
       :config
       (add-hook 'write-file-hooks 'time-stamp))
   #+END_SRC
** Calendar
   Configure the calendar

   #+BEGIN_SRC emacs-lisp
     (use-package calendar
       :init
       (setq calendar-date-style 'iso
             calendar-location-name "Armidale"
             calendar-longitude 151.617222
             calendar-mark-diary-entries-flag t
             calendar-mark-holidays-flag t
             calendar-time-zone 600
             calendar-view-holidays-initially-flag t
             icalendar-import-format "%s%l"
             icalendar-import-format-location " (%s)"
             icalendar-recurring-start-year 2013))

   #+END_SRC
** Crontab
   #+BEGIN_SRC emacs-lisp
     (use-package crontab-mode
       :mode ("\\.?cron\\(tab\\)?\\'" . crontab-mode))
   #+END_SRC
** CSV
   #+BEGIN_SRC emacs-lisp
     (use-package csv-mode
       :ensure t
       :init
       (setq csv-separators '("," ";" "|" " "))
       :config
       (use-package csv-nav
         :ensure t)
       :mode ("\\.[Cc][Ss][Vv]\\'" . csv-mode))
   #+END_SRC
** Dired

   I like to have directories listed first. Easiest way to do this is use the
   ~ls-lisp~ library

   #+BEGIN_SRC emacs-lisp
     (use-package dired
       :init
       (setq dired-listing-switches "-la")
       (add-hook 'dired-load-hook (lambda ()
                                    (load "dired-x")))
       :config
       (use-package ls-lisp
         :init
         (setq ls-lisp-dirs-first t
               ls-lisp-ignore-case t
               ls-lisp-use-insert-directory-program nil
               ls-lisp-use-localized-time-format t))
       (use-package diff-hl
         :ensure t)
       (add-hook 'dired-mode-hook 'diff-hl-dired-mode))

     (use-package find-dired
       :init
       (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld")))

   #+END_SRC
** Spelling
    When running on OSX it is necessary to
    - Install a spell checker. I prefer to use /homebrew/ to install both emacs and
      associated programs i.e
      : brew install hunspell
    - Note that you also need to install the dictionaries. I use the dictionaries from
      openOffice. These are distributed in /*.oxt/ files, which are just /zip/
      archives. Unzip them and put the /*.aff/ and /*.dic/ files in
      /~/Library/Spelling/ directory.
    - I also setup symbolic links from the dictionaries I want to /default.aff/ and /default.dic/

    #+BEGIN_SRC emacs-lisp 
      (when *spell-check-support-enabled*
        (use-package ispell
          :init
          (if *is-a-mac*
              (setq ispell-dictionary "british")
            (setq ispell-dictionary "british-ise"))
          :config
          (when (executable-find ispell-program-name)
            (use-package flyspell
              :diminish flyspell-mode
              :init
              (setq flyspell-use-meta-tab nil)
              :config
              (add-hook 'prog-mode-hook 'flyspell-prog-mode)
              (add-hook 'text-mode-hook 'flyspell-mode)))))
    #+END_SRC

** Whitespace
   Cleanup whitespace

   #+BEGIN_SRC emacs-lisp
     (use-package whitespace-cleanup-mode
       :ensure t
       :diminish whitespace-cleanup-mode
       :config
       (global-whitespace-cleanup-mode t))
   #+END_SRC
** Rainbow Mode
   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-mode
       :ensure t
       :commands (rainbow-mode))
   #+END_SRC
** Rainbow Delimiters 
   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters 
       :ensure t
       :commands (rainbow-delimiters-mode
                  rainbow-delimiters-mode-enable
                  rainbow-delimiters-mode-disable))
   #+END_SRC
* Yasnippet
  #+BEGIN_SRC emacs-lisp
    (use-package yasnippet
    :ensure t
    :init
    (setq yas-prompt-functions '(yas-dropdown-prompt))
    :config
    (define-key yas-minor-mode-map (kbd "<tab>") nil)
    (define-key yas-minor-mode-map (kbd "TAB") nil)
    (define-key yas-minor-mode-map (kbd "C-M-/") 'yas-expand)
    (yas/load-directory "~/.emacs.d/snippets"))
  #+END_SRC
* Hippie Expand
  #+BEGIN_SRC emacs-lisp
    (setq hippie-expand-try-functions-list
          '(try-complete-file-name-partially
            try-complete-file-name
            yas-hippie-try-expand
            try-expand-dabbrev
            try-expand-dabbrev-all-buffers
            try-expand-dabbrev-from-kill))
  #+END_SRC
* Auto Complete
  #+BEGIN_SRC emacs-lisp
    ;; Turn off auto-complete

    ;; (use-package auto-complete
    ;;   :ensure t
    ;;   :diminish auto-complete
    ;;   :init
    ;;   (set-default 'ac-sources
    ;;                '(
    ;;                  ;;ac-source-dabbrev
    ;;                  ;;ac-source-emoji
    ;;                  ac-source-dictionary
    ;;                  ac-source-words-in-buffer
    ;;                  ac-source-words-in-same-mode-buffers
    ;;                  ac-source-words-in-all-buffer
    ;;                  ))

    ;;   (setq-default ac-expand-on-auto-complete nil)
    ;;   (setq-default ac-auto-start nil)
    ;;   (setq-default ac-dwim nil)        ; To get pop-ups with docs even if a word is
    ;;                                         ; uniquely completed
    ;;   (setq tab-always-indent 'complete)    ;; use 't when auto-complete is disabled

    ;;   ;; Stop completion-at-point from popping up completion buffers so eagerly
    ;;   (setq completion-cycle-threshold 5)
    ;;   (setq c-tab-always-indent nil
    ;;         c-insert-tab-function 'indent-for-tab-command)

    ;;   :config
    ;;   (global-auto-complete-mode t)
    ;;   (add-to-list 'completion-styles 'initials t)

    ;;   (defun tx/auto-complete-at-point ()
    ;;     (when (and (not (minibufferp))
    ;;                (fboundp 'auto-complete-mode)
    ;;                auto-complete-mode)
    ;;       #'auto-complete))

    ;;   (defun tx/never-indent ()
    ;;     (set (make-local-variable 'indent-line-function) (lambda () 'noindent)))

    ;;   (defun set-auto-complete-as-completion-at-point-function ()
    ;;     (setq completion-at-point-functions
    ;;           (cons 'tx/auto-complete-at-point
    ;;                 (remove 'tx/auto-complete-at-point
    ;;                         completion-at-point-functions))))

    ;;   (add-hook 'auto-complete-mode-hook
    ;;             'set-auto-complete-as-completion-at-point-function)

    ;;   (dolist (mode '(log-edit-mode
    ;;                   org-mode
    ;;                   text-mode
    ;;                   haml-mode
    ;;                   git-commit-mode
    ;;                   sass-mode
    ;;                   yaml-mode
    ;;                   csv-mode espresso-mode haskell-mode
    ;;                   html-mode
    ;;                   nxml-mode
    ;;                   sh-mode
    ;;                   smarty-mode
    ;;                   clojure-mode
    ;;                   lisp-mode
    ;;                   textile-mode
    ;;                   markdown-mode
    ;;                   tuareg-mode
    ;;                   js3-mode
    ;;                   css-mode
    ;;                   less-css-mode
    ;;                   sql-mode
    ;;                   sql-interactive-mode
    ;;                   inferior-emacs-lisp-mode))
    ;;     (add-to-list 'ac-modes mode))

    ;;   (defun tx/dabbrev-friend-buffer (other-buffer)
    ;;     (< (buffer-size other-buffer) (* 1 1024 1024)))
    ;;   (setq dabbrev-friend-buffer-function 'tx/dabbrev-friend-buffer))

    ;; (use-package auto-complete-auctex
    ;;   :ensure t
    ;;   :config
    ;;   (add-hook 'latex-mode-hook 'ac-auctex-setup))

    ;; (use-package auto-complete-pcmp
    ;;   :ensure t)

    ;; (use-package ac-ispell
    ;;   :ensure t
    ;;   :init
    ;;   (setq ac-ispell-requires 4
    ;;         ac-ispell-fuzzy-limit 4)
    ;;   :config
    ;;   (add-hook 'text-mode-hook 'ac-ispell-setup)
    ;;   (add-hook 'latex-mode-hook 'ac-ispell-setup)
    ;;   (add-hook 'org-mode-hook 'ac-ispell-setup)
    ;;   (add-hook 'markdown-mode-hook 'ac-ispell-setup))

    ;; (use-package ac-dabbrev
    ;;   :ensure t
    ;;   :config
    ;;   (add-to-list 'ac-sources 'ac-source-dabbrev))

    ;; (use-package ac-emoji
    ;;   :ensure t
    ;;   :config
    ;;   (add-hook 'markdown-mode-hook 'ac-emoji-setup)
    ;;   (add-hook 'text-mode-hook 'ac-emoji-setup)
    ;;   (add-hook 'org-mode-hook 'ac-emoji-setup)
    ;;   (add-hook 'git-commit-mode-hook 'ac-emoji-setup))

  #+END_SRC
* Company
  #+BEGIN_SRC emacs-lisp
    (use-package company
      :ensure t
      :init
      (setq company-idle-delay 0.9)
      (setq company-tooltip-limit 10)
      ;;(setq company-minimum-prefix-length 2)
      ;; invert the navigation direction if the the completion popup-isearch-match
      ;; is displayed on top (happens near the bottom of windows)
      ;;(setq company-tooltip-flip-when-above t)
      :config
      (global-company-mode 1)
      (use-package company-auctex
        :ensure t
        :config
        (company-auctex-init))
      ;; (use-package company-quickhelp
      ;;   :ensure t
      ;;   :config
      ;;   (company-quickhelp-mode 1))
      ;; I like the idea of the company-statistics package, but
      ;; it seems to adversely impact performance and I seem to have
      ;; experienced some lock-ups where emacs stops responding which
      ;; appear to be related to this package (could be wrong). 
      ;; (use-package company-statistics
      ;;   :ensure t
      ;;   :config
      ;;   (company-statistics-mode))
      (eval-after-load 'emacspeak-company-frontend
        (setq company-frontends '(emacspeak-company-frontend
                                  company-pseudo-tooltip-unless-just-one-frontend
                                  company-preview-if-just-one-frontend))))

  #+END_SRC
* Web Browsing 
  Setup ~browse-url~ defaults

  #+BEGIN_SRC emacs-lisp
    (use-package browse-url
      :init
      (if *is-a-mac*
          (setq browse-url-browser-function 'browse-url-default-macosx-browser)
        (setq browse-url-browser-function 'browse-url-default-browser))
      :bind (("C-c C-z ." . browse-url-at-point)
             ("C-c C-z b" . browse-url-of-buffer)
             ("C-c C-z r" . browse-url-of-region)
             ("C-c C-z u" . browse-url)
             ("C-c C-z v" . browse-url-of-file)))
  #+END_SRC
* Local packages
  I put locally managed packages i.e. those not installed via elpa into the lib
  directory.

  #+BEGIN_SRC emacs-lisp
    (use-package ipcalc
      :commands (ipcalc))

   #+END_SRC

* Themes
  I like to use the solarized dark theme

  #+BEGIN_SRC emacs-lisp
    (use-package color-theme-sanityinc-solarized
      :ensure t
      :init (setq-default custom-enabled-themes '(sanityinc-solarized-dark))
      :config
      (defun reapply-themes ()
        "Forcibly load the themes listed in `custom-enabled-themes'."
        (dolist (theme custom-enabled-themes)
          (unless (custom-theme-p theme)
            (load-theme theme)))
        (custom-set-variables `(custom-enabled-themes
                                (quote ,custom-enabled-themes))))
      (add-hook 'after-init-hook 'reapply-themes))

   #+END_SRC
* Windows
  Use ~switch-window~ to provide an easier way to select the specific window I
  want.

  #+BEGIN_SRC emacs-lisp
    (use-package switch-window
      :ensure t
      :init
      (setq-default switch-window-shortcut-style 'alphabet)
      (setq-default switch-window-timeout nil)
      :bind ("C-x o" . switch-window)
      :config
      (defun split-window-horizontally-instead ()
        (interactive)
        (save-excursion
          (delete-other-windows)
          (funcall (split-window-func-with-other-buffer 'split-window-horizontally))))

      (defun split-window-vertically-instead ()
        (interactive)
        (save-excursion
          (delete-other-windows)
          (funcall (split-window-func-with-other-buffer 'split-window-vertically))))

      (global-set-key "\C-x|" 'split-window-horizontally-instead)
      (global-set-key "\C-x_" 'split-window-vertically-instead))
  #+END_SRC
* Custom
  I use different emacs custom files depending on the platform. Need to load
  them

  #+BEGIN_SRC emacs-lisp
    (if *is-a-mac*
        (setq custom-file (expand-file-name "mac-custom.el" user-emacs-directory))
      (setq custom-file (expand-file-name "linux-custom.el" user-emacs-directory)))

    (when (file-exists-p custom-file)
      (load custom-file))
  #+END_SRC
* Fonts
  Setup font related things

  Set default font. I quite like the Source Code Pro font from Adobe.

  #+BEGIN_SRC emacs-lisp
    (if *is-a-mac*
        (set-face-attribute 'default nil
                            :foundry nil
                            :family "Source Code Pro"
                            :height 280)
      (set-face-attribute 'default nil
                          :foundry "adobe"
                          :family "Source Code Pro"
                          :height 138))
  #+END_SRC

  Setup font for emoji
   - Linux users can use Symbola font. Ubuntu/Debian provides Symbola as
     package, ttf-ancient-fonts or ttf-ancient-fonts-symbola. :+1:

  #+BEGIN_SRC emacs-lisp
     (if *is-a-mac*
         (set-fontset-font t 'symbol
                           (font-spec :family "Apple Color Emoji")
                           nil 'prepend)
       (set-fontset-font t 'symbol
                         (font-spec :family "Symbola")
                         nil 'prepend))
  #+END_SRC

  Change font scaling dynamically

  #+BEGIN_SRC emacs-lisp
    (use-package default-text-scale
      :ensure t
      :bind (("C-M-=" . default-text-scale-increase)
             ("C-M--" . default-text-scale-decrease))
      :config
      (defun sanityinc/maybe-adjust-visual-fill-column ()
        "Readjust visual fill column when the global font size is modified.
       This is helpful for writeroom-mode, in particular."
        (if visual-fill-column-mode
            (add-hook 'after-setting-font-hook
                      'visual-fill-column--adjust-window nil t)
          (remove-hook 'after-setting-font-hook
                       'visual-fill-column--adjust-window t)))
      (add-hook 'visual-fill-column-mode-hook
              'sanityinc/maybe-adjust-visual-fill-column))
  #+END_SRC

* Mode line

  Setup powerline to configure the mode-line

  #+BEGIN_SRC emacs-lisp
    (use-package powerline
      :ensure t
      :init
      (setq powerline-display-mule-info nil
            powerline-display-buffer-size nil)
      :config (powerline-default-theme))

    ;; (setq-default header-line-format mode-line-format)
    ;; (setq-default mode-line-format nil)
   #+END_SRC

* Utilities
  Some simple utilities which can be occasionally useful.

** Free Keys
   The ~free-keys~ package provides a convenient way to identify keys which are
   potential bind candidates. Combine this with the
   ~describe-personal-keybindings~ function from the ~bind-keys~ package and
   you can go to town with customising your emacs! 

   #+BEGIN_SRC emacs-lisp
     (use-package free-keys
       :ensure t
       :commands (free-keys))
   #+END_SRC 
* Version Control
  Setup version control stuff

  #+BEGIN_SRC emacs-lisp
    (use-package gh
      :ensure t)

    (use-package git-commit
      :ensure t)
      :config
      (global-git-commit-mode)

    (use-package git-timemachine
      :ensure t
      :commands (git-timemachine-toggle git-timemachine 
                 git-timemachine-switch-browser))

    (use-package github-browse-file
      :ensure t
      :commands (github-browse-file github-browse-file-blame))

    (use-package gitignore-mode
      :ensure t)

    (use-package magit
      :ensure t
      :commands (magit-status magit-dispatch-popup)
      :config
      (global-set-key (kbd "C-x g") 'magit-status)
      (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup))

    (use-package magit-popup
      :ensure t)

   #+END_SRC
* Org Mode
  Start by getting required package. I'm using the org-plus-contrib
  package from the org repository.

  *Note*: Occasionally, you may run into problems when installing org from a
  repository. Essentially the problem can occur if you have some of the bundled
  org files loaded when you try to install a repo version. The easiest way to
  fix this is to reload org mode using the command

  : C-u M-x org-reload

  Then remove the repo package version (in my case, this is org-plus-congtrib)
  and re-install. This will normally ensure a 'stable' environment. 

  #+BEGIN_SRC emacs-lisp 
    (use-package org
      :ensure org-plus-contrib
      :demand t
      :mode ("\\.org\\'" . org-mode)
      :bind (("C-c l" . org-store-link)
             ("C-c a" . org-agenda)
             ("C-c b" . org-iswitchb)
             ("C-c r" . org-capture))
      :init
      (setq org-agenda-files '("~/Dropbox/org/personal.org"
                               "~/Dropbox/org/planner.org"
                               "~/Dropbox/org/policy.org"
                               "~/Dropbox/org/projects.org"
                               "~/Dropbox/org/refile.org"
                               "~/Dropbox/org/security.org"
                               "~/Dropbox/org/urs.org"
                               "~/Dropbox/org/storage.org"
                               "~/Dropbox/org/iam.org")
            org-agenda-remove-tags t
            org-agenda-skip-unavailable-files t
            org-agenda-span 14
            org-catch-invisible-edits 'smart
            org-clock-in-resume t
            org-clock-out-remove-zero-time-clocks t
            org-clock-persist t
            org-clock-persistence-insinuate t
            org-time-clocksum-format '(:hours "%d" :require-hours t
                                              :minutes ":%02d" :require-minutes t)
            org-completion-use-ido t
            org-ctrl-k-protect-subtree t
            org-default-notes-file "~/Dropbox/org/notes.org"
            org-directory "~/Dropbox/org"
            org-enforce-todo-checkbox-dependencies t
            org-enforce-todo-dependencies t
            org-export-backends '(ascii beamer html
                                        icalendar latex
                                        md odt org koma-letter
                                        taskjuggler)
            org-export-kill-product-buffer-when-displayed t
            org-export-with-sub-superscripts nil
            org-export-with-tags nil
            org-hide-block-startup t
            org-html-validation-link nil
            org-list-allow-alphabetical t
            org-list-description-max-indent 5
            org-list-indent-offset 2
            org-log-done 'time
            org-log-into-drawer t
            org-log-refile 'time
            org-outline-path-complete-in-steps t
            org-pretty-entities t
            org-refile-allow-creating-parent-nodes 'confirm
            org-refile-targets (quote ((nil :maxlevel . 5)
                                       (org-agenda-files :maxlevel . 5)))
            org-refile-use-outline-path (quote file)
            org-startup-align-all-tables t
            org-plantuml-jar-path "~/.emacs.d/plantuml/plantuml.jar")
      (setq org-capture-templates
            (quote
             (("t" "todo" entry
               (file "~/Dropbox/org/refile.org")
               "* TODO %?
                                %U
                                %a" :empty-lines-after 1 :clock-in t :clock-resume t)
              ("r" "respond" entry
               (file "~/Dropbox/org/refile.org")
               "* NEXT Respond to %:from on %:subject
                                SCHEDULED: %t
                                %U
                                %a" :empty-lines-after 1 :clock-in t :clock-resume t)
              ("n" "note" entry
               (file "~/Dropbox/org/refile.org")
               "* %? :NOTE:
                                %U
                                %a" :empty-lines-after 1 :clock-in t :clock-resume t)
              ("j" "journal" entry
               (file+datetree "~/Dropbox/org/journal.org")
               "* %?
                                %U" :empty-lines-after 1 :clock-in t :clock-resume t)
              ("p" "phone" entry
               (file "~/Dropbox/org/refile.org")
               "* PHONE %? :PHONE:
                                %U" :empty-lines-after 1 :clock-in t :clock-resume t))))
      (setq org-todo-keywords
            (quote
             ((sequence "TODO(t)"
                        "NEXT(n)"
                        "STARTED(s!)"
                        "DELEGATED(w@/!)"
                        "HOLD(h@/!)"
                        "|"
                        "CANCELLED(c@)"
                        "DONE(d!)"))))
      (setq org-agenda-custom-commands
            (quote
             (("n" "Agenda and all TODO's"
               ((agenda "" nil)
                (alltodo "" nil))
               nil)
              ("wr" "Weekly Report"
               ((todo "DONE|CANCELLED"
                      ((org-agenda-overriding-header "Completed and Cancelled : Last Week")))
                (todo "STARTED|NEXT"
                      ((org-agenda-overriding-header "WIP")))
                (todo "HOLD|DELEGATED"
                      ((org-agenda-overriding-header "On Hold and Delegated Tasks")))
                (todo "TODO"
                      ((org-agenda-overriding-header "Task Backlog"))))
               nil nil))))
      (setq org-latex-classes
            '(("beamer" "\\documentclass[presentation]{beamer}\n[DEFAULT-PACKAGES]\n[PACKAGES]\n[EXTRA]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
              ("article" "\\documentclass[a4paper,12pt]{hitec}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
              ("une-article" "\\documentclass[a4paper,12pt]{article}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
              ("report" "\\documentclass[a4paper,12pt]{scrreprt}"
               ("\\part{%s}" . "\\part*{%s}")
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
              ("book" "\\documentclass[a4paper,12pt]{scrbook}"
               ("\\part{%s}" . "\\part*{%s}")
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
              ("my-letter" "\\documentclass[DIV=14,fontsize=12pt,subject=titled,backaddress=true,fromalign=right,fromemail=true,fromphone=true]{scrlttr2}")))
      (setq org-latex-pdf-process
            '("lualatex -interaction nonstopmode -output-directory %o %f"
              "lualatex -interaction nonstopmode -output-directory %o %f"
              "lualatex -interaction nonstopmode -output-directory %o %f"))
      :config
      ;; (bind-key "C-M-<up>" 'org-up-element)
      (org-babel-do-load-languages
       'org-babel-load-languages
       '(
         ;;(R . t)
         (ditaa . t)
         (dot . t)
         (emacs-lisp . t)
         ;;(gnuplot . t)
         ;;(haskell . nil)
         (latex . t)
         (ledger . t)
         ;;(ocaml . nil)
         ;;(octave . t)
         (python . t)
         (ruby . t)
         (screen . nil)
         (sh . t)
         (sql . nil)
         (sqlite . t)))
      (add-to-list 'org-structure-template-alist
                   '("p" "#+BEGIN_SRC python\n?\n#+END_SRC"
                     "<src lang=\"python\">\n?\n</src>"))
      ;; add <el for emacs-lisp expansion
      (add-to-list 'org-structure-template-alist
                   '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"
                     "<src lang=\"emacs-lisp\">\n?\n</src>")))

    (use-package org-bullets
      :ensure t
      :config
      (add-hook 'org-mode-hook 'org-bullets-mode)
      ;; (font-lock-add-keywords 'org-mode
      ;;                         '(("^ +\\([-*]\\) "
      ;;                            (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
      )

    (use-package org-fstree
      :disabled t
      :ensure t)
   #+END_SRC

** Task Juggler
  I use org-taskjuggler for producing project gant charts etc

  #+BEGIN_SRC emacs-lisp
     (use-package org-taskjuggler
       :disabled t
       :init
       (setq org-taskjuggler-default-global-header
           " timingresolution 60min
                 timezone \"Australia/Sydney\"
                 dailyworkinghours 7
                 workinghours mon - fri 9:00 - 13:00, 14:00 - 17:00
                 workinghours sat, sun off
               "
           org-taskjuggler-default-project-duration 365)
       (setq org-taskjuggler-default-reports
           '("textreport report \"Plan\" {
                 formats html
                 header '== %title =='

                 center -8<-
                   [#Plan Plan] | [#Resource_Allocation Resource Allocation]
                   ----
                   === Plan ===
                   <[report id=\"plan\"]>
                   ----
                   === Resource Allocation ===
                   <[report id=\"resourceGraph\"]>
                 ->8-
               }

               # A traditional Gantt chart with a project overview.
               taskreport plan \"\" {
                 headline \"Project Plan\"
                 columns bsi, name, start, end, effort, chart { width 1500 }
                 loadunit shortauto
                 hideresource 1
               }

               # A graph showing resource allocation. It identifies whether each
               # resource is under- or over-allocated for.
               resourcereport resourceGraph \"\" {
                 headline \"Resource Allocation Graph\"
                 columns no, name, effort, weekly { width 1500 }
                 loadunit shortauto
                 hidetask ~(isleaf() & isleaf_())
                 sorttasks plan.start.up
               }")))

   #+END_SRC

** Some OS X packages
   If running under OS X, there are a couple of additional packages we need

   #+BEGIN_SRC emacs-lisp 
   (when *is-a-mac*
      (use-package org-mac-link
        :disabled t
        :ensure t
        :config
        (bind-key "C-c g" 'org-mac-grb-link org-mode-map)
        (bind-key "M-h" nil)))
  #+END_SRC

** Org pomadoro
  I like to use the pomadoro technique for getting work done.
  See [[https://en.wikipedia.org/wiki/Pomodoro_Technique][Pomadoro Technique]] for details. There is an org package to help with applying
  this technique using org-mode

  #+BEGIN_SRC emacs-lisp 
    (use-package org-pomodoro
      :ensure t
      :disabled t
      :config
      (after-load 'org-agenda
        (define-key org-agenda-mode-map (kbd "P") 'org-pomodoro)))
  #+END_SRC

* Searching
  Using ~ag~ package for searches. This needs some OS support
  - On Linux ~apt-get install silversearcher-ag~
  - On OSX ~brew install the_silver_searcher~

    #+BEGIN_SRC emacs-lisp
      (use-package ag
        :ensure t
        :commands (ag ag-files ag-regex ag-project ag-project-files ag-project-regexp)
        :config
        (global-set-key (kbd "M-?") 'ag-project))
    #+END_SRC
* Projectile 
  #+BEGIN_SRC emacs-lisp
    (use-package projectile
      :ensure t
      :diminish projectile-mode
      :commands (projectile-mode
                 projectile-global-mode)
      :init
      (add-hook 'prog-mode-hook 'projectile-mode))
  #+END_SRC
* Markdown
  setup for handling various markdown/markup formats

  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode
      :defer t
      :commands (markdown-mode gfm-mode)
      :mode (("\\.markdown\\'" . markdown-mode)
             ("\\.md\\'" . markdown-mode)))


    (use-package gh-md
      :ensure t
      :commands (gh-md-render-buffer gh-md-render-region))

    (use-package markdown-preview-eww
      :ensure t
      :commands (markdown-peview-eww))

    (use-package markdown-toc
      :ensure t
      :commands (markdown-toc-generate-toc))
  #+END_SRC
* Programming
  Setup stuff most useful when writing code
** Paredit
   This mode was a little tricky at first, but now I'm use to it, I miss it when
   it isn't there. 

   #+BEGIN_SRC emacs-lisp
      (use-package paredit
        :ensure t
        :diminish paredit-mode
        :commands (enable-paredit-mode disable-paredit-mode paredit-mode)
        :init
        (defun maybe-map-paredit-newline ()
          (unless (or (memq major-mode '(inferior-emacs-lisp-mode
                                         cider-repl-mode))
                      (minibufferp))
            (local-set-key (kbd "RET") 'paredit-newline)))

        (add-hook 'paredit-mode-hook 'maybe-map-paredit-newline)
        :config
        (defvar paredit-minibuffer-commands '(eval-expression
                                              pp-eval-expression
                                              eval-expression-with-eldoc
                                              ibuffer-do-eval
                                              ibuffer-do-view-and-eval)
          "Interactive commands where paredit should be enabled in minibuffer.")

        (defun conditionally-enable-paredit-mode ()
          "Enable paredit during lisp-related minibuffer commands."
          (if (memq this-command paredit-minibuffer-commands)
              (enable-paredit-mode)))

        (add-hook 'minibuffer-setup-hook 'conditionally-enable-paredit-mode)
        (dolist (binding (list (kbd "C-<left>") (kbd "C-<right>")
                               (kbd "C-M-<left>") (kbd "C-M-<right>")))
          (define-key paredit-mode-map binding nil))
        ;; Modify kill-sentence, which is easily confused with the kill-sexp
        ;; binding, but doesn't preserve sexp structure
        (define-key paredit-mode-map [remap kill-sentence] 'paredit-kill)
        (define-key paredit-mode-map [remap backward-kill-sentence] nil))

     (use-package paredit-everywhere
       :ensure t
       :commands (paredit-everywhere-mode)
       :config
       (add-hook 'prog-mode-hook 'paredit-everywhere-mode))
   #+END_SRC

** Emacs Lisp
   Configure lisp modes. 

   Add the ~elisp-slime-nave~ package to get some nice nav functions from slime.

   #+BEGIN_SRC emacs-lisp
     (use-package elisp-slime-nav
       :ensure t
       :diminish elisp-slime-nav-mode
       :config
       (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
              (add-hook hook 'turn-on-elisp-slime-nav-mode)))
   #+END_SRC

   Add the ~lively~ package

   #+BEGIN_SRC emacs-lisp
     (use-package lively
       :ensure t
       :commands (lively lively-region))
   #+END_SRC

   Use ~ipretty~ to improve display of eval results 

   #+BEGIN_SRC emacs-lisp
     (use-package ipretty
       :ensure t
       :init
       (defadvice pp-display-expression (after tx/make-read-only (expression out-buffer-name) activate)
         "Enable `view-mode' in the output buffer - if any - so it can be closed with `\"q\"."
         (when (get-buffer out-buffer-name)
           (with-current-buffer out-buffer-name
             (view-mode 1))))
       :commands (ipretty-mode))
   #+END_SRC

   Setup ~lisp-mode~

   #+BEGIN_SRC emacs-lisp
     (use-package lisp-mode
       :init
       (add-hook 'lisp-mode-hook 'rainbow-delimiters-mode)
       (add-hook 'lisp-mode-hook 'enable-paredit-mode)
       (setq-default initial-scratch-message ";; Elisp scratch buffer\n")

       (defun setup-hippie-expand-for-elisp ()
         "Locally set `hippie-expand' completion functions for use with Emacs Lisp."
         (make-local-variable 'hippie-expand-try-functions-list)
         (add-to-list 'hippie-expand-try-functions-list
                      'try-complete-lisp-symbol t)
         (add-to-list 'hippie-expand-try-functions-list
                      'try-complete-lisp-symbol-partially t)
         (add-to-list 'hippie-expand-try-functions-list
                      'my/try-complete-lisp-symbol-without-namespace t))

       (defun my-elisp-setup ()
         (ipretty-mode 1)
         (setup-hippie-expand-for-elisp)
         (enable-paredit-mode))

       (add-hook 'emacs-lisp-mode-hook 'my-elisp-setup)
       (add-hook 'emacs-lisp-mode-hook (lambda () (setq mode-name "ELisp")))

       :config
       (rainbow-mode 1)
       (add-hook 'after-save-hook  'check-parens nil t)
       (defun tx/eval-last-sexp-or-region (prefix)
         "Eval region from BEG to END if active, otherwise the last sexp."
         (interactive "P")
         (if (and (mark) (use-region-p))
             (eval-region (min (point) (mark)) (max (point) (mark)))
           (pp-eval-last-sexp prefix)))

       (bind-key "M-:" 'pp-eval-expression)
       (bind-key "C-x C-e" 'tx/eval-last-sexp-or-region emacs-lisp-mode-map))
   #+END_SRC

** Clojure
   Setup ~clojure-mode~ and ~cider~. 

   #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode
       :ensure t
       :commands (clojure-mode)
       :mode (("\\.\\(clj\\|dtm\\|edn\\)\\'" . clojure-mode)
              ("\\.cljc\\'" . clojure-mode)
              ("\\.cljx\\'" . clojure-mode)
              ("\\.cljs\\'" . clojure-mode)
              ("\\(?:build\\|profile\\)\\.boot\\'" . clojure-mode)))

     (use-package cljsbuild-mode
       :ensure t
       :commands (cljsbuild-mode cljsbuild-start))

     (use-package elein
       :ensure t
       :commands (elein-run-cmd elein-run-task))

     (use-package cider
       :ensure t
       :commands (cider-jack-in cider-jack-in-clojurescript 
                                cider-connect cider-apropos cider-apropos-documentation
                                cider-browse-ns cider-browse-ns-all cider-classpath
                                cider-open-classpath-entry cider-debug-defun-at-point
                                cider-grimoire-web cider-grimoire cider-inspect-last-sexp
                                cider-inspect-defun-at-point cider-inspect
                                cider-macroexpand-1 cider-macroexpand-all
                                cider-mode cider-scratch cider-selector)
       :config
       (bind-key "C-c M-j" 'cider-jack-in clojure-mode-map)
       (bind-key "C-c M-J" 'cider-connect clojure-mode-map))

     ;; (use-package ac-cider
     ;;   :ensure t
     ;;   :config
     ;;   (add-hook 'cider-mode-hook 'ac-flyspell-workaround)
     ;;   (add-hook 'cider-mode-hook 'ac-cider-setup)
     ;;   (add-hook 'cider-repl-mode-hook 'ac-cider-setup)
     ;;   (add-to-list 'ac-modes 'cider-mode)
     ;;   (add-to-list 'ac-modes 'cider-repl-mode))

     (use-package clj-refactor
       :ensure t
       :config
       (defun my-clojure-mode-hook ()
         (clj-refactor-mode 1)
         (yas-minor-mode 1) ; for adding require/use/import statements
         ;; This choice of keybinding leaves cider-macroexpand-1 unbound
         (cljr-add-keybindings-with-prefix "C-c C-m"))

       (add-hook 'clojure-mode-hook #'my-clojure-mode-hook))
   #+END_SRC
** SQL
   #+BEGIN_SRC emacs-lisp
      (use-package sql
        :init
        (setq-default sql-input-ring-file-name
                      (expand-file-name ".sqli_history" user-emacs-directory))
        (defun tx/pop-to-sqli-buffer ()
          "Switch to the corresponding sqli buffer."
          (interactive)
          (if sql-buffer
              (progn
                (pop-to-buffer sql-buffer)
                (goto-char (point-max)))
            (sql-set-sqli-buffer)
            (when sql-buffer
              (tx/pop-to-sqli-buffer))))
        :config
        (use-package sql-indent
          :ensure t)
        (bind-key "C-c C-z" 'tx/pop-to-sqli-buffer sql-mode-map)
        (add-hook 'sql-interactive-mode-hook 'tx/never-indent))
   #+END_SRC
* Emacs Server
  Start the emacs server so that we can use emacsclient

  #+BEGIN_SRC emacs-lisp
    (use-package server
      :config
      (server-start))

    #+END_SRC
