* Header
  #+BEGIN_SRC emacs-lisp
  ;; Filename: init.el
  ;; Last Modified: Saturday, 22 August 2015 04:03 PM AEST
  #+END_SRC

* Introduction
  This is my experiment on using org-mode and it's support for /literate programming/
  using /org-babel/. For those that don't know, literate programming is a technique
  introduced by Donald Knuth, who also wrote the TeX document formatting system as
  well as the excellent [[http://www.amazon.com/Computer-Programming-Volumes-1-4A-Boxed/dp/0321751043][The Art of Computer Programming]], one of the best programming
  books I've ever read.

  In literate programming, text and code are mixed together in one file. This allows
  you to have a single source file which can be used to generate detailed
  documentation and source code files. Unlike source code comments, you can actually
  write about what the source code does and provide quite in-depth documentation
  which can also show the reasoning and rationale for design decisions, assumptions,
  constraints and anything else which might make it easier to understand thee
  code and why certain decisions were made. This can be especially useful when
  you revisit the code some time later and can't remember all the details or thoughts
  which drove the original design and implementation decisions.

  Literate programming is something I've always thought was interesting, but have
  rarely applied in a consistent fashion. Unfortunately, a little like my use of unit
  testing and test driven development. In this case, I have some additional
  motivation. It is possible that by structuring my emacs configuration code in this
  way, it may be useful as an example to others. There are lots of example emacs
  configurations out there, but often the terse and short comments are not sufficient
  to explain why a certain configuration option is used or exactly what it
  does. While this can be OK, it has a significant limitation. Others end up using
  the code without sufficient understanding of what it does or how it works. As a
  result, when they run into configuration problems or decide certain enabled
  features don't fit with their work flow, they don't understand what is going on,
  making it harder to fix or change. 

  I make no claims that this is a good setup or even a correct setup. It is my setup
  and for now works for me. There are plenty of areas where it could be improved and
  there are lots of bits I plan to tweak at some point. Lots of the ideas in my
  configuration have been /borrowed with pride/ from the configurations of
  others. Most of the time, I don't attribute these stolen configuration settings,
  not because I don't want to attribute them, but because I usually don't remember
  where I got it from. Likewise, if you want to use any of the code from my setup in
  your own configuration, please feel free to do so and know there is absolutely no
  expectation on my part for attribution or recognition.

  This configuration was ported from my existing collection of elisp files. As some
  of it was very old and as I wanted to just get this up and running, the
  accompanying text is not great. In many cases, I have not yet realised the full
  value of the literate programming methodology because this was not written from
  scratch. I plan to add more explanation and descriptions as the file evolves. At
  the moment, there is lots of stuff which lacks any documentation. 

  This configuration also contains a number of init files for emacs modes which I
  rarely use or don't use any longer. I leave these configurations in place just in
  case I need these modes in the future. However, this also means that my
  configuration can be out of date as modes are updated and new versions come
  out. This is especially the case these days as I use the emacs lisp package
  management support as packages are updated more regularly than they once use to
  be. 

  This means you may find configuration settings in this file which are out of date
  or incorrect. Use at your own risk. 

  *WARNING* Note that I make extensive use of ELPA and packages from repositories
   such as MELPA. The configuration is such that these packages will be automatically
   downloaded and installed if they are not found when emacs starts. This can have a
   couple of consequences;

   1. Initial startup may be slow and may involve downloading quite a few packages
      from the Internet. If your on a slow link, this could be an issue
   2. Due to the number of packages being downloaded and possible interaction between
      these packages, I have observed temporary instability in the system. A restart
      of emacs usually fixes any issues.
   3. If any of the required packages are not available for some reason, there may be
      unexpected startup problems or errors reported.
   4. for emacspeak users, I have run into minor issues when the speech server has
      died during the loading of these packages. This normally isn't a big issue and
      in the worst case, exiting emacs and starting it again usually fixes any
      problems. Often, simply restarting the speech server will be sufficient. 

* Emacspeak
  I have been using Emacspeak for about 18 years. For those unfamiliar with
  emacspeak, it is a quite remarkable package, developed by T. V. Raman, which
  provides blind and vision impaired users with a complete audio desktop. Information
  on EmacsSpeak can be found at [[http://emacspeak.sourceforge.net/][the emacspeak homepage]].

  I mainly mention my use of emacspeak because it has an impact on how I manage my
  emacs configuration. One of the challenges faced by blind and vision impaired users
  who depend on a package to make an application accessible is that making changes to
  how the application is configured can result in key packages or configuration code
  not loading correctly. For blind and vision impaired users, this can result in a
  catch 22. You need the package in order to gain the access necessary to fix the
  configuration error, but because of the configuration error, you cannot load the
  package.

  To reduce the risk of this happening, I have a very simple shell script which will
  start emacs with nothing else loaded except emacspeak. While not a perfect
  solution, it can help in an emergency. The shell script is

  #+BEGIN_SRC sh :tangle emergency.sh
    #!/bin/sh

    exec emacs -q -l ~/.emacs.d/emergency.el
  #+END_SRC

  and the emergency.el file consists of

  #+BEGIN_SRC emacs-lisp :tangle emergency.el
    (defconst *is-a-mac* (eq system-type 'darwin))

    (if *is-a-mac*
        (progn
          (defconst *emacspeak-src-dir* "~/src/emacspeak")
          (defconst *emacspeak-server* "mac"))
      (defconst *emacspeak-src-dir* "~/git/emacspeak/trunk")
      (defconst *emacspeak-server* "outloud"))

    (add-to-list 'Info-default-directory-list (concat *emacspeak-src-dir* "/info"))

    (when (and (not noninteractive)
               (not (featurep 'emacspeak)))
      (add-to-list 'load-path *emacspeak-src-dir*)
      (setenv "EMACSPEAK_DIR" *emacspeak-src-dir*)
      (setq dtk-program *emacspeak-server*)
      (setenv "DTK_PROGRAM" *emacspeak-server*)
      (setq tts-default-speech-rate 90)
      (setq outloud-default-speech-rate 90)
      (setq mac-default-speech-rate 400)
      (add-hook 'emacspeak-startup-hook
                (lambda ()
                  (dtk-set-rate tts-default-speech-rate 1)
                  (dtk-interp-sync)))
      (load-file (concat *emacspeak-src-dir* "/lisp/emacspeak-setup.el")))
  #+END_SRC

  You will notice that I do not use a pre-packaged version of emacspeak. This is for
  two reasons
  - EmacSpeak is very easy to install from sources
  - EmacSpeak is constantly being improved by T. V. Raman and packaged versions
    provided by distributions are almost always out of date

  My approach is to run EmacSpeak directly from the Git code repository on
  [[https://github.com/tvraman/emacspeak.git][GitHub]]. I don't bother with installing emacspeak /system wide/ and therefore don't
  do the ~make install~ target in the emacspeak Makefile. Instead, I just clone the
  GitHub repository into a directory under my home directory and run directly from
  there. I tell emacs what the path is to the sources and run it directly
  from there. This has three advantages
  - I can get the latest code by just running ~git pull~ and then all I need to
    do is ~make clean~, ~make config~ and then ~make emacspeak~ and restart emacs
  - I sometimes like to tweak the emacspeak code base. Keeping all of this in git
    means I can easily create branches, merge with latest versions or revert back to
    the stock standard code base. Git will even help manage merging of my changes.
  - If I check out a new version of emacspeak and merge it with my modifications and
    then find it doesn't work, it is trivial to revert back to a previous working
    version, get emacs and emacspeak working again and then investigate why it didn't
    work. 

* Overview
  My general approach to managing my emacs configuration is to prefer having it in
  configuration files I manage rather than using the built-in customization support
  of emacs. This is just a matter of personal taste. I would recommend that new users
  use the built in /custom/ interface initially. Emacs customisation can be complex
  and is easy to get wrong, especially for beginners. Using the /custom/ mechanism
  can lower the learning curve and allow you to tweak things while your learning the
  basics of the editor.

  All emacs users will at some point encounter errors and problems with their emacs
  configuration. Therefore it is important that you structure your configuration
  setup in a way which will make it easier to track down problems. I achieve this by

  - Breaking up my setup into separate task specific configuration files
  - Keep my /root/ config file i.e. =.emacs.d/init.el= as simple as possible

  My =emacs.d/init.el= file consists mainly of statements which require other
  files. These other files represent specific configuration groups. The advantage
  with doing this is that I can easily remove a configuration by just commenting out
  the require statement. This can be really helpful when debugging problems in my
  config.

  One of the first things my =init.el= file does is add a directory =.emacs.d/lisp=
  to the load path. This directory contains all my topic specific init files. All the
  =require= statements in my main =init.el= file which start with =init-= refer to
  files in the =.emacs.d/lisp= directory.

** Debuggin Problems
   When you encounter a problem in emacs, it is usually due to one of 4 problems. In
   order of likelihood, these are

   1. Error in your config file
   2. Error in a package you are loading
   3. Error in the site wide configuration file used by emacs
   4. Error in emacs itself

   In almost 20 years of emacs use, I think there has only been a couple of times
   that I've had problems due to a bug in emacs. Almost without exception, these bugs
   have already been known and were being worked on. Usually, there would also be a
   workaround. If you are using a stable version of emacs and you think you have
   found a bug, you are almost certainly wrong. Most likely, the /bug/ you think  you
   have found is either due to an error in your configuration or due to an error in
   an add-on package you are using. If your using a development version of emacs, you
   are more likely to find a bug, but that is to be expected when your living on the
   bleeding edge.

   To determine if a problem is a bug in emacs or a problem with your configuration
   file, the first thing to do is run emacs with the -q switch (or, if you rely on
   emacspeak, use something like my emergency emacs configuration which is equivalent
   to running with -q plus adding just emacspeak). If you run with -q and cannot
   reproduce the problem, then the issue is either with your config file or one of
   the additional packages your loading.

*** Useful Command Line Switches
    Emacs has some very useful command line switches which will help track down
    problems in your config files.
    - *-q* The -q switch stops your config file from being loaded. Useful to do this
      to ensure the problem is actually due to your config and not a bug in emacs
      itself.

    - *--debug-init* The ~--debug-init~ switch will provide more details on the error
      which is preventing your config file from loading correctly. Without this
      switch, emacs just reports there was a problem loading your init file, it does
      not give you any details on what that problem was or where it happend. Often,
      just running with this switch will pinpoint the problem.

*** Divide and Conquer
   The easiest way to track down problems with our config and loaded packages is to
   use a divide and conquer approach. You start by commenting out half your =init.el=
   file and try running emacs again. If emacs starts up and you cannot reproduce the
   problem, the you know the problem is in the half of your config you commented
   out. If on the other hand, emacs still will not start correctly or you are still
   able to reproduce the problem, then you know the issue is being cause by something
   in the un-commented part of your config file. You have now halved your search
   space for the problem.

   Once you have identified the half of your config file which has the problem, you
   repeat the same process. Comment out half of that half and run emacs. If the
   problem occurs, you have identified the quarter of your config file where the
   problem lies. If it doesn't, you know the problem is in the commented half. You
   can now repeat the process again, cutting down to an eighth. continue the process
   and you will eventually be down to a single line. However, most of the time, you
   will see the problem long before that point.

*** Don't spiral down into confusion 
    One of the most common mistakes I see people make when trying to solve
    configuration problems is in how they change their configuration file. Too often,
    I see people start debugging their config file by making a change, seeing if that
    fixed it and when it doesn't, making another change, repeating the cycle with new
    changes added each time. The problem with this approach is that more often than
    not, you will add new issues and create an even harder problem to solve. I call
    this spiralling into confusion. You start with a single problem and then end up
    with multiple problems and get more and more confused as to what the problem is.  

    It is very important that when you make a change to your config file and then
    test it, if the change makes no definite improvement, remove it and revert back
    to what the code was prior to the change. Don't just leave the change there and
    move on. 

    When you make a change to a config file, it can have three possible impacts
    1. It fixes the problem
    2. It does not fix the original problem, but adds a new problem which may not be
       obvious because it is being masked by the original problem
    3. It has no effect at all.

    It is rare that adding/changing a config setting will have absolutely no
    effect. Most of the time, something will be affected, it just may not be obvious
    what it is. When your trying to fix a problem, it is crucial to ensure all the
    dependent variables are as stable as possible. As it isn't always clear which
    things are dependent and which are independent, we must try to keep change to a
    minimum. 
  
    Therefore, when you make a change, test it and find it doesn't fix the problem,
    revert the change back to the original value. Don't just leave it there and
    change something else unless you know with great certainty that the change you
    made is correct and beneficial. 

* Generating the Configuration Files
  To generate the emacs configuration files from this org file, do the following
  - Create the directory to hold the configuration files. For example, to put them in
    =.emacs.d= within your home directory, do the following
    #+BEGIN_EXAMPLE
    cd $HOME
    mkdir .emacs.d
    mkdir .emacs.d/lisp
    #+END_EXAMPLE
  - Put the init.org file in the =.emacs.d= directory. Note that this directory
    *must* also contain a sub-directory called =lisp=.
  - Start emacs and open the =init.org= file
  - Run the command ~M-x org-babel-load-file~.

  After doing this, you should see an =init.el= and =emergency.el= files in
  =.emacs.d= and a number of files which begin with =init-= in the =/lisp=
  directory. You should then be able to exit emacs and when you restart, have this
  configuration loaded. Note that there could be some errors, because of things which
  may be specific to my setup. I wouldn't want to make it too easy! If you do run
  into errors, just comment out the offending lines and try again.

  Once you have run =org-babel-load-file= you can use ~C-x C-v C-f~ to /tangle/ the
  file and generate the code files. If you make changes, do this to refresh the
  code files or just run ~M-x org-babel-load-file~ again, giving init.org as the
  input file..

** How it Works
   The init.org file consists of text and a lot of org mode source code blocks. The
   source code blocks look like

   #+BEGIN_EXAMPLE
     BEGIN_SRC emacs-lisp
     .... elsip source code
     END_SRC
   #+END_EXAMPLE

   When you /tangle/ the file, these code blocks are extracted and written to the
   init.el file as emacs lisp code. You can also include an additional ~:tangle~
   directive on the first line, which will specify an alternative target file. I use
   this mechanism to break my config up into separate *.el files. 

   Org-mode provides a number of support mechanisms to make writing these code blocks
   easy, including templates and the ability to edit the code block in a separate
   window which is opened using the default mode for the language you are writing,
   for example, emacs-lisp mode. 

* Basic Setup
  This section contains the basic minimum configuration stuff I need in my init.el file

** Add to load path
  Start by adding the directory containing my topic specific configuration files
  #+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
  #+END_SRC

** Set flag for operating platform
  I run emacspeak on both my Linux desktop and my Apple laptop. However, they require
  slightly different configuration options. Therefore I define a constant
  =*is-a-mac*=, which will be =t= if we are ruining on OS X. I can then use
  this variable to control what settings are applied
  #+BEGIN_SRC emacs-lisp
  (defconst *is-a-mac* (eq system-type 'darwin))
  #+END_SRC

** Set flag to turn on spell checking
  I also define a constant to control the enabling of spell checking support. Stole
  this from somewhere because it looked like a good idea. Not sure I really need it
  #+BEGIN_SRC emacs-lisp
  (defconst *spell-check-support-enabled* t)
  #+END_SRC

** Load Emacspeak
  Now load EmacSpeak. As EmacSpeak makes extensive use of Emacs' =defacvice=
  facility, it is important that it is loaded as early as possible in the Emacs boot
  process.
  #+BEGIN_SRC emacs-lisp
  (require 'init-emacspeak)
  #+END_SRC
*** init-emacspeak.el
    We use different speech server setting on Linux and OS X
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-emacspeak.el
      (defconst *emacspeak-src-dir* "~/git/emacspeak/trunk")

      (if *is-a-mac*
          (defconst *emacspeak-server* "mac")
        (defconst *emacspeak-server* "outloud"))

    #+END_SRC
    
    Add the EmacsSpeak info documentation to the info search path. From within Info,
    you can hit ~g~ and then enter ~(emacspeak)~ at the prompt to open the EmacSpeak
    info documentation
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-emacspeak.el
    (add-to-list 'Info-default-directory-list (concat *emacspeak-src-dir* "/info"))
    #+END_SRC

    When emacs is not being run in batch mode and when emacspeak is not yet loaded,
    then load it
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-emacspeak.el
      (when (and (not noninteractive)
                 (not (featurep 'emacspeak)))
        (add-to-list 'load-path *emacspeak-src-dir*)
        (setenv "EMACSPEAK_DIR" *emacspeak-src-dir*)
        (setenv "DTK_PROGRAM" *emacspeak-server*)
        (setq dtk-program *emacspeak-server*)
        (setq dtk-use-tones nil)
        (setq emacspeak-mail-alert nil)
        (setq tts-default-speech-rate 90)
        (setq outloud-default-speech-rate 90)
        (setq emacspeak-vm-use-raman-settings nil)
        (setq mac-default-speech-rate 400)
        (setq emacspeak-erc-my-nick "theophilusx")
        (setq emacspeak-erc-speak-all-participants t)
        (setq emacspeak-play-program "/home/tcross/bin/play")
        (setq emacspeak-play-args nil)
        (if *is-a-mac*
            (progn
              (setq emacspeak-soxplay-command "/usr/local/bin/play -v 2 %s earwax &")
              (setq sox-play "/usr/local/bin/play"))
          (setq emacspeak-soxplay-command "/usr/bin/play -v 2 %s earwax &")
          (setq sox-play "/usr/bin/play"))
        (setq emacspeak-auditory-icon-function 
              'emacspeak-soxplay-auditory-icon)
        (add-hook 'emacspeak-startup-hook
                  (lambda ()
                    (dtk-set-rate tts-default-speech-rate 1)
                    (dtk-interp-sync)
                    (emacspeak-sounds-select-theme "chimes-stereo/")
                    (emacspeak-toggle-auditory-icons t)))
        (load-file (concat *emacspeak-src-dir* "/lisp/emacspeak-setup.el")))
    #+END_SRC

    I actually don't want some of the global key bindings defined by emacspeak, so
    I'll undefine them before loading other packages.
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-emacspeak.el
      (with-eval-after-load 'emacspeak-keymap
        (global-unset-key [(shift left)])
        (global-unset-key [(shift right)])
        (global-unset-key [(control left)])
        (global-unset-key [(control right)])
        (global-unset-key [(control down)])
        (global-unset-key [(control up)])
        (global-unset-key [(shift up)])
        (global-unset-key [(shift down)])
        (global-unset-key [27 up])
        (global-unset-key  [27 down])
        (global-unset-key  [27 prior])
        (global-unset-key  [27 next])
        (global-unset-key  [27 select]))

      (provide 'init-emacspeak)
    #+END_SRC
** Setup package repositories
   These days I make extensive use of =package.el= the Emacs lisp package manager. It
   is quite unbelievable how much easier this has made life. I do this early in my
   init as I also like to override some of the standard packages from the official
   GNU package archive with ones from other archives which tend to be more up-to-date.
  #+BEGIN_SRC emacs-lisp
    (when *is-a-mac*
      (let ((default-directory "/usr/local/share/emacs/site-lisp"))
        (normal-top-level-add-subdirs-to-load-path)))

    (require 'init-elpa)
  #+END_SRC
*** init-elpa.el
    This is the basic package management setup
    
    First, we need to load package.el and then we need to add some additional package
    repositories. I hadd
    - The Org repository so that I can use most recent org-plus-contrib package
    - Add the melpa repository
    - Add the melpa stable repository
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-elpa.el
      (require 'package)

      (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
      (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
      ;;;(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))

    #+END_SRC

    Define a helper function to install packages. This one allow use to set minimum
    versions and to prevent the package list from being refreshed 
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-elpa.el
      (defun require-package (package &optional min-version no-refresh)
        "Install given PACKAGE, optionally requiring MIN-VERSION.
      If NO-REFRESH is non-nil, the available package lists will not be
      re-downloaded in order to locate PACKAGE."
        (if (package-installed-p package min-version)
            t
          (if (or (assoc package package-archive-contents) no-refresh)
              (package-install package)
            (progn
              (package-refresh-contents)
              (require-package package min-version t)))))
    #+END_SRC

    Another helper function. This is for when we would like to install a package, but
    if it isn't available, we don't want to exit with an error. Instead we want to
    just warn the user and continue processing. 
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-elpa.el
      (defun maybe-require-package (package &optional min-version no-refresh)
        "Try to install PACKAGE, and return non-nil if successful.
      In the event of failure, return nil and print a warning message.
      Optionally require MIN-VERSION.  If NO-REFRESH is non-nil, the
      available package lists will not be re-downloaded in order to
      locate PACKAGE."
        (condition-case err
            (require-package package min-version no-refresh)
          (error
           (message "Couldn't install package `%s': %S" package err)
           nil)))

      ;; kick it
      (setq package-enable-at-startup nil)
      (package-initialize)

      (provide 'init-elpa)

    #+END_SRC

** Utility Functions
   #+BEGIN_SRC emacs-lisp
   (require 'init-utils)
   #+END_SRC

*** init-utils.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-utils.el
      (if (fboundp 'with-eval-after-load)
          (defalias 'after-load 'with-eval-after-load)
        (defmacro after-load (feature &rest body)
          "After FEATURE is loaded, evaluate BODY."
          (declare (indent defun))
          `(eval-after-load ,feature
             '(progn ,@body))))

      ;; Handier way to add modes to auto-mode-alist
      (defun add-auto-mode (mode &rest patterns)
        "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
        (dolist (pattern patterns)
          (add-to-list 'auto-mode-alist (cons pattern mode))))

      ;; String utilities missing from core emacs
      (defun sanityinc/string-all-matches (regex str &optional group)
        "Find all matches for `REGEX' within `STR', returning the full match string or group `GROUP'."
        (let ((result nil)
              (pos 0)
              (group (or group 0)))
          (while (string-match regex str pos)
            (push (match-string group str) result)
            (setq pos (match-end group)))
          result))

      (defun sanityinc/string-rtrim (str)
        "Remove trailing whitespace from `STR'."
        (replace-regexp-in-string "[ \t\n]+$" "" str))

      ;; Find the directory containing a given library
      (autoload 'find-library-name "find-func")
      (defun sanityinc/directory-of-library (library-name)
        "Return the directory in which the `LIBRARY-NAME' load file is found."
        (file-name-as-directory (file-name-directory (find-library-name library-name))))

      ;; Delete the current file
      (defun delete-this-file ()
        "Delete the current file, and kill the buffer."
        (interactive)
        (or (buffer-file-name) (error "No file is currently being edited"))
        (when (yes-or-no-p (format "Really delete '%s'?"
                                   (file-name-nondirectory buffer-file-name)))
          (delete-file (buffer-file-name))
          (kill-this-buffer)))

      ;; Rename the current file
      (defun rename-this-file-and-buffer (new-name)
        "Renames both current buffer and file it's visiting to NEW-NAME."
        (interactive "sNew name: ")
        (let ((name (buffer-name))
              (filename (buffer-file-name)))
          (unless filename
            (error "Buffer '%s' is not visiting a file!" name))
          (if (get-buffer new-name)
              (message "A buffer named '%s' already exists!" new-name)
            (progn
              (when (file-exists-p filename)
                (rename-file filename new-name 1))
              (rename-buffer new-name)
              (set-visited-file-name new-name)))))

      ;; Browse current HTML file
      (defun browse-current-file ()
        "Open the current file as a URL using `browse-url'."
        (interactive)
        (let ((file-name (buffer-file-name)))
          (if (tramp-tramp-file-p file-name)
              (error "Cannot open tramp file")
            (browse-url (concat "file://" file-name)))))

      (provide 'init-utils)

    #+END_SRC

** Emacs exec path
   Configure the exec path used by emacs
  #+BEGIN_SRC emacs-lisp
    (require 'init-exec-path)
  #+END_SRC
*** init-exec-path.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-exec-path.el
      (require-package 'exec-path-from-shell)

      (after-load 'exec-path-from-shell
        (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID"
                       "GPG_AGENT_INFO" "LANG"
                       "LC_CTYPE"))
          (add-to-list 'exec-path-from-shell-variables var)))

      (when *is-a-mac*
        (exec-path-from-shell-initialize))

      (provide 'init-exec-path)

    #+END_SRC
** Custom
   We use different custom files on Linux and OS X. Originally, this was so that I
   could just keep all my init files in Dropbox or in a git repository. 
   #+BEGIN_SRC emacs-lisp
     (if *is-a-mac*
         (setq custom-file (expand-file-name "mac-custom.el" user-emacs-directory))
       (setq custom-file (expand-file-name "linux-custom.el" user-emacs-directory)))
   #+END_SRC

   Load the custom file if it exists 
   #+BEGIN_SRC emacs-lisp
     (when (file-exists-p custom-file)
       (load custom-file))
   #+END_SRC
* Basic feature packages
  The =init-elpa.el= package contains some utility functions to assist with loading
  packages. In particular =require-package=, which is used to load a number of useful
  packages.
  #+BEGIN_SRC emacs-lisp
    (require-package 'diminish)
    (require-package 'sx)
    (require-package 'swiper)
    (require-package 'discover)
    (require-package 'discover-my-major)
    (require-package 'smartscan)
    (require-package 'goto-chg)
    (require-package 'auctex)
  #+END_SRC
* Topic specific configurations
  Set the topic specific configurations by =requiring= the init files from the
  =/lisp= directory.
** Undo Tree
   #+BEGIN_SRC emacs-lisp
   (require 'init-undo-tree)
   #+END_SRC
*** init-undo-tree.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-undo-tree.el
      (require-package 'undo-tree)

      (require 'undo-tree)

      (global-undo-tree-mode)

      (provide 'init-undo-tree)

    #+END_SRC
** Emacs Themes
   Yes, even with less than 10% vision, I like to use an emacs theme! In fact, with
   my specific vision impairment, the right theme makes looking at the screen much
   easier and with less glare.
   #+BEGIN_SRC emacs-lisp
   (require 'init-themes)
   #+END_SRC
*** init-themes.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-themes.el
      (require-package 'color-theme-sanityinc-solarized)
      (require-package 'color-theme-sanityinc-tomorrow)

      (setq-default custom-enabled-themes '(sanityinc-solarized-dark))

      ;; Ensure that themes will be applied even if they have not been customized
      (defun reapply-themes ()
        "Forcibly load the themes listed in `custom-enabled-themes'."
        (dolist (theme custom-enabled-themes)
          (unless (custom-theme-p theme)
            (load-theme theme)))
        (custom-set-variables `(custom-enabled-themes (quote ,custom-enabled-themes))))

      (add-hook 'after-init-hook 'reapply-themes)

      ;; toggle between light and dark themes
      (defun light ()
        "Activate a light color theme."
        (interactive)
        (color-theme-sanityinc-solarized-light))

      (defun dark ()
        "Activate a dark color theme."
        (interactive)
        (color-theme-sanityinc-solarized-dark))

      (provide 'init-themes)

    #+END_SRC
** Fonts
   #+BEGIN_SRC emacs-lisp
   (require 'init-fonts)
   #+END_SRC

*** init-fonts.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-fonts.el
      (if *is-a-mac*
          (set-face-attribute 'default nil
                              :foundry "apple"
                              :family "Menlo"
                              :height 260)
        (set-face-attribute 'default nil
                            :foundry "unknown"
                            :family "Anonymous Pro"
                            :height 160))

      (provide 'init-fonts)

    #+END_SRC
** OSX keys
   Make the OS X keyboard behave as expected
   #+BEGIN_SRC emacs-lisp
   (require 'init-osx-keys)
   #+END_SRC
*** init-osx-keys.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-osx-keys.el
      (when *is-a-mac*
        (setq mac-command-modifier 'meta)
        (setq mac-option-modifier 'none)
        (setq default-input-method "MacOSX")
        ;; Make mouse wheel / trackpad scrolling less jerky
        (setq mouse-wheel-scroll-amount '(1
                                          ((shift) . 5)
                                          ((control))))
        (dolist (multiple '("" "double-" "triple-"))
          (dolist (direction '("right" "left"))
            (global-set-key (kbd (concat "<" multiple "wheel-" direction ">")) 'ignore)))
        (global-set-key (kbd "M-`") 'ns-next-frame)
        (global-set-key (kbd "M-h") 'ns-do-hide-emacs)
        (global-set-key (kbd "M-˙") 'ns-do-hide-others)
        (after-load 'nxml-mode
          (define-key nxml-mode-map (kbd "M-h") nil))
        (global-set-key (kbd "M-ˍ") 'ns-do-hide-others))

      (provide 'init-osx-keys)

    #+END_SRC
** Browse URL
   #+BEGIN_SRC emacs-lisp
   (require 'init-browse-url)
   #+END_SRC

*** init-browse-url.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-browse-url.el
      (if *is-a-mac*
          (setq browse-url-browser-function 'browse-url-default-macosx-browser)
        (setq browse-url-browser-function 'browse-url-default-browser))

      (global-set-key "\C-c\C-z." 'browse-url-at-point)
      (global-set-key "\C-c\C-zb" 'browse-url-of-buffer)
      (global-set-key "\C-c\C-zr" 'browse-url-of-region)
      (global-set-key "\C-c\C-zu" 'browse-url)
      (global-set-key "\C-c\C-zv" 'browse-url-of-file)

      (provide 'init-browse-url)

    #+END_SRC

** Dired
   #+BEGIN_SRC emacs-lisp
   (require 'init-dired)
   #+END_SRC

*** init-dired.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-dired.el
      (require 'ls-lisp)
      (setq dired-listing-switches "-l"
            ls-lisp-dirs-first t
            ls-lisp-ignore-case t
            ls-lisp-use-insert-directory-program nil
            ls-lisp-use-localized-time-format t)

      (provide 'init-dired)

    #+END_SRC

** Timestamp
   #+BEGIN_SRC emacs-lisp
   (require 'init-timestamp)
   #+END_SRC

*** init-timestamp.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-timestamp.el
      (add-hook 'write-file-hooks 'time-stamp)

      (setq time-stamp-active t)
      (setq time-stamp-format "%:a, %02d %:b %:y %02I:%02M %#P %Z")
      (setq time-stamp-start "\\(Time-stamp:[         ]+\\\\?[\"<]+\\|Last Modified:[
              ]\\)")
      (setq time-stamp-end "\\\\?[\">]\\|$")
      (setq time-stamp-line-limit 10)

      (provide 'init-timestamp)

    #+END_SRC
** Tempo
   #+BEGIN_SRC emacs-lisp
   (require 'init-tempo)
   #+END_SRC

*** init-timestamp.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-tempo.el
      (require 'tempo)

      (tempo-define-template "generic-header"
                             '((format "%s%s" comment-start comment-start)
                               "      Filename: "
                               (file-name-nondirectory (buffer-file-name)) 'n
                               (format "%s%s" comment-start comment-start)
                               " Creation Date: "
                               (format-time-string "%A, %d %B %Y %I:%M %p %Z") 'n
                               (format "%s%s" comment-start comment-start)
                               " Last Modified: "
                               (format-time-string "%A, %d %B %Y %I:%M %p %Z") 'n
                               (format "%s%s" comment-start comment-start)
                               "        Author: Tim Cross <theophilusx AT gmail.com>"
                               'n
                               (format "%s%s" comment-start comment-start)
                               "   Description:" 'n
                               (format "%s%s" comment-start comment-start) 'n
                               'n))

      (global-set-key [(f5)] 'tempo-template-generic-header)

      (provide 'init-tempo)

    #+END_SRC
** Isearch
   #+BEGIN_SRC emacs-lisp
   (require 'init-isearch)
   #+END_SRC
*** init-isearch.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-isearch.el
      ;; Show number of matches while searching
      (when (maybe-require-package 'anzu)
        (global-anzu-mode t)
        (diminish 'anzu-mode)
        (global-set-key [remap query-replace-regexp] 'anzu-query-replace-regexp)
        (global-set-key [remap query-replace] 'anzu-query-replace))

      ;; Activate occur easily inside isearch
      (define-key isearch-mode-map (kbd "C-o") 'isearch-occur)

      ;; DEL during isearch should edit the search string,
      ;; not jump back to the previous result
      (define-key isearch-mode-map [remap isearch-delete-char] 'isearch-del-char)

      ;; Search back/forth for the symbol at point
      ;; See http://www.emacswiki.org/emacs/SearchAtPoint
      (defun isearch-yank-symbol ()
        "*Put symbol at current point into search string."
        (interactive)
        (let ((sym (symbol-at-point)))
          (if sym
              (progn
                (setq isearch-regexp t
                      isearch-string (concat "\\_<" (regexp-quote
                                                     (symbol-name sym)) "\\_>")
                      isearch-message (mapconcat 'isearch-text-char-description
                                                 isearch-string "")
                      isearch-yank-flag t))
            (ding)))
        (isearch-search-and-update))

      (define-key isearch-mode-map "\C-\M-w" 'isearch-yank-symbol)


      ;; http://www.emacswiki.org/emacs/ZapToISearch
      (defun zap-to-isearch (rbeg rend)
        "Kill the region between the mark and the closest portion of
      the isearch match string. The behaviour is meant to be analogous
      to zap-to-char; let's call it zap-to-isearch. The deleted region
      does not include the isearch word. This is meant to be bound only
      in isearch mode.  The point of this function is that oftentimes
      you want to delete some portion of text, one end of which happens
      to be an active isearch word. The observation to make is that if
      you use isearch a lot to move the cursor around (as you should,
      it is much more efficient than using the arrows), it happens a
      lot that you could just delete the active region between the mark
      and the point, not include the isearch word."
        (interactive "r")
        (when (not mark-active)
          (error "Mark is not active"))
        (let* ((isearch-bounds (list isearch-other-end (point)))
               (ismin (apply 'min isearch-bounds))
               (ismax (apply 'max isearch-bounds))
               )
          (if (< (mark) ismin)
              (kill-region (mark) ismin)
            (if (> (mark) ismax)
                (kill-region ismax (mark))
              (error "Internal error in isearch kill function.")))
          (isearch-exit)))

      (define-key isearch-mode-map [(meta z)] 'zap-to-isearch)

      ;; http://www.emacswiki.org/emacs/ZapToISearch
      (defun isearch-exit-other-end (rbeg rend)
        "Exit isearch, but at the other end of the search string.
      This is useful when followed by an immediate kill."
        (interactive "r")
        (isearch-exit)
        (goto-char isearch-other-end))

      (define-key isearch-mode-map [(control return)] 'isearch-exit-other-end)

      (provide 'init-isearch)

    #+END_SRC

** Grep
   #+BEGIN_SRC emacs-lisp
   (require 'init-grep)
   #+END_SRC
*** init-grep.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-grep.el
      (setq-default grep-highlight-matches t
                    grep-scroll-output t)

      (when *is-a-mac*
        (setq-default locate-command "mdfind"))

      (provide 'init-grep)

    #+END_SRC
** Uniquify
   #+BEGIN_SRC emacs-lisp
   (require 'init-uniquify)
   #+END_SRC

*** init-uniquify.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-uniquify.el
      (require 'uniquify)

      (setq uniquify-buffer-name-style 'reverse)
      (setq uniquify-separator " • ")
      (setq uniquify-after-kill-buffer-p t)
      (setq uniquify-ignore-buffers-re "^\\*")


      (provide 'init-uniquify)

    #+END_SRC

** Ibuffer
   #+BEGIN_SRC emacs-lisp
   (require 'init-ibuffer)
   #+END_SRC
*** init-ibuffer.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-ibuffer.el
      (require-package 'ibuffer-vc)

      (defun ibuffer-set-up-preferred-filters ()
        (ibuffer-vc-set-filter-groups-by-vc-root)
        (unless (eq ibuffer-sorting-mode 'filename/process)
          (ibuffer-do-sort-by-filename/process)))

      (add-hook 'ibuffer-hook 'ibuffer-set-up-preferred-filters)

      (after-load 'ibuffer
        ;; Use human readable Size column instead of original one
        (define-ibuffer-column size-h
          (:name "Size" :inline t)
          (cond
           ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
           ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
           (t (format "%8d" (buffer-size))))))

      ;; Explicitly require ibuffer-vc to get its column definitions, which
      ;; can't be autoloaded
      (after-load 'ibuffer
        (require 'ibuffer-vc))

      ;; Modify the default ibuffer-formats (toggle with `)
      (setq ibuffer-formats
            '((mark modified read-only vc-status-mini " "
                    (name 18 18 :left :elide)
                    " "
                    (size-h 9 -1 :right)
                    " "
                    (mode 16 16 :left :elide)
                    " "
                    filename-and-process)
              (mark modified read-only vc-status-mini " "
                    (name 18 18 :left :elide)
                    " "
                    (size-h 9 -1 :right)
                    " "
                    (mode 16 16 :left :elide)
                    " "
                    (vc-status 16 16 :left)
                    " "
                    filename-and-process)))

      (setq ibuffer-filter-group-name-face 'font-lock-doc-face)

      (global-set-key (kbd "C-x C-b") 'ibuffer)

      (provide 'init-ibuffer)

    #+END_SRC
** Recentf
   #+BEGIN_SRC emacs-lisp
   (require 'init-recentf)
   #+END_SRC

*** init-recentf.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-recentf.el
      (recentf-mode 1)
      (setq recentf-max-saved-items 1000
            recentf-exclude '("/tmp/" "/ssh:"))

      (provide 'init-recentf)

    #+END_SRC

** Ido
   #+BEGIN_SRC emacs-lisp
   (require 'init-ido)
   #+END_SRC

*** init-ido.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-ido.el
      ;; Use C-f during file selection to switch to regular find-file
      (require 'ido)
      (ido-mode t)
      (ido-everywhere t)
      (setq ido-enable-flex-matching t)
      (setq ido-use-filename-at-point nil)
      (setq ido-auto-merge-work-directories-length 0)
      (setq ido-use-virtual-buffers t)

      (when (maybe-require-package 'ido-ubiquitous)
        (ido-ubiquitous-mode t))

      ;; Use smex to handle M-x
      (when (maybe-require-package 'smex)
        ;; Change path for ~/.smex-items
        (setq smex-save-file (expand-file-name ".smex-items" user-emacs-directory))
        (global-set-key [remap execute-extended-command] 'smex))

      (require-package 'idomenu)

      ;; Allow the same buffer to be open in different frames
      (setq ido-default-buffer-method 'selected-window)

      ;; http://www.reddit.com/r/emacs/comments/21a4p9/use_recentf_and_ido_together/cgbprem
      (add-hook 'ido-setup-hook (lambda ()
                                  (define-key ido-completion-map
                                    [up] 'previous-history-element)))

      (provide 'init-ido)

    #+END_SRC

** Hippie Expand
   #+BEGIN_SRC emacs-lisp
   (require 'init-hippie-expand)
   #+END_SRC

*** init-hippie-expand.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-hippie-expand.el
      (global-set-key (kbd "M-/") 'hippie-expand)

      (setq hippie-expand-try-functions-list
            '(try-complete-file-name-partially
              try-complete-file-name
              try-expand-dabbrev
              try-expand-dabbrev-all-buffers
              try-expand-dabbrev-from-kill))

      (provide 'init-hippie-expand)

    #+END_SRC

** Auto Complete
   #+BEGIN_SRC emacs-lisp
   (require 'init-auto-complete)
   #+END_SRC

*** init-auto-complete.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-auto-complete.el
      (require-package 'auto-complete)
      (require 'auto-complete-config)

      (global-auto-complete-mode t)
      (setq-default ac-expand-on-auto-complete nil)
      (setq-default ac-auto-start nil)
      ;; To get pop-ups with docs even if a word is uniquely completed
      (setq-default ac-dwim nil)

      ;;----------------------------------------------------------------------------
      ;; Use Emacs' built-in TAB completion hooks to trigger AC (Emacs >= 23.2)
      ;;----------------------------------------------------------------------------
      (setq tab-always-indent 'complete)  ;; use 't when auto-complete is disabled
      (add-to-list 'completion-styles 'initials t)
      ;; Stop completion-at-point from popping up completion buffers so eagerly
      (setq completion-cycle-threshold 5)

      (setq c-tab-always-indent nil
            c-insert-tab-function 'indent-for-tab-command)

      ;; hook AC into completion-at-point
      (defun sanityinc/auto-complete-at-point ()
        (when (and (not (minibufferp))
                   (fboundp 'auto-complete-mode)
                   auto-complete-mode)
          #'auto-complete))

      (defun sanityinc/never-indent ()
        (set (make-local-variable 'indent-line-function) (lambda () 'noindent)))

      (defun set-auto-complete-as-completion-at-point-function ()
        (setq completion-at-point-functions
              (cons 'sanityinc/auto-complete-at-point
                    (remove 'sanityinc/auto-complete-at-point
                            completion-at-point-functions))))

      (add-hook 'auto-complete-mode-hook 'set-auto-complete-as-completion-at-point-function)

      (set-default 'ac-sources
                   '(ac-source-imenu
                     ac-source-dictionary
                     ac-source-words-in-buffer
                     ac-source-words-in-same-mode-buffers
                     ac-source-words-in-all-buffer))

      (dolist (mode '(magit-log-edit-mode
                      log-edit-mode org-mode text-mode haml-mode
                      sass-mode yaml-mode csv-mode espresso-mode haskell-mode
                      html-mode nxml-mode sh-mode smarty-mode clojure-mode
                      lisp-mode textile-mode markdown-mode tuareg-mode
                      js3-mode css-mode less-css-mode sql-mode
                      sql-interactive-mode
                      inferior-emacs-lisp-mode))
        (add-to-list 'ac-modes mode))

      ;; Exclude very large buffers from dabbrev
      (defun sanityinc/dabbrev-friend-buffer (other-buffer)
        (< (buffer-size other-buffer) (* 1 1024 1024)))

      (setq dabbrev-friend-buffer-function 'sanityinc/dabbrev-friend-buffer)

      (provide 'init-auto-complete)

    #+END_SRC

** MMM
   #+BEGIN_SRC emacs-lisp
   (require 'init-mmm)
   #+END_SRC

*** init-mmm.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-mmm.el
      ;;----------------------------------------------------------------------------
      ;; Multiple major modes
      ;;----------------------------------------------------------------------------
      (require-package 'mmm-mode)
      (require 'mmm-auto)
      (setq mmm-global-mode 'buffers-with-submode-classes)
      (setq mmm-submode-decoration-level 2)

      (provide 'init-mmm)

    #+END_SRC

** Git
   #+BEGIN_SRC emacs-lisp
   (require 'init-git)
   (require 'init-github)
   #+END_SRC

*** init-git.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-git.el
      ;; (require-package 'magit)
      ;; (require-package 'git-blame)
      ;; (require-package 'gitignore-mode)
      ;; (require-package 'gitconfig-mode)
      ;; (require-package 'git-messenger) ;; Though see also vc-annotate's "n" & "p" bindings
      ;; (require-package 'git-timemachine)

      ;; (setq-default magit-save-some-buffers nil
      ;;               magit-process-popup-time 10
      ;;               magit-diff-refine-hunk t
      ;;               magit-completing-read-function 'magit-ido-completing-read)

      ;; ;; Hint: customize `magit-repo-dirs' so that you can use C-u M-F12 to
      ;; ;; quickly open magit on any one of your projects.
      ;; (global-set-key [(meta f12)] 'magit-status)

      ;; (after-load 'magit
      ;;   (define-key magit-status-mode-map (kbd "C-M-<up>") 'magit-goto-parent-section))

      ;; ;;; When we start working on git-backed files, use git-wip if available

      ;; (after-load 'magit
      ;;   (when (executable-find magit-git-executable)
      ;;     (global-magit-wip-save-mode)
      ;;     (diminish 'magit-wip-save-mode)))

      ;; (after-load 'magit
      ;;   (diminish 'magit-auto-revert-mode))

      ;; (when *is-a-mac*
      ;;   (after-load 'magit
      ;;     (add-hook 'magit-mode-hook (lambda () (local-unset-key [(meta h)])))))

      ;; ;; Convenient binding for vc-git-grep
      ;; (global-set-key (kbd "C-x v f") 'vc-git-grep)

      ;; ;;; git-svn support

      ;; (require-package 'magit-svn)
      ;; (autoload 'magit-svn-enabled "magit-svn")

      ;; (defun sanityinc/maybe-enable-magit-svn-mode ()
      ;;   (when (magit-svn-enabled)
      ;;     (magit-svn-mode)))

      ;; (add-hook 'magit-status-mode-hook #'sanityinc/maybe-enable-magit-svn-mode)

      ;; (after-load 'compile
      ;;   (dolist (defn (list '(git-svn-updated "^\t[A-Z]\t\\(.*\\)$" 1 nil nil 0 1)
      ;;                       '(git-svn-needs-update "^\\(.*\\): needs update$" 1 nil nil 2 1)))
      ;;     (add-to-list 'compilation-error-regexp-alist-alist defn)
      ;;     (add-to-list 'compilation-error-regexp-alist (car defn))))

      ;; (defvar git-svn--available-commands nil "Cached list of git svn subcommands")

      ;; (defun git-svn--available-commands ()
      ;;   (or git-svn--available-commands
      ;;       (setq git-svn--available-commands
      ;;             (sanityinc/string-all-matches
      ;;              "^  \\([a-z\\-]+\\) +"
      ;;              (shell-command-to-string "git svn help") 1))))

      ;; (defun git-svn (dir command)
      ;;   "Run a git svn subcommand in DIR."
      ;;   (interactive (list (read-directory-name "Directory: ")
      ;;                      (completing-read "git-svn command: "
      ;;                                       (git-svn--available-commands) nil t nil nil
      ;;                                       (git-svn--available-commands))))
      ;;   (let* ((default-directory (vc-git-root dir))
      ;;          (compilation-buffer-name-function (lambda (major-mode-name) "*git-svn*")))
      ;;     (compile (concat "git svn " command))))

      ;; (require-package 'git-messenger)
      ;; (global-set-key (kbd "C-x v p") #'git-messenger:popup-message)

      (require-package 'git-blame)
      (require-package 'gitignore-mode)
      (require-package 'gitconfig-mode)
      (require-package 'git-messenger) ; Though see also vc-annotate's "n" & "p"
                                              ; bindings
      (require-package 'git-timemachine)


      (when (maybe-require-package 'magit)
        (setq-default
         magit-process-popup-time 10
         magit-diff-refine-hunk t
         magit-completing-read-function 'magit-ido-completing-read)

        ;; Hint: customize `magit-repo-dirs' so that you can use C-u M-F12 to
        ;; quickly open magit on any one of your projects.
        (global-set-key [(meta f12)] 'magit-status)
        (global-set-key (kbd "C-x g") 'magit-status)
        (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup))

      (after-load 'magit
        (define-key magit-status-mode-map (kbd "C-M-<up>") 'magit-section-up)
        (add-hook 'magit-popup-mode-hook 'sanityinc/no-trailing-whitespace))

      (require-package 'fullframe)
      (after-load 'magit
        (fullframe magit-status magit-mode-quit-window))

      (when (maybe-require-package 'git-commit)
        (add-hook 'git-commit-mode-hook 'goto-address-mode))

      (when *is-a-mac*
        (after-load 'magit
          (add-hook 'magit-mode-hook (lambda () (local-unset-key [(meta h)])))))

      ;; Convenient binding for vc-git-grep
      (global-set-key (kbd "C-x v f") 'vc-git-grep)

      (after-load 'compile
        (dolist (defn (list '(git-svn-updated "^\t[A-Z]\t\\(.*\\)$" 1 nil nil 0 1)
                            '(git-svn-needs-update "^\\(.*\\): needs update$" 1
                                                   nil nil 2 1)))
          (add-to-list 'compilation-error-regexp-alist-alist defn)
          (add-to-list 'compilation-error-regexp-alist (car defn))))

      (defvar git-svn--available-commands nil "Cached list of git svn subcommands")
      (defun git-svn--available-commands ()
        (or git-svn--available-commands
            (setq git-svn--available-commands
                  (sanityinc/string-all-matches
                   "^  \\([a-z\\-]+\\) +"
                   (shell-command-to-string "git svn help") 1))))

      (defun git-svn (dir command)
        "Run a git svn subcommand in DIR."
        (interactive (list (read-directory-name "Directory: ")
                           (completing-read "git-svn command: "
                                            (git-svn--available-commands)
                                            nil t nil nil
                                            (git-svn--available-commands))))
        (let* ((default-directory (vc-git-root dir))
               (compilation-buffer-name-function (lambda (major-mode-name)
                                                   "*git-svn*")))
          (compile (concat "git svn " command))))


      (require-package 'git-messenger)
      (global-set-key (kbd "C-x v p") #'git-messenger:popup-message)


      (provide 'init-git)

    #+END_SRC
**** TODO link commits from vc-log to magit-show-commit
**** TODO smerge-mode

*** init-github.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-github.el
      (require 'init-git)

      (require-package 'yagist)
      (require-package 'github-browse-file)
      (require-package 'bug-reference-github)
      (add-hook 'prog-mode-hook 'bug-reference-prog-mode)

      (maybe-require-package 'github-clone)
      (maybe-require-package 'magit-gh-pulls)

      (provide 'init-github)

    #+END_SRC

** Compile
   #+BEGIN_SRC emacs-lisp
   (require 'init-compile)
   #+END_SRC

*** init-compile.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-compile.el
      (setq-default compilation-scroll-output t)

      (require-package 'alert)

      ;; Customize `alert-default-style' to get messages after compilation

      (defun sanityinc/alert-after-compilation-finish (buf result)
        "Use `alert' to report compilation RESULT if BUF is hidden."
        (let ((buf-is-visible nil))
          (walk-windows (lambda (w)
                          (when (eq (window-buffer w) buf)
                            (setq buf-is-visible t))))
          (unless buf-is-visible
            (alert (concat "Compilation " result)
                   :buffer buf
                   :category 'compilation))))

      (after-load 'compile
        (add-hook 'compilation-finish-functions
                  'sanityinc/alert-after-compilation-finish))

      (provide 'init-compile)

    #+END_SRC

** Calendar
   #+BEGIN_SRC emacs-lisp
   (require 'init-calendar)
   #+END_SRC

*** init-calendar.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-calendar.el
      (require 'calendar)
      (setq calendar-date-style 'iso
            calendar-location-name "Armidale"
            calendar-longitude 151.617222
            calendar-mark-diary-entries-flag t
            calendar-mark-holidays-flag t
            calendar-time-zone 600
            calendar-view-holidays-initially-flag t)

      (setq icalendar-import-format "%s%l"
            icalendar-import-format-location " (%s)"
            icalendar-recurring-start-year 2013)

      (provide 'init-calendar)

    #+END_SRC
** Convert to Text
   This is a utility to convert some document formats to plain text. I wrote this
   before doc-view was added to emacs. To some extent, the doc-view utility provides
   superior looking versions of some documents within Emacs. However, sometimes, it
   is good to just have a document's contents in plain text.

   Note that the functionality in this utility requires a number of external programs
   which actually do the conversion.
   #+BEGIN_SRC emacs-lisp
   (require 'init-text-convert)
   #+END_SRC

*** init-text-convert.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-text-convert.el
      (require 'custom)
      (require 'browse-url)

      ;; make-temp-file is part of apel prior to emacs 22
      ;;(static-when (= emacs-major-version 21)
      ;;  (require 'poe))

      (defgroup txutils nil
        "Customize group for txutils."
        :prefix "txutils-"
        :group 'External)

      (defcustom txutils-convert-alist
        '( ;; MS Word
          ("\\.\\(?:DOC\\|doc\\)$"     doc  "/usr/bin/wvText"    nil nil nil nil nil)
          ;; PDF
          ("\\.\\(?:PDF\\|pdf\\)$"     pdf  "/usr/bin/pdftotext" nil nil nil nil nil)
          ;; PostScript
          ("\\.\\(?:PS\\|ps\\)$"       ps   "/usr/bin/pstotext"  "-output" t nil nil nil)
          ;; MS PowerPoint
          ("\\.\\(?:PPT\\|ppt\\)$"     ppt  "/usr/bin/ppthtml"   nil nil nil t t))

        "*Association for program convertion.

      Each element has the following form:

      (REGEXP SYMBOL CONVERTER SWITCHES INVERT REDIRECT-INPUT REDIRECT-OUTPUT HTML-OUTPUT)

      Where:

      REGEXP             is a regexp to match file type to convert.

      SYMBOL             is a symbol to designate the fyle type.

      CONVERTER          is a program to convert the fyle type to text or HTML.

      SWITCHES           is a string which gives command line switches for the conversion
      program. Nil means there are no switches needed.

      INVERT             indicates if input and output program option is to be
      inverted or not.  Non-nil means to invert, that is, output
      option first then input option.  Nil means do not invert,
      that is, input option first then output option.

      REDIRECT-INPUT indicates to use < to direct input from the input
      file. This is useful for utilities which accept input
      from stdin rather than a file.

      REDIRECT-OUTPUT indicates to use > to direct output to the output
      file. This is useful for utilities that only send output to
      stdout.

      HTML-OUTPUT    Indicates the conversion program creates HTML output
      rather than plain text."

        :type '(repeat
                (list :tag "Convertion"
                      (regexp  :tag "File Type Regexp")
                      (symbol  :tag "File Type Symbol")
                      (string  :tag "Converter")
                      (choice  :menu-tag "Output Option"
                               :tag "Output Option"
                               (const :tag "None" nil)
                               string)
                      (boolean :tag "Invert I/O Option")
                      (boolean :tag "Redirect Standard Input")
                      (boolean :tag "Redirect Standard Output")
                      (boolean :tag "HTML Output")))
        :group 'txutils)

      (defun txutils-run-command (cmd &optional output-buffer)
        "Execute shell command with arguments, putting output in buffer."
        (= 0 (shell-command cmd (if output-buffer
                                    output-buffer
                                  "*txutils-output*")
                            (if output-buffer
                                "*txutils-output*"))))

      (defun txutils-quote-expand-file-name (file-name)
        "Expand file name and quote special chars if required."
        (shell-quote-argument (expand-file-name file-name)))

      (defun txutils-file-alist (file-name)
        "Return alist associated with file of this type."
        (let ((al txutils-convert-alist))
          (while (and al
                      (not (string-match (caar al) file-name)))
            (setq al (cdr al)))
          (if al
              (cdar al)
            nil)))

      (defun txutils-make-temp-name (orig-name type-alist)
        "Create a temp file name from original file name"
        (make-temp-file (file-name-sans-extension
                         (file-name-nondirectory orig-name)) nil
                         (if (nth 7 type-alist)
                             ".html"
                           ".txt")))

      (defun txutils-build-cmd (input-file output-file type-alist)
        "Create the command string from conversion alist."
        (let ((f1 (if (nth 3 type-alist)
                      output-file
                    input-file))
              (f2 (if (nth 3 type-alist)
                      input-file
                    output-file)))
          (concat
           (nth 1 type-alist)
           (if (nth 2 type-alist)               ; Add cmd line switches
               (concat " " (nth 2 type-alist)))
           (if (nth 4 type-alist)          ; redirect input (which may be output
               (concat " < " f1)           ; if arguments are inverted!)
             (concat " " f1))
           (if (nth 5 type-alist)          ; redirect output (see above comment)
               (concat " > " f2)
             (concat " " f2)))))

      (defun txutils-do-file-conversion (file-name)
        "Based on file extension, convert file to text. Return name of text file"
        (interactive "fFile to convert: ")
        (let ((f-alist (txutils-file-alist file-name))
              output-file)
          (when f-alist
            (message "Performing file conversion for %s." file-name)
            (setq output-file (txutils-make-temp-name file-name f-alist))
            (message "Command: %s" (txutils-build-cmd file-name output-file f-alist))
            (if (txutils-run-command
                 (txutils-build-cmd (txutils-quote-expand-file-name file-name)
                                    (txutils-quote-expand-file-name
                                     output-file) f-alist))
                output-file
              file-name))))

      (defadvice view-file (around txutils pre act comp)
        "Perform file conversion or call web browser to view contents of file."
        (let ((file-arg (ad-get-arg 0)))
          (if (txutils-file-alist file-arg)
              (ad-set-arg 0 (txutils-do-file-conversion file-arg)))
          (if (string-match "\\.\\(?:HTML?\\|html?\\)$" (ad-get-arg 0))
              (browse-url-of-file (ad-get-arg 0))
            ad-do-it)))

      (provide 'init-text-convert)

    #+END_SRC
** Crontab
   #+BEGIN_SRC emacs-lisp
   (require 'init-crontab)
   #+END_SRC

*** init-crontab.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-crontab.el
      (require-package 'crontab-mode)
      (add-auto-mode 'crontab-mode "\\.?cron\\(tab\\)?\\'")

      (provide 'init-crontab)

    #+END_SRC
** Textile
   #+BEGIN_SRC emacs-lisp
   (require 'init-textile)
   #+END_SRC

*** init-textile.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-textile.el
      (require-package 'textile-mode)

      (autoload 'textile-mode "textile-mode" "Mode for editing Textile documents" t)
      (setq auto-mode-alist
            (cons '("\\.textile\\'" . textile-mode) auto-mode-alist))

      (provide 'init-textile)

    #+END_SRC

** Markdown
   #+BEGIN_SRC emacs-lisp
   (require 'init-markdown)
   #+END_SRC

*** init-markdown.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-markdown.el
      (require-package 'markdown-mode)

      (setq auto-mode-alist
            (cons '("\\.\\(md\\|markdown\\)\\'" . markdown-mode) auto-mode-alist))

      (provide 'init-markdown)

    #+END_SRC

** CSV
   #+BEGIN_SRC emacs-lisp
   (require 'init-csv)
   #+END_SRC

*** init-csv.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-csv.el
      (require-package 'csv-mode)
      (require-package 'csv-nav)

      (add-auto-mode 'csv-mode "\\.[Cc][Ss][Vv]\\'")

      (setq csv-separators '("," ";" "|" " "))

      (provide 'init-csv)

    #+END_SRC

** Javascript
   #+BEGIN_SRC emacs-lisp
   (require 'init-javascript)
   #+END_SRC

*** init-javascript.el
   #+BEGIN_SRC emacs-lisp :tangle lisp/init-javascript.el
     (require-package 'json-mode)
     (maybe-require-package 'js2-mode)
     (maybe-require-package 'ac-js2)
     (maybe-require-package 'coffee-mode)
     (require-package 'js-comint)

     (defcustom preferred-javascript-mode
       (first (remove-if-not #'fboundp '(js2-mode js-mode)))
       "Javascript mode to use for .js files."
       :type 'symbol
       :group 'programming
       :options '(js2-mode js-mode))

     (defvar preferred-javascript-indent-level 2)

     ;; Need to first remove from list if present, since elpa adds entries too, which
     ;; may be in an arbitrary order
     (eval-when-compile (require 'cl))

     (setq auto-mode-alist (cons `("\\.js\\(\\.erb\\)?\\'" . ,preferred-javascript-mode)
                                 (loop for entry in auto-mode-alist
                                       unless (eq preferred-javascript-mode (cdr entry))
                                       collect entry)))


     ;; js2-mode
     (after-load 'js2-mode
       (add-hook 'js2-mode-hook (lambda () (setq mode-name "JS2")))
       (setq-default js2-basic-offset preferred-javascript-indent-level
                     js2-bounce-indent-p nil)
       (after-load 'js2-mode
         (js2-imenu-extras-setup)))

     ;; js-mode
     (setq-default js-indent-level preferred-javascript-indent-level)

     (add-to-list 'interpreter-mode-alist (cons "node" preferred-javascript-mode))

     ;; Javascript nests {} and () a lot, so I find this helpful
     (require-package 'rainbow-delimiters)
     (dolist (hook '(js2-mode-hook js-mode-hook json-mode-hook))
       (add-hook hook 'rainbow-delimiters-mode))


     ;;; Coffeescript
     (after-load 'coffee-mode
       (setq coffee-js-mode preferred-javascript-mode
             coffee-tab-width preferred-javascript-indent-level))

     (when (fboundp 'coffee-mode)
       (add-to-list 'auto-mode-alist '("\\.coffee\\.erb\\'" . coffee-mode)))

     ;; ---------------------------------------------------------------------------
     ;; Run and interact with an inferior JS via js-comint.el
     ;; ---------------------------------------------------------------------------
     (setq inferior-js-program-command "js")

     (defvar inferior-js-minor-mode-map (make-sparse-keymap))
     (define-key inferior-js-minor-mode-map "\C-x\C-e" 'js-send-last-sexp)
     (define-key inferior-js-minor-mode-map "\C-\M-x" 'js-send-last-sexp-and-go)
     (define-key inferior-js-minor-mode-map "\C-cb" 'js-send-buffer)
     (define-key inferior-js-minor-mode-map "\C-c\C-b" 'js-send-buffer-and-go)
     (define-key inferior-js-minor-mode-map "\C-cl" 'js-load-file-and-go)

     (define-minor-mode inferior-js-keys-mode
       "Bindings for communicating with an inferior js interpreter."
       nil " InfJS" inferior-js-minor-mode-map)

     (dolist (hook '(js2-mode-hook js-mode-hook))
       (add-hook hook 'inferior-js-keys-mode))

     ;; ---------------------------------------------------------------------------
     ;; Alternatively, use skewer-mode
     ;; ---------------------------------------------------------------------------
     (when (maybe-require-package 'skewer-mode)
       (after-load 'skewer-mode
         (add-hook 'skewer-mode-hook
                   (lambda () (inferior-js-keys-mode -1)))))

     (provide 'init-javascript)

   #+END_SRC

** NXML
   - Reference [[http://sinewalker.wordpress.com/2008/06/26/pretty-printing-xml-with-emacs-nxml-mode/][NXML mode pretty printing]]
   #+BEGIN_SRC emacs-lisp
   (require 'init-nxml)
   #+END_SRC

*** init-nxml.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-nxml.el
      (add-auto-mode 'nxml-mode
                     (concat "\\." (regexp-opt '("xml" "xsd" "sch" "rng" "xslt" "svg" "rss"
                                                 "gpx" "tcx" "plist"))
                             "\\'"))
      (setq magic-mode-alist (cons '("<\\?xml " . nxml-mode) magic-mode-alist))
      (fset 'xml-mode 'nxml-mode)
      (add-hook 'nxml-mode-hook (lambda ()
                                  (set (make-local-variable 'ido-use-filename-at-point) nil)))
      (setq nxml-slash-auto-complete-flag t)

      (defun sanityinc/pp-xml-region (begin end)
        "Pretty format XML markup in region. The function inserts
      linebreaks to separate tags that have nothing but whitespace
      between them.  It then indents the markup by using nxml's
      indentation rules."
        (interactive "r")
        (save-excursion
          (nxml-mode)
          (goto-char begin)
          (while (search-forward-regexp "\>[ \\t]*\<" nil t)
            (backward-char) (insert "\n"))
          (indent-region begin end)))

      ;;----------------------------------------------------------------------------
      ;; Integration with tidy for html + xml
      ;;----------------------------------------------------------------------------
      (require-package 'tidy)
      (add-hook 'nxml-mode-hook (lambda () (tidy-build-menu nxml-mode-map)))

      (provide 'init-nxml)

    #+END_SRC

** HTML
   #+BEGIN_SRC emacs-lisp
   (require 'init-html)
   #+END_SRC

*** init-html.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-html.el
      (require-package 'tidy)
      (add-hook 'html-mode-hook (lambda ()
                                  (tidy-build-menu html-mode-map)))

      (require-package 'tagedit)
      (after-load 'sgml-mode
        (tagedit-add-paredit-like-keybindings)
        (add-hook 'sgml-mode-hook (lambda ()
                                    (tagedit-mode 1))))

      (add-auto-mode 'html-mode "\\.(jsp|tmpl)\\'")

      (provide 'init-html)

    #+END_SRC

** CSS
   #+BEGIN_SRC emacs-lisp
   (require 'init-css)
   #+END_SRC

*** init-css.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-css.el
      ;;; Colourise CSS colour literals
      (when (maybe-require-package 'rainbow-mode)
        (dolist (hook '(css-mode-hook html-mode-hook sass-mode-hook))
          (add-hook hook 'rainbow-mode)))

      ;;; Embedding in html
      (require-package 'mmm-mode)
      (after-load 'mmm-vars
        (mmm-add-group
         'html-css
         '((css-cdata
            :submode css-mode
            :face mmm-code-submode-face
            :front "<style[^>]*>[ \t\n]*\\(//\\)?<!\\[CDATA\\[[ \t]*\n?"
            :back "[ \t]*\\(//\\)?]]>[ \t\n]*</style>"
            :insert ((?j js-tag nil @ "<style type=\"text/css\">"
                         @ "\n" _ "\n" @ "</style>" @)))
           (css
            :submode css-mode
            :face mmm-code-submode-face
            :front "<style[^>]*>[ \t]*\n?"
            :back "[ \t]*</style>"
            :insert ((?j js-tag nil @ "<style type=\"text/css\">"
                         @ "\n" _ "\n" @ "</style>" @)))
           (css-inline
            :submode css-mode
            :face mmm-code-submode-face
            :front "style=\""
            :back "\"")))
        (dolist (mode (list 'html-mode 'nxml-mode))
          (mmm-add-mode-ext-class mode "\\.r?html\\(\\.erb\\)?\\'" 'html-css)))

      ;;; SASS and SCSS
      (require-package 'sass-mode)
      (require-package 'scss-mode)
      (setq-default scss-compile-at-save nil)

      ;;; LESS
      (require-package 'less-css-mode)
      (when (featurep 'js2-mode)
        (require-package 'skewer-less))

      ;;; Auto-complete CSS keywords
      (after-load 'auto-complete
        (dolist (hook '(css-mode-hook sass-mode-hook scss-mode-hook))
          (add-hook hook 'ac-css-mode-setup)))

      ;;; Use eldoc for syntax hints
      (require-package 'css-eldoc)
      (autoload 'turn-on-css-eldoc "css-eldoc")
      (add-hook 'css-mode-hook 'turn-on-css-eldoc)

      (provide 'init-css)

    #+END_SRC

** HAML
   #+BEGIN_SRC emacs-lisp
   (require 'init-haml)
   #+END_SRC

*** init-haml.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-haml.el
      (require-package 'haml-mode)

      (after-load 'haml-mode
        (define-key haml-mode-map (kbd "C-o") 'open-line))

      (provide 'init-haml)

    #+END_SRC

** Org Mode
   #+BEGIN_SRC emacs-lisp
   (require 'init-org)
   #+END_SRC

*** init-org.el
**** Add package and archives
    Start by getting required package. I'm using the org-plus-contrib package from
    the org repository 
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (require-package 'org-plus-contrib)
      (require-package 'org-fstree)
    #+END_SRC

**** Some OS X packages 
     If running under OS X, there are a couple of additional packages we need
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (when *is-a-mac*
        (require 'org-mac-link)
        (autoload 'org-mac-grab-link "org-mac-link" nil t)
        (require 'org-mac-iCal))
    #+END_SRC

**** Basic setup
    I like to keep all my org files in Dropbox so that they are available on all my
    systems. Lets start by setting some basic stuff
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (setq org-catch-invisible-edits 'smart
            org-completion-use-ido t
            org-ctrl-k-protect-subtree t
            org-default-notes-file "~/Dropbox/org/notes.org"
            org-directory "~/Dropbox/org"
            org-hide-block-startup t
            org-html-validation-link nil
            org-list-allow-alphabetical t
            org-list-description-max-indent 5
            org-list-indent-offset 2
            org-log-done 'time
            org-log-into-drawer t
            org-log-refile 'time
            org-pretty-entities t
            org-startup-align-all-tables t
            org-plantuml-jar-path "~/.emacs.d/plantuml/plantuml.jar")
    #+END_SRC

**** Org refile
    Next, we setup org refile behaviour. I log all new todos, notes, journal enteries
    etc into a file called refile.org. Later, I refile these entries to the proper
    location. This allows me to take quick notes and get back to what I was working
    on with minimal disturbance.

    Refile targets include this file and any file contributing to the agenda up to 5
    levels deep
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (setq org-refile-targets (quote ((nil :maxlevel . 5)
                                       (org-agenda-files :maxlevel . 5))))
    #+END_SRC

    Targets start with the file name - allows creating level 1 tasks
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (setq org-refile-use-outline-path (quote file))
    #+END_SRC

    Targets complete in steps so we start with filename, TAB shows the next level of
    targets etc
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (setq org-outline-path-complete-in-steps t
            org-refile-allow-creating-parent-nodes 'confirm)
    #+END_SRC

**** Org pomadoro 
    I like to use the pomadoro technique for getting work done. 
    See [[https://en.wikipedia.org/wiki/Pomodoro_Technique][Pomadoro Technique]] for details. There is an org package to help with applying
    this technique using org-mode
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (require-package 'org-pomodoro)
      (after-load 'org-agenda
        (define-key org-agenda-mode-map (kbd "P") 'org-pomodoro))
    #+END_SRC

**** Org elements
    Some key bindings to help with handling org elements
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (after-load 'org
        (define-key org-mode-map (kbd "C-M-<up>") 'org-up-element)
        (when *is-a-mac*
          (define-key org-mode-map (kbd "M-h") nil))
        (define-key org-mode-map (kbd "C-M-<up>") 'org-up-element)
        (when *is-a-mac*
          (define-key org-mode-map (kbd "C-c g") 'org-mac-grab-link)))
    #+END_SRC

**** Org-babel
    Select the source languages we will use with org-babel
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (after-load 'org
        (org-babel-do-load-languages
         'org-babel-load-languages
         '(
           ;;(R . t)
           (ditaa . t)
           (dot . t)
           (emacs-lisp . t)
           ;;(gnuplot . t)
           ;;(haskell . nil)
           (latex . t)
           (ledger . t)
           ;;(ocaml . nil)
           ;;(octave . t)
           (python . t)
           (ruby . t)
           (screen . nil)
           (sh . t)
           (sql . nil)
           (sqlite . t))))
    #+END_SRC

    Some useful babel templates to make it easier to insert source blocks
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (after-load 'org
        ;; add <p for python expansion
        (add-to-list 'org-structure-template-alist
                     '("p" "#+BEGIN_SRC python\n?\n#+END_SRC"
                       "<src lang=\"python\">\n?\n</src>"))
        ;; add <el for emacs-lisp expansion
        (add-to-list 'org-structure-template-alist
                     '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"
                       "<src lang=\"emacs-lisp\">\n?\n</src>")))
    #+END_SRC

**** Org capture 
    Setup my capture templates
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (setq org-capture-templates
            (quote
             (("t" "todo" entry
               (file "~/Dropbox/org/refile.org")
               "* TODO %?
                        %U
                        %a" :empty-lines-after 1 :clock-in t :clock-resume t)
              ("r" "respond" entry
               (file "~/Dropbox/org/refile.org")
               "* NEXT Respond to %:from on %:subject
                        SCHEDULED: %t
                        %U
                        %a" :empty-lines-after 1 :clock-in t :clock-resume t)
              ("n" "note" entry
               (file "~/Dropbox/org/refile.org")
               "* %? :NOTE:
                        %U
                        %a" :empty-lines-after 1 :clock-in t :clock-resume t)
              ("j" "journal" entry
               (file+datetree "~/Dropbox/org/journal.org")
               "* %?
                        %U" :empty-lines-after 1 :clock-in t :clock-resume t)
              ("p" "phone" entry
               (file "~/Dropbox/org/refile.org")
               "* PHONE %? :PHONE:
                        %U" :empty-lines-after 1 :clock-in t :clock-resume t))))
    #+END_SRC

**** Org TODO
    Setup TODO keywords and order
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (setq org-todo-keywords
            (quote
             ((sequence "TODO(t)"
                        "NEXT(n)"
                        "STARTED(s!)"
                        "DELEGATED(w@/!)"
                        "HOLD(h@/!)"
                        "|"
                        "CANCELLED(c@)"
                        "DONE(d!)"))))
    #+END_SRC

    Basic todo config
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (setq org-enforce-todo-checkbox-dependencies t
            org-enforce-todo-dependencies t)
    #+END_SRC

**** Org Agenda     
    Setup custom agenda reports
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (setq org-agenda-custom-commands
            (quote
             (("n" "Agenda and all TODO's"
               ((agenda "" nil)
                (alltodo "" nil))
               nil)
              ("wr" "Weekly Report"
               ((todo "DONE|CANCELLED"
                      ((org-agenda-overriding-header "Completed and Cancelled : Last Week")))
                (todo "STARTED|NEXT"
                      ((org-agenda-overriding-header "WIP")))
                (todo "HOLD|DELEGATED"
                      ((org-agenda-overriding-header "On Hold and Delegated Tasks")))
                (todo "TODO"
                      ((org-agenda-overriding-header "Task Backlog"))))
               nil nil))))
    #+END_SRC

    Basic agenda settings
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (setq  org-agenda-files (quote ("~/Dropbox/org/personal.org"
                                      "~/Dropbox/org/planner.org"
                                      "~/Dropbox/org/policy.org"
                                      "~/Dropbox/org/projects.org"
                                      "~/Dropbox/org/refile.org"
                                      "~/Dropbox/org/security.org"
                                      "~/Dropbox/org/urs.org"
                                      "~/Dropbox/org/storage.org"
                                      "~/Dropbox/org/iam.org"))
             org-agenda-skip-unavailable-files t
             org-agenda-span 14
             org-agenda-remove-tags t)
    #+END_SRC
**** Org Latex exports
     I use the beamer and hitec latex classes
     #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
       (setq org-latex-classes
             '(("beamer" "\\documentclass[presentation]{beamer}\n[DEFAULT-PACKAGES]\n[PACKAGES]\n[EXTRA]"
                ("\\section{%s}" . "\\section*{%s}")
                ("\\subsection{%s}" . "\\subsection*{%s}")
                ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
               ("article" "\\documentclass[a4paper]{hitec}"
                ("\\section{%s}" . "\\section*{%s}")
                ("\\subsection{%s}" . "\\subsection*{%s}")
                ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                ("\\paragraph{%s}" . "\\paragraph*{%s}")
                ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
               ("report" "\\documentclass[12pt]{scrreprt}"
                ("\\part{%s}" . "\\part*{%s}")
                ("\\chapter{%s}" . "\\chapter*{%s}")
                ("\\section{%s}" . "\\section*{%s}")
                ("\\subsection{%s}" . "\\subsection*{%s}")
                ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
               ("book" "\\documentclass[12pt]{scrbook}"
                ("\\part{%s}" . "\\part*{%s}")
                ("\\chapter{%s}" . "\\chapter*{%s}")
                ("\\section{%s}" . "\\section*{%s}")
                ("\\subsection{%s}" . "\\subsection*{%s}")
                ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
     #+END_SRC

     use the lualatex stuff to generate PDFs
     #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (setq org-latex-pdf-process
            '("lualatex -interaction nonstopmode -output-directory %o %f"
              "lualatex -interaction nonstopmode -output-directory %o %f"
              "lualatex -interaction nonstopmode -output-directory %o %f"))
     #+END_SRC

**** Org Taskjuggler 
     I use the ability to export an org file into taskjuggler format for project
     planning and creating pretty graphs for pointy-haired bosses. Unfortunately, it
     appears taskjuggler doesn't yet support the ability to set global project
     settings. I therefore set the org-taskjuggler-default-global-header, which will
     not work, but at least puts these values in the generated file. I can then move
     them into the right place manually.
     #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
       (setq org-taskjuggler-default-global-header
             " timingresolution 60min
               timezone \"Australia/Sydney\"
               dailyworkinghours 7
               workinghours mon - fri 9:00 - 13:00, 14:00 - 17:00
               workinghours sat, sun off
             ")
     #+END_SRC

     Set default project duration to 1 year
     #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (setq org-taskjuggler-default-project-duration 365)
     #+END_SRC     

     Set default report format
     #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
       (setq org-taskjuggler-default-reports
             (quote
              ("textreport report \"Plan\" {
               formats html
               header '== %title =='

               center -8<-
                 [#Plan Plan] | [#Resource_Allocation Resource Allocation]
                 ----
                 === Plan ===
                 <[report id=\"plan\"]>
                 ----
                 === Resource Allocation ===
                 <[report id=\"resourceGraph\"]>
               ->8-
             }

             # A traditional Gantt chart with a project overview.
             taskreport plan \"\" {
               headline \"Project Plan\"
               columns bsi, name, start, end, effort, chart { width 1500 }
               loadunit shortauto
               hideresource 1
             }

             # A graph showing resource allocation. It identifies whether each
             # resource is under- or over-allocated for.
             resourcereport resourceGraph \"\" {
               headline \"Resource Allocation Graph\"
               columns no, name, effort, weekly { width 1500 }
               loadunit shortauto
               hidetask ~(isleaf() & isleaf_())
               sorttasks plan.start.up
             }")))
     #+END_SRC
***** TODO Find fix for taskjuggler project default settings

**** Org clocking
     Basic clock config
     #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
       (setq org-clock-in-resume t
             org-clock-out-remove-zero-time-clocks t
             org-clock-persist t
             org-clock-persistence-insinuate t
             org-time-clocksum-format '(:hours "%d" :require-hours t
                                               :minutes ":%02d" :require-minutes t))
     #+END_SRC

     Remove empty drawers on clock out
     #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
       ;; Remove empty LOGBOOK drawers on clock out
       ;; (defun tx-remove-empty-drawer-on-clock-out ()
       ;;   (interactive)
       ;;   (save-excursion
       ;;     (beginning-of-line 0)
       ;;     (org-remove-empty-drawer-at "LOGBOOK" (point))))

       ;; (add-hook 'org-clock-out-hook 'tx-remove-empty-drawer-on-clock-out 'append)
     #+END_SRC

**** Org export
     #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
       (setq org-export-backends '(ascii beamer html icalendar latex taskjuggler)
             org-export-kill-product-buffer-when-displayed t
             org-export-with-sub-superscripts nil
             org-export-with-tags nil)
     #+END_SRC

**** Org key bindings 
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-org.el
      (global-set-key "\C-cl" 'org-store-link)
      (global-set-key "\C-ca" 'org-agenda)
      (global-set-key "\C-cb" 'org-iswitchb)
      (global-set-key "\C-cr" 'org-capture)


      (provide 'init-org)

    #+END_SRC

** Python
   #+BEGIN_SRC emacs-lisp
   (require 'init-python-mode)
   #+END_SRC

*** init-python-mode.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-python-mode.el
      (setq auto-mode-alist
            (append '(("SConstruct\\'" . python-mode)
                      ("SConscript\\'" . python-mode))
                    auto-mode-alist))

      (require-package 'pip-requirements)

      (provide 'init-python-mode)

    #+END_SRC

** Ruby

   #+BEGIN_SRC emacs-lisp
   (require 'init-ruby-mode)
   #+END_SRC

*** init-ruby-mode.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-ruby-mode.el
      (require-package 'ruby-mode)
      (require-package 'ruby-hash-syntax)

      (add-auto-mode 'ruby-mode
                     "Rakefile\\'" "\\.rake\\'" "\\.rxml\\'"
                     "\\.rjs\\'" "\\.irbrc\\'" "\\.pryrc\\'" "\\.builder\\'" "\\.ru\\'"
                     "\\.gemspec\\'" "Gemfile\\'" "Kirkfile\\'")

      (setq ruby-use-encoding-map nil)

      (after-load 'ruby-mode
        (define-key ruby-mode-map (kbd "TAB") 'indent-for-tab-command)

        ;; Stupidly the non-bundled ruby-mode isn't a derived mode of
        ;; prog-mode: we run the latter's hooks anyway in that case.
        (add-hook 'ruby-mode-hook
                  (lambda ()
                    (unless (derived-mode-p 'prog-mode)
                      (run-hooks 'prog-mode-hook)))))

      (add-hook 'ruby-mode-hook 'subword-mode)

      ;;; Inferior ruby
      (require-package 'inf-ruby)
      (require-package 'ac-inf-ruby)

      (after-load 'auto-complete
        (add-to-list 'ac-modes 'inf-ruby-mode))

      (add-hook 'inf-ruby-mode-hook 'ac-inf-ruby-enable)

      (after-load 'inf-ruby
        (define-key inf-ruby-mode-map (kbd "TAB") 'auto-complete))

      ;;; Ruby compilation
      (require-package 'ruby-compilation)

      (after-load 'ruby-mode
        (let ((m ruby-mode-map))
          (define-key m [S-f7] 'ruby-compilation-this-buffer)
          (define-key m [f7] 'ruby-compilation-this-test)
          (define-key m [f6] 'recompile)))

      ;;; Robe
      (require-package 'robe)

      (after-load 'ruby-mode
        (add-hook 'ruby-mode-hook 'robe-mode))

      (defun sanityinc/maybe-enable-robe-ac ()
        "Enable/disable robe auto-complete source as necessary."
        (if robe-mode
            (progn
              (add-hook 'ac-sources 'ac-source-robe nil t)
              (set-auto-complete-as-completion-at-point-function))
          (remove-hook 'ac-sources 'ac-source-robe)))

      (after-load 'robe
        (add-hook 'robe-mode-hook 'sanityinc/maybe-enable-robe-ac))

      ;;; ri support
      (require-package 'yari)
      (defalias 'ri 'yari)

      ;;; YAML
      (require-package 'yaml-mode)

      ;;; ERB
      (require-package 'mmm-mode)
      (defun sanityinc/ensure-mmm-erb-loaded ()
        (require 'mmm-erb))

      (require 'derived)

      (defun sanityinc/set-up-mode-for-erb (mode)
        (add-hook (derived-mode-hook-name mode) 'sanityinc/ensure-mmm-erb-loaded)
        (mmm-add-mode-ext-class mode "\\.erb\\'" 'erb))

      (let ((html-erb-modes '(html-mode html-erb-mode nxml-mode)))
        (dolist (mode html-erb-modes)
          (sanityinc/set-up-mode-for-erb mode)
          (mmm-add-mode-ext-class mode "\\.r?html\\(\\.erb\\)?\\'" 'html-js)
          (mmm-add-mode-ext-class mode "\\.r?html\\(\\.erb\\)?\\'" 'html-css)))

      (mapc 'sanityinc/set-up-mode-for-erb
            '(coffee-mode js-mode js2-mode js3-mode markdown-mode textile-mode))

      (mmm-add-mode-ext-class 'html-erb-mode "\\.jst\\.ejs\\'" 'ejs)

      (add-auto-mode 'html-erb-mode "\\.rhtml\\'" "\\.html\\.erb\\'")
      (add-to-list 'auto-mode-alist '("\\.jst\\.ejs\\'"  . html-erb-mode))
      (mmm-add-mode-ext-class 'yaml-mode "\\.yaml\\'" 'erb)

      (dolist (mode (list 'js-mode 'js2-mode 'js3-mode))
        (mmm-add-mode-ext-class mode "\\.js\\.erb\\'" 'erb))

      (provide 'init-ruby-mode)

    #+END_SRC
**** TODO hippie-expand ignoring : for names in ruby-mode
**** TODO hippie-expand adaptor for auto-complete sources

** Rails
   #+BEGIN_SRC emacs-lisp
   (require 'init-rails)
   #+END_SRC

*** init-rails.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-rails.el
      (require-package 'rinari)

      (after-load 'rinari
        (diminish 'rinari-minor-mode "Rin"))

      (global-rinari-mode)

      (defun update-rails-ctags ()
        (interactive)
        (let ((default-directory (or (rinari-root) default-directory)))
          (shell-command (concat "ctags -a -e -f " rinari-tags-file-name
                                 " --tag-relative -R app lib vendor test"))))

      (provide 'init-rails)

    #+END_SRC

** SQL
   - See answer to [[https://emacs.stackexchange.com/questions/657/why-do-sql-mode-and-sql-interactive-mode-not-highlight-strings-the-same-way/673][SQL mode and string highlighting ]]

   #+BEGIN_SRC emacs-lisp
   (require 'init-sql)
   #+END_SRC

*** init-sql.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-sql.el
      (require-package 'sql-indent)

      (after-load 'sql
        (require 'sql-indent))

      (defun sanityinc/pop-to-sqli-buffer ()
        "Switch to the corresponding sqli buffer."
        (interactive)
        (if sql-buffer
            (progn
              (pop-to-buffer sql-buffer)
              (goto-char (point-max)))
          (sql-set-sqli-buffer)
          (when sql-buffer
            (sanityinc/pop-to-sqli-buffer))))

      (after-load 'sql
        (define-key sql-mode-map (kbd "C-c C-z") 'sanityinc/pop-to-sqli-buffer)
        (add-hook 'sql-interactive-mode-hook 'sanityinc/never-indent)
        (when (package-installed-p 'dash-at-point)
          (defun sanityinc/maybe-set-dash-db-docset ()
            (when (eq sql-product 'postgres)
              (setq dash-at-point-docset "psql")))

          (add-hook 'sql-mode-hook 'sanityinc/maybe-set-dash-db-docset)
          (add-hook 'sql-interactive-mode-hook 'sanityinc/maybe-set-dash-db-docset)
          (defadvice sql-set-product (after set-dash-docset activate)
            (sanityinc/maybe-set-dash-db-docset))))

      (setq-default sql-input-ring-file-name
                    (expand-file-name ".sqli_history" user-emacs-directory))

      (defun sanityinc/font-lock-everything-in-sql-interactive-mode ()
        (unless (eq 'oracle sql-product)
          (sql-product-font-lock nil nil)))

      (add-hook 'sql-interactive-mode-hook
                'sanityinc/font-lock-everything-in-sql-interactive-mode)

      (after-load 'page-break-lines
        (push 'sql-mode page-break-lines-modes))

      (provide 'init-sql)

    #+END_SRC

** Paredit
   - See [[http://emacsredux.com/blog/2013/04/18/evaluate-emacs-lisp-in-the-minibuffer/][Paredit in the minibuffer]]
   #+BEGIN_SRC emacs-lisp
   (require 'init-paredit)
   #+END_SRC

*** init-paredit.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-paredit.el
      (require-package 'paredit)
      (autoload 'enable-paredit-mode "paredit")

      (defun maybe-map-paredit-newline ()
        (unless (or (memq major-mode '(inferior-emacs-lisp-mode cider-repl-mode))
                    (minibufferp))
          (local-set-key (kbd "RET") 'paredit-newline)))

      (add-hook 'paredit-mode-hook 'maybe-map-paredit-newline)

      (after-load 'paredit
        (diminish 'paredit-mode " PE")
        ;; (dolist (binding (list (kbd "C-<left>") (kbd "C-<right>")
        ;;                        (kbd "C-M-<left>") (kbd "C-M-<right>")))
        ;;   (define-key paredit-mode-map binding nil))

        ;; Disable kill-sentence, which is easily confused with the kill-sexp
        ;; binding, but doesn't preserve sexp structure
        (define-key paredit-mode-map [remap kill-sentence] nil)
        (define-key paredit-mode-map [remap backward-kill-sentence] nil)

        ;; Allow my global binding of M-? to work when paredit is active
        (define-key paredit-mode-map (kbd "M-?") nil))

      ;; Use paredit in the minibuffer
      (add-hook 'minibuffer-setup-hook 'conditionally-enable-paredit-mode)

      (defvar paredit-minibuffer-commands '(eval-expression
                                            pp-eval-expression
                                            eval-expression-with-eldoc
                                            ibuffer-do-eval
                                            ibuffer-do-view-and-eval)
        "Interactive commands for which paredit should be enabled in the minibuffer.")

      (defun conditionally-enable-paredit-mode ()
        "Enable paredit during lisp-related minibuffer commands."
        (if (memq this-command paredit-minibuffer-commands)
            (enable-paredit-mode)))

      ;; Enable some handy paredit functions in all prog modes
      (require-package 'paredit-everywhere)
      (add-hook 'prog-mode-hook 'paredit-everywhere-mode)
      (add-hook 'css-mode-hook 'paredit-everywhere-mode)

      (provide 'init-paredit)

    #+END_SRC

** Lisp
   #+BEGIN_SRC emacs-lisp
   (require 'init-lisp)
   #+END_SRC

*** init-lisp.el
    - Delete .elc files when reverting the .el from VC or magit When .el files are
      open, we can intercept when they are modified by VC or magit in order to remove
      .elc files that are likely to be out of sync. This is handy while actively
      working on elisp files, though obviously it doesn't ensure that unopened files
      will also have their .elc counterparts removed - VC hooks would be necessary
      for that.

    #+BEGIN_SRC emacs-lisp :tangle lisp/init-lisp.el
      ;;;(require-package 'elisp-slime-nav)

      ;; (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
      ;;   (add-hook hook 'elisp-slime-nav-mode))

      ;;(require-package 'lively)

      (setq-default initial-scratch-message
                    (concat ";; Happy hacking " (or user-login-name "") "!\n\n"))

      ;; Make C-x C-e run 'eval-region if the region is active
      (defun sanityinc/eval-last-sexp-or-region (prefix)
        "Eval region from BEG to END if active, otherwise the last sexp."
        (interactive "P")
        (if (and (mark) (use-region-p))
            (eval-region (min (point) (mark)) (max (point) (mark)))
          (pp-eval-last-sexp prefix)))

      (global-set-key (kbd "M-:") 'pp-eval-expression)

      (after-load 'lisp-mode
        (define-key emacs-lisp-mode-map (kbd "C-x C-e") 'sanityinc/eval-last-sexp-or-region))

      ;; (require-package 'ipretty)
      ;; (ipretty-mode 1)

      ;; (defadvice pp-display-expression (after make-read-only
      ;;                                         (expression out-buffer-name) activate)
      ;;   "Enable `view-mode' in the output buffer - if any - so it can be closed with `\"q\"."
      ;;   (when (get-buffer out-buffer-name)
      ;;     (with-current-buffer out-buffer-name
      ;;       (view-mode 1))))

      ;; Use C-c C-z to toggle between elisp files and an ielm session
      ;; I might generalise this to ruby etc., or even just adopt the repl-toggle package.
      (defvar sanityinc/repl-original-buffer nil
        "Buffer from which we jumped to this REPL.")
      (make-variable-buffer-local 'sanityinc/repl-original-buffer)

      (defvar sanityinc/repl-switch-function 'switch-to-buffer-other-window)

      (defun sanityinc/switch-to-ielm ()
        (interactive)
        (let ((orig-buffer (current-buffer)))
          (if (get-buffer "*ielm*")
              (funcall sanityinc/repl-switch-function "*ielm*")
            (ielm))
          (setq sanityinc/repl-original-buffer orig-buffer)))

      (defun sanityinc/repl-switch-back ()
        "Switch back to the buffer from which we reached this REPL."
        (interactive)
        (if sanityinc/repl-original-buffer
            (funcall sanityinc/repl-switch-function sanityinc/repl-original-buffer)
          (error "No original buffer.")))

      (after-load 'lisp-mode
        (define-key emacs-lisp-mode-map (kbd "C-c C-z") 'sanityinc/switch-to-ielm))

      (after-load 'ielm
        (define-key ielm-map (kbd "C-c C-z") 'sanityinc/repl-switch-back))

      ;; Hippie-expand
      (defun my/emacs-lisp-module-name ()
        "Search the buffer for `provide' declaration."
        (save-excursion
          (goto-char (point-min))
          (when (search-forward-regexp "^(provide '" nil t)
            (symbol-name (symbol-at-point)))))

      ;; Credit to Chris Done for this one.
      (defun my/try-complete-lisp-symbol-without-namespace (old)
        "Hippie expand \"try\" function which expands \"-foo\" to \"modname-foo\" in elisp."
        (unless old
          (he-init-string (he-lisp-symbol-beg) (point))
          (when (string-prefix-p "-" he-search-string)
            (let ((mod-name (my/emacs-lisp-module-name)))
              (when mod-name
                (setq he-expand-list (list (concat mod-name he-search-string)))))))
        (when he-expand-list
          (he-substitute-string (car he-expand-list))
          (setq he-expand-list nil)
          t))

      (defun set-up-hippie-expand-for-elisp ()
        "Locally set `hippie-expand' completion functions for use with Emacs Lisp."
        (make-local-variable 'hippie-expand-try-functions-list)
        (add-to-list 'hippie-expand-try-functions-list 'try-complete-lisp-symbol t)
        (add-to-list 'hippie-expand-try-functions-list 'try-complete-lisp-symbol-partially t)
        (add-to-list 'hippie-expand-try-functions-list
                     'my/try-complete-lisp-symbol-without-namespace t))


      ;; Automatic byte compilation
      (require-package 'auto-compile)
      (auto-compile-on-save-mode 1)
      (auto-compile-on-load-mode 1)

      ;; Load .el if newer than corresponding .elc
      (setq load-prefer-newer t)

      ;; Highlight current sexp
      ;;(require-package 'hl-sexp)

      ;; Prevent flickery behaviour due to hl-sexp-mode unhighlighting before each command
      ;; (after-load 'hl-sexp
      ;;   (defadvice hl-sexp-mode (after unflicker (&optional turn-on) activate)
      ;;     (when turn-on
      ;;       (remove-hook 'pre-command-hook #'hl-sexp-unhighlight))))

      ;;; Support byte-compilation in a sub-process, as
      ;;; required by highlight-cl
      (defun sanityinc/byte-compile-file-batch (filename)
        "Byte-compile FILENAME in batch mode, ie. a clean sub-process."
        (interactive "fFile to byte-compile in batch mode: ")
        (let ((emacs (car command-line-args)))
          (compile
           (concat
            emacs " "
            (mapconcat
             'shell-quote-argument
             (list "-Q" "-batch" "-f" "batch-byte-compile" filename)
             " ")))))

      ;; Enable desired features for all lisp modes
      (require-package 'rainbow-delimiters)
      ;; (require-package 'redshank)
      ;; (after-load 'redshank
      ;;   (diminish 'redshank-mode))

      (maybe-require-package 'aggressive-indent)

      (defun sanityinc/lisp-setup ()
        "Enable features useful in any Lisp mode."
        (rainbow-delimiters-mode t)
        (enable-paredit-mode)
        (when (fboundp 'aggressive-indent-mode)
          (aggressive-indent-mode))
        (turn-on-eldoc-mode)
      ;;  (redshank-mode)
        (add-hook 'after-save-hook #'check-parens nil t))

      (defun sanityinc/emacs-lisp-setup ()
        "Enable features useful when working with elisp."
      ;  (elisp-slime-nav-mode t)
        (set-up-hippie-expand-for-elisp)
        (ac-emacs-lisp-mode-setup))

      (defconst sanityinc/elispy-modes
        '(emacs-lisp-mode ielm-mode)
        "Major modes relating to elisp.")

      (defconst sanityinc/lispy-modes
        (append sanityinc/elispy-modes
                '(lisp-mode inferior-lisp-mode lisp-interaction-mode))
        "All lispy major modes.")

      (require 'derived)

      (dolist (hook (mapcar #'derived-mode-hook-name sanityinc/lispy-modes))
        (add-hook hook 'sanityinc/lisp-setup))

      (dolist (hook (mapcar #'derived-mode-hook-name sanityinc/elispy-modes))
        (add-hook hook 'sanityinc/emacs-lisp-setup))

      (if (boundp 'eval-expression-minibuffer-setup-hook)
          (add-hook 'eval-expression-minibuffer-setup-hook #'eldoc-mode)
        (require-package 'eldoc-eval)
        (require 'eldoc-eval)
        (eldoc-in-minibuffer-mode 1))

      (add-to-list 'auto-mode-alist '("\\.emacs-project\\'" . emacs-lisp-mode))
      (add-to-list 'auto-mode-alist '("archive-contents\\'" . emacs-lisp-mode))

      ;; (require-package 'cl-lib-highlight)
      ;; (after-load 'lisp-mode
      ;;   (cl-lib-highlight-initialize))


      (defvar sanityinc/vc-reverting nil
        "Whether or not VC or Magit is currently reverting buffers.")

      (defadvice revert-buffer (after sanityinc/maybe-remove-elc activate)
        "If reverting from VC, delete any .elc file that will now be out of sync."
        (when sanityinc/vc-reverting
          (when (and (eq 'emacs-lisp-mode major-mode)
                     buffer-file-name
                     (string= "el" (file-name-extension buffer-file-name)))
            (let ((elc (concat buffer-file-name "c")))
              (when (file-exists-p elc)
                (message "Removing out-of-sync elc file %s" (file-name-nondirectory elc))
                (delete-file elc))))))

      (defadvice magit-revert-buffers (around sanityinc/reverting activate)
        (let ((sanityinc/vc-reverting t))
          ad-do-it))

      (defadvice vc-revert-buffer-internal (around sanityinc/reverting activate)
        (let ((sanityinc/vc-reverting t))
          ad-do-it))

      (require-package 'macrostep)

      (after-load 'lisp-mode
        (define-key emacs-lisp-mode-map (kbd "C-c e") 'macrostep-expand))

      ;; A quick way to jump to the definition of a function given its key binding
      (global-set-key (kbd "C-h K") 'find-function-on-key)

      (when (maybe-require-package 'rainbow-mode)
        (defun sanityinc/enable-rainbow-mode-if-theme ()
          (when (string-match "\\(color-theme-\\|-theme\\.el\\)" (buffer-name))
            (rainbow-mode 1)))

        (add-hook 'emacs-lisp-mode-hook 'sanityinc/enable-rainbow-mode-if-theme))

      ;; (when (maybe-require-package 'highlight-quoted)
      ;;   (add-hook 'emacs-lisp-mode-hook 'highlight-quoted-mode))

      ;; ERT
      (after-load 'ert
        (define-key ert-results-mode-map (kbd "g") 'ert-results-rerun-all-tests))

      (defun sanityinc/cl-libify-next ()
        "Find next symbol from 'cl and replace it with the 'cl-lib equivalent."
        (interactive)
        (let ((case-fold-search nil))
          (re-search-forward
           (concat
            "("
            (regexp-opt
             ;; Not an exhaustive list
             '("loop" "incf" "plusp" "first" "decf" "minusp" "assert"
               "case" "destructuring-bind" "second" "third" "defun*"
               "defmacro*" "return-from" "labels" "cadar" "fourth"
               "cadadr") t)
            "\\_>")))
        (let ((form (match-string 1)))
          (backward-sexp)
          (cond
           ((string-match "^\\(defun\\|defmacro\\)\\*$")
            (kill-sexp)
            (insert (concat "cl-" (match-string 1))))
           (t
            (insert "cl-")))
          (when (fboundp 'aggressive-indent-indent-defun)
            (aggressive-indent-indent-defun))))

      (provide 'init-lisp)

    #+END_SRC

** Clojure
   #+BEGIN_SRC emacs-lisp
   (require 'init-clojure)
   #+END_SRC

*** init-clojure.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-clojure.el
      (require-package 'clojure-mode)
      (require-package 'cljsbuild-mode)
      (require-package 'elein)


      ;; Misc clojure tweaks
      (after-load 'clojure-mode
        (add-hook 'clojure-mode-hook 'sanityinc/lisp-setup)
        (add-hook 'clojure-mode-hook 'subword-mode))

      ;; Use clojure-mode for clojurescript, since clojurescript-mode
      ;; pulls in Slime
      (add-auto-mode 'clojure-mode "\\.cljs\\'")

      (provide 'init-clojure)

    #+END_SRC

** Cider
   #+BEGIN_SRC emacs-lisp
   (require 'init-cider)
   #+END_SRC

*** init-cider.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-cider.el
      (require 'init-clojure)
      (require-package 'cider)
      (require-package 'ac-cider)

      (setq nrepl-popup-stacktraces nil)

      (after-load 'cider
        (add-hook 'cider-repl-mode-hook 'ac-cider-setup)
        (add-hook 'cider-mode-hook 'ac-cider-setup)
        (after-load 'auto-complete
          (add-to-list 'ac-modes 'cider-repl-mode))

        (add-hook 'cider-repl-mode-hook 'set-auto-complete-as-completion-at-point-function)
        (add-hook 'cider-mode-hook 'set-auto-complete-as-completion-at-point-function)
        (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
        (add-hook 'cider-repl-mode-hook 'subword-mode)
        (add-hook 'cider-repl-mode-hook 'paredit-mode)
        (define-key cider-mode-map (kbd "C-c C-d") 'ac-cider-popup-doc)

        ;; nrepl isn't based on comint
        (add-hook 'cider-repl-mode-hook
                  (lambda () (setq show-trailing-whitespace nil))))

      (provide 'init-cider)

    #+END_SRC

** Spelling
   When running on OSX it is necessary to 
   - Install a spell checker. I prefer to use /homebrew/ to install both emacs and
     associated programs i.e
     : brew install hunspell
   - Note that you also need to install the dictionaries. I use the dictionaries from
     openOffice. These are distributed in /*.oxt/ files, which are just /zip/
     archives. Unzip them and put the /*.aff/ and /*.dic/ files in
     /~/Library/Spelling/ directory.
   - I also setup symbolic links from the dictionaries I want to /default.aff/ and /default.dic/

   #+BEGIN_SRC emacs-lisp
   (when *spell-check-support-enabled*
      (require 'init-spelling))
   #+END_SRC

*** init-flyspell.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-flyspell.el
      ;; Add spell-checking in comments for all programming language modes
      (if (fboundp 'prog-mode)
          (add-hook 'prog-mode-hook 'flyspell-prog-mode)
        (dolist (hook '(lisp-mode-hook
                        emacs-lisp-mode-hook
                        scheme-mode-hook
                        clojure-mode-hook
                        ruby-mode-hook
                        yaml-mode
                        python-mode-hook
                        shell-mode-hook
                        php-mode-hook
                        css-mode-hook
                        haskell-mode-hook
                        caml-mode-hook
                        nxml-mode-hook
                        crontab-mode-hook
                        perl-mode-hook
                        tcl-mode-hook
                        javascript-mode-hook))
          (add-hook hook 'flyspell-prog-mode)))

      (after-load 'flyspell
        (add-to-list 'flyspell-prog-text-faces 'nxml-text-face))

      (provide 'init-flyspell)

    #+END_SRC

*** init-spelling.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-spelling.el
      (if *is-a-mac*
          (setq ispell-dictionary "british")
        (setq ispell-dictionary "british-ise"))

      (require 'ispell)

      (when (executable-find ispell-program-name)
        (require 'init-flyspell))

      (provide 'init-spelling)

    #+END_SRC

** Ledger
   #+BEGIN_SRC emacs-lisp
   (require 'init-ledger)
   #+END_SRC

*** init-ledger.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-ledger.el
      (require-package 'ledger-mode)

      (add-to-list 'auto-mode-alist '("\\.ledger$" . ledger-mode))

      (after-load 'ledger-mode
        (define-key ledger-mode-map (kbd "RET") 'newline)
        (define-key ledger-mode-map (kbd "C-o") 'open-line))

      (setq ledger-highlight-xact-under-point nil
            ledger-use-iso-dates nil)

      (when (memq window-system '(mac ns))
        (exec-path-from-shell-copy-env "LEDGER_FILE"))

      (add-hook 'ledger-mode-hook 'goto-address-prog-mode)

      (provide 'init-ledger)

    #+END_SRC

** Edit Server
   I use edit server so that I can edit textareas within chrome web pages using emacs
   #+BEGIN_SRC emacs-lisp
   (require 'init-edit-server)
   #+END_SRC
**** init-edit-server.el
     #+BEGIN_SRC emacs-lisp :tangle lisp/init-edit-server.el
       (require-package 'edit-server)

       (after-load 'edit-server
         (edit-server-start))

       (provide 'init-edit-server)
     #+END_SRC
** Emacs Server
   #+BEGIN_SRC emacs-lisp
     (require 'init-server)
   #+END_SRC

*** init-server
    Seem to run into some problems on my OSX due to directory permissions. Seems like
    this may be related to the default umask. Anyway, resulted in being unable to
    start the emacs server as we would get a message about the socket directory being
    unsafe.

    Solved the problem by moving the server socket directory to be under
    : ~/.emacs.d/server/socket
    and ensuring the /server/ and /socket/ directories only had rwx permissions for
    the user

    #+BEGIN_SRC emacs-lisp :tangle lisp/init-server.el
      (when *is-a-mac*
        (setq server-socket-dir "~/.emacs.d/server/socket"))

      (require 'server)

      (server-start)

      (provide 'init-server)
    #+END_SRC

** ipcalc
   
** Misc
   #+BEGIN_SRC emacs-lisp
   (require 'init-misc)
   #+END_SRC

*** init-misc.el
    #+BEGIN_SRC emacs-lisp :tangle lisp/init-misc.el
      ;;----------------------------------------------------------------------------
      ;; Misc config - yet to be placed in separate files
      ;;----------------------------------------------------------------------------
      (add-auto-mode 'tcl-mode "Portfile\\'")
      (fset 'yes-or-no-p 'y-or-n-p)

      (dolist (hook (if (fboundp 'prog-mode)
                        '(prog-mode-hook ruby-mode-hook)
                      '(find-file-hooks)))
        (add-hook hook 'goto-address-prog-mode))
      (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
      (setq goto-address-mail-face 'link)

      (setq-default regex-tool-backend 'perl)

      (add-auto-mode 'conf-mode "Procfile")

      (setq message-log-max 2048)

      (global-unset-key "\C-x\C-c")
      (global-set-key "\C-x\C-c" 'save-buffers-kill-emacs)

      (setq-default fill-column 85)

      (add-hook 'text-mode-hook 'turn-on-auto-fill)
      (add-hook 'text-mode-hook 'flyspell-mode)

      (setq auth-sources '("~/.authinfo.gpg" "~/.authinfo" "~/.netrc")
            delete-by-moving-to-trash t
            delete-old-versions t
            doc-view-resolution 140
            line-move-visual nil
            url-personal-mail-address "tcross@une.edu.au"
            eldoc-idle-delay 5.5)

      (setq-default save-place t)
      (require 'saveplace)

      (tool-bar-mode -1)
      (tooltip-mode -1)
      (show-paren-mode)
      (line-number-mode 1)
      (add-to-list 'load-path (expand-file-name "lib" user-emacs-directory))
      (require 'ipcalc)

      (provide 'init-misc)

    #+END_SRC
