#+TITEL: Emacs init.el File
#+DATE: \today
#+AUTHOR: Tim Cross

* Early Init

Emacs 27 introduces an early init file. This is a good place to set some frame defaults and tweak the gc to speed up init process
The below has been borrowed from Doom Emacs.

Defer garbage collection further back in the startup process

#+begin_src emacs-lisp :tangle tangle-early-init.el
  (setq gc-cons-threshold 268435456)

#+end_src

Package initialize occurs automatically, before `user-init-file' is
loaded, but after `early-init-file'. We handles package
initialization, so we must prevent Emacs from doing it early!

#+begin_src emacs-lisp :tangle tangle-early-init.el
(setq package-enable-at-startup nil)

#+end_src

Prevent the glimpse of un-styled Emacs by setting these early.

#+begin_src emacs-lisp :tangle tangle-early-init.el
(add-to-list 'default-frame-alist '(tool-bar-lines . 0))
(add-to-list 'default-frame-alist '(menu-bar-lines . 0))
(add-to-list 'default-frame-alist '(vertical-scroll-bars))

#+end_src

One less file to load at startup

#+begin_src emacs-lisp :tangle tangle-early-init.el
(setq site-run-file nil)

#+end_src

* GC Settings

#+begin_src emacs-lisp :tangle tangle-init.el
  (defvar tx-gc-cons-threshold 16777216 ; 16mb
    "The default value to use for `gc-cons-threshold'. If you experience freezing,
  decrease this. If you experience stuttering, increase this.")

  (defvar tx-gc-cons-upper-limit 536870912 ; 512mb
    "The temporary value for `gc-cons-threshold' to defer it.")

  (defvar tx-file-name-handler-alist file-name-handler-alist)
#+end_src

Function to restore default gc etc after init.

#+begin_src emacs-lisp :tangle tangle-init.el
  (defun tx-restore-startup-optimizations ()
    "Resets garbage collection settings to reasonable defaults (a large
  `gc-cons-threshold' can cause random freezes otherwise) and resets
  `file-name-handler-alist'."
    (setq file-name-handler-alist tx-file-name-handler-alist)
    ;; Do this on idle timer to defer a possible GC pause that could result; also
    ;; allows deferred packages to take advantage of these optimizations.
    (run-with-idle-timer
     3 nil
     (lambda ()
       (setq-default gc-cons-threshold tx-gc-cons-threshold)
       ;; To speed up minibuffer commands (like helm and ivy), we defer garbage
       ;; collection while the minibuffer is active.
       (defun tx-defer-garbage-collection ()
	 (setq gc-cons-threshold tx-gc-cons-upper-limit))
       (defun tx-restore-garbage-collection ()
	 ;; Defer it so that commands launched from the minibuffer can enjoy the
	 ;; benefits.
	 (run-at-time 1 nil (lambda ()
			      (setq gc-cons-threshold tx-gc-cons-threshold))))
       (add-hook 'minibuffer-setup-hook #'tx-defer-garbage-collection)
       (add-hook 'minibuffer-exit-hook  #'tx-restore-garbage-collection)
       ;; GC all sneaky breeky like
       (add-hook 'focus-out-hook #'garbage-collect))))


  (if (ignore-errors (or after-init-time noninteractive))
      (setq gc-cons-threshold tx-gc-cons-threshold)
    ;; A big contributor to startup times is garbage collection. We up the gc
    ;; threshold to temporarily prevent it from running, then reset it later in
    ;; `tx-restore-startup-optimizations'.
    (setq gc-cons-threshold tx-gc-cons-upper-limit)
    ;; This is consulted on every `require', `load' and various path/io functions.
    ;; You get a minor speed up by nooping this.
    (setq file-name-handler-alist nil)
    ;; Not restoring these to their defaults will cause stuttering/freezes.
    (add-hook 'after-init-hook #'tx-restore-startup-optimizations))

#+end_src

Set things for fast load

#+begin_src emacs-lisp :tangle tangle-init.el
  (if (ignore-errors (or after-init-time noninteractive))
      (setq gc-cons-threshold tx-gc-cons-threshold)
    ;; A big contributor to startup times is garbage collection. We up the gc
    ;; threshold to temporarily prevent it from running, then reset it later in
    ;; `tx-restore-startup-optimizations'.
    (setq gc-cons-threshold tx-gc-cons-upper-limit)
    ;; This is consulted on every `require', `load' and various path/io functions.
    ;; You get a minor speed up by nooping this.
    (setq file-name-handler-alist nil)
    ;; Not restoring these to their defaults will cause stuttering/freezes.
    (add-hook 'after-init-hook #'tx-restore-startup-optimizations))

  (setq load-prefer-newer noninteractive)

#+end_src

* Load Path
The following adds additional directories to the emacs load-path so that
emacs can find various additional libraries etc

Any small third party libraries I use which are not packaged in an ELPA
repository go in the ~.emacs.d/lib~  subdirectory.

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (add-to-list 'load-path (expand-file-name "lib" user-emacs-directory))

#+END_SRC

* Set Some Constants
I set a couple of constants which can then be used to control configuration
settings in my init file.

** Mac or Linux?

I run emacs on both OSX and Linux. To handle differences in configuration
settings for the two platforms, I set a constant which determines if emacs is
running on OSX or not. 

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (defconst *is-a-mac* (eq system-type 'darwin)
    "T if emacs is running under OSX, nil otherwise.")
#+END_SRC

** Do Spell Checking?

Set a constant to determine if spell checking is to be enabled. Not sure if I
really need this, but leaving it in place for now.

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (defconst *spell-check-support-enabled* t
    "T if we want spell checking support enabled, nil otherwise.")
#+END_SRC

** Silence Warnings

Some ELISP packages don't necessarily define variables correctly and can
generate warnings. This section lists such variables to quieten things down a
bit.

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (defvar url-http-extra-headers nil)
  (defvar oauth--token-data nil)
  (defvar url-callback-function nil)
  (defvar url-callback-arguments nil)
  (defvar emacspeak-we-url-executor nil)
  (defvar org-ans2 nil)
  (defvar ido-process-ignore-lists nil)
  (defvar select-object nil)
  (defvar *slime-inspector* nil)

#+END_SRC

** Load Emacspeak

#+begin_src emacs-lisp :tangle tangle-init.el
  (defconst *run_emacspeak* (if (getenv "RUN_EMACSPEAK") t nil))

#+end_src

* OS

** General

#+begin_src emacs-lisp :tangle tangle-init.el
  (defun tx-init-clipboard-in-tty-emacs ()
    (if *is-a-mac
	(if (require 'osx-clipboard nil t)
	    (osx-clipboard-mode))
      (if (require 'xclip nil t)
	  (xclip-mode))))

  (add-hook 'tty-setup-hook #'tx-init-clipboard-in-tty-emacs)

  ;; Enable mouse in terminal Emacs
  (add-hook 'tty-setup-hook #'xterm-mouse-mode)

#+end_src

** OSX/macOS

#+begin_src emacs-lisp :tangle tangle-init.el
  (when *is-a-mac*
    (setq mac-command-modifier 'meta
	  mac-option-modifier 'none
	  dired-free-space-program "gdf"
	  insert-directory-program "gls"
	  default-input-method "MacOSX"
	  mouse-wheel-scroll-amount '(1 ((shift) . 5)
					((control)))
	  command-line-x-option-alist nil
	  mac-redisplay-dont-reset-vscroll t
	  mac-mouse-wheel-smooth-scroll nil
	  ns-use-native-fullscreen nil
	  ns-pop-up-frames nil)
  
    ;; (when (and (or (daemonp)
    ;;                (display-graphic-p))
    ;;            (require 'ns-auto-titlebar nil t))
    ;;   (add-hook 'load-theme-hook #'ns-auto-titlebar-mode
    (dolist (multiple '("" "double-" "triple-"))
      (dolist (direction '("right" "left"))
	(global-set-key (read-kbd-macro
			 (concat "<" multiple "wheel-" direction ">")) 'ignore)))
    (bind-key "M-'" 'ns-next-frame)
    (bind-key "M-h" 'ns-do-hide-emacs)
    (bind-key "M-`" 'ms-do-hide-others)
    (use-package applescript-mode
      :ensure t
      :mode ("\\.applescript" . applescript-mode))
    ;; (use-package osx-plist
    ;;   :ensure t)
    (use-package osx-trash
      :ensure t
      :config (osx-trash-setup))
    (use-package grab-mac-link
      :ensure t
      :bind (:map org-mode-map ("C-c g" . grab-mac-link))))

#+end_src

** Linux

#+begin_src emacs-lisp :tangle tangle-init.el
   (when (not *is-a-mac*)
     (setq x-gtk-use-system-tooltips nil    ; native tooltips are ugly!
	   x-underline-at-descent-line t
	   command-line-ns-option-alist nil))

#+end_src

* Emacspeak

Now load Emacspeak. As Emacspeak makes extensive use of Emacs' =defacvice=
facility, it is important that it is loaded as early as possible in the Emacs
boot process.

First, setup a constant which tells emacs where to look for the emacspeak distro

** Emacspeak Loading Constants

#+BEGIN_SRC emacs-lisp  :tangle tangle-init.el
  (when *run_emacspeak*
    (defconst *emacspeak-src-dir* (if (getenv "EMACSPEAK_DIR")
                                      (expand-file-name (getenv "EMACSPEAK_DIR"))
                                    (expand-file-name "~/git/emacspeak/trunk"))
      "Where emacs will find the emacspeak distro")

    (defconst *dtk-program* (if (getenv "DTK_PROGRAM")
                                (getenv "DTK_PROGRAM")
                              (if *is-a-mac*
                                  "mac"
                                "espeak")))
  
    (require 'info)
    (add-to-list 'Info-additional-directory-list
                 (expand-file-name "info"  *emacspeak-src-dir*)))

#+END_SRC

** Load Emacspeak
When emacs is not being run in batch mode and when emacspeak is not yet loaded,
then load it

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (when (and *run_emacspeak*
             (not noninteractive)
             (not (featurep 'emacspeak)))
    (add-to-list 'load-path *emacspeak-src-dir*)
    (setenv "EMACSPEAK_DIR" *emacspeak-src-dir*)
    (setenv "DTK_PROGRAM" *dtk-program*)
    (setq dtk-program *dtk-program*
          dtk-use-tones nil
          emacspeak-auditory-icon-function 'emacspeak-soxplay-auditory-icon
          emacspeak-erc-my-nick "theophilusx"
          emacspeak-erc-speak-all-participants t
          emacspeak-mail-alert nil
          emacspeak-play-emacspeak-startup-icon nil
          emacspeak-vm-use-raman-settings nil
          emacspeak-play-program (expand-file-name "~/bin/play")
          emacpseak-play-args nil
          mac-default-speech-rate 360        
          outloud-default-speech-rate 90
          sox-play (if *is-a-mac*
                       "/usr/local/bin/play"
                     "/usr/bin/play")
          emacspeak-soxplay-command (if *is-a-mac*
                                        "/usr/local/bin/play -v 1.2 %s earwax &"
                                      "/usr/bin/play -v 1.2 %s earwax &")
          tts-default-speech-rate 90)

    (add-hook 'emacspeak-startup-hook
              (lambda ()
                ;; (dtk-set-rate tts-default-speech-rate 1)
                (dtk-interp-sync)
                (emacspeak-sounds-select-theme "3d/")))

    (load-file (concat *emacspeak-src-dir* "/lisp/emacspeak-setup.el")))
#+END_SRC

I like to set my own key bindings and there are a lot of emacspeak key bindings
I don't need/want. However, emacspeak does a key binding /refresh/ at the end of
the init process by adding some emacspeak setup functions to the
=after-init-hook=. This means we need to make our setup changes in this hook and
ensure our changes are added /after/ emacspeak hook functions run by appending
them.

** Emacspeak Key Bindings

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (when *run_emacspeak*
    (defun my-esp-bindings ()
      (message "Loading my emacspeak key bindings...")
      (unbind-key "<S-left>")
      (unbind-key "<S-right>")
      (unbind-key "<C-left>")
      (unbind-key "<C-right>")
      (unbind-key "<C-down>")
      (unbind-key "<C-up>")
      (unbind-key "<S-up>")
      (unbind-key "<S-down>")
      (bind-key "<f5>" 'my-hydra-window/body)
      (bind-key "<f7>" 'my-hydra-wizards/body)
      (bind-key "C-z" 'my-hydra-zoom/body))

    (add-hook 'after-init-hook #'my-esp-bindings t))

#+END_SRC

 I've added a little of my own extensions/enhancements to Emacspeak. Once I feel
 they are mature enough, I will generally submit them for inclusion 

* Custom 

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (if *is-a-mac*
      (setq custom-file (expand-file-name "mac-custom.el" user-emacs-directory))
    (setq custom-file (expand-file-name "linux-custom.el" user-emacs-directory)))

  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

* ELPA

ELPA has made managing add-on elisp packages *much* easier than it use to
be. The trick is to only load packages you really want/need and not get carried
away loading lots of additional packages /just in case/.


First, we need to load package.el and then we need to add some additional
package repositories. I add

   - The Org repository so that I can use most recent org-plus-contrib package
   - The melpa repository

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (require 'package)

  (setq package-enable-at-startup nil
        package-archive-priorities '(("org" . 2) ("melpa" . 1) ("gnu" . 0)))

  (add-to-list 'package-archives `("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (package-initialize)

#+END_SRC

* Use Package

I just found John Wiegley's use-package macro, which I think is a really
convenient way to manage the installation and configuration of ELPA
packages. Therefore, I plan to migrate my configuration to use that package.

We have a slight bootstrap or /chicken and egg/ problem, we need the use-package
package from ELPA before we can use it, but it is what we want to use to install
the package. Therefore, need a simple light weight way to get that package. Lets
do the simple way

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'diminish)
    (package-install 'delight)
    (package-install 'bind-key)
    (package-install 'use-package))

  (setq use-package-verbose nil)

  ;; melpa version of use-package currently broken. Load from git clone instead
  ;; (eval-when-compile
  ;;   ;; Following line is not needed if use-package.el is in ~/.emacs.d
  ;;   (add-to-list 'load-path "~/git/github/use-package")
  ;;   (require 'use-package))

  (eval-when-compile
    (require 'use-package))
  (require 'diminish)
  (require 'bind-key)
#+END_SRC

* Fonts
Set the default font

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (if *is-a-mac*
      (progn
	(set-face-attribute 'default nil
			    :foundry nil
			    :family "Fira Code"
			    :height 361)
	(mac-auto-operator-composition-mode))
    (set-face-attribute 'default nil
			;;:foundry "CTDB"
			:family "Fira Code"
			:height 200))

#+END_SRC

* Theme 

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  ;; (use-package solarized-theme
  ;;   :ensure t
  ;;   :init 
  ;;   (setq-default custom-enabled-themes '(solarized-dark))
  ;;   (setq solarized-distinct-fringe-background +1)
  ;;   (setq solarized-use-more-italic t)
  ;;   :config
  ;;   (defun reapply-themes ()
  ;;     "Forcibly load the themes listed in `custom-enabled-themes'."
  ;;     (dolist (theme custom-enabled-themes)
  ;;       (unless (custom-theme-p theme)
  ;;         (load-theme theme)))
  ;;     (custom-set-variables `(custom-enabled-themes
  ;;                             (quote ,custom-enabled-themes))))
  ;;   (add-hook 'after-init-hook 'reapply-themes))

  (use-package night-owl-theme
    :ensure t
    :init 
    (setq-default custom-enabled-themes '(night-owl))
    :config
    (defun reapply-themes ()
      "Forcibly load the themes listed in `custom-enabled-themes'."
      (dolist (theme custom-enabled-themes)
        (unless (custom-theme-p theme)
          (load-theme theme)))
      (custom-set-variables `(custom-enabled-themes
                              (quote ,custom-enabled-themes))))
    (add-hook 'after-init-hook 'reapply-themes))

#+END_SRC

* Set Defaults

** setq-default

#+begin_src emacs-lisp :tangle tangle-init.el
  (setq-default
   vc-follow-symlinks t
   ;; Save clipboard contents into kill-ring before replacing them
   save-interprogram-paste-before-kill t
   ;; Bookmarks
   bookmark-default-file (concat user-emacs-directory "bookmarks")
   bookmark-save-flag t
   ;; Formatting
   delete-trailing-lines nil
   fill-column 80
   sentence-end-double-space nil
   ;;word-wrap t
   ;; Scrolling
   hscroll-margin 2
   hscroll-step 1
   scroll-conservatively 1001
   scroll-margin 0
   scroll-preserve-screen-position t
   mouse-wheel-scroll-amount '(5 ((shift) . 2))
   mouse-wheel-progressive-speed nil ; don't accelerate scrolling
   ;; Whitespace (see `editorconfig')
   indent-tabs-mode nil
   require-final-newline t
   tab-always-indent t
   tab-width 4
   tabify-regexp "^\t* [ \t]+" ; for :retab
   ;; Wrapping
   truncate-lines t
   truncate-partial-width-windows 50)

  ;;; Extra file extensions to support
  (push '("/LICENSE\\'" . text-mode) auto-mode-alist)

#+end_src

** setq

#+BEGIN_SRC emacs-lisp
  (setq apropos-do-all t
	auth-sources '("~/.authinfo.gpg" "~/.authinfo" "~/.netrc")
	backup-directory-alist `(("." . ,(concat user-emacs-directory
						 "backups")))
	blink-matching-paren nil
	default-frame-alist '((top . 10) (left . 10) (width . 90) (height . 30))
	delete-by-moving-to-trash t
	ediff-window-setup-function 'ediff-setup-windows-plain
	eldoc-idle-delay 1.5
	inhibit-startup-message t
	initial-fram-alist '((top . 10) (left . 10) (width . 90) (height . 30))
	line-move-visual nil
	load-prefer-newer t
       ;; max-mini-window-height 0.50
	message-log-max 2048
	mouse-yank-at-point t
	require-final-newline t
	save-interprogram-paste-before-kill t
	show-paren-delay 0
	show-paren-style 'mixed
	tab-always-indent 'complete
	truncate-lines t
	visible-bell t
	select-enable-clipboard t
	select-enable-primary t
	x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

  (fset 'yes-or-no-p 'y-or-n-p)

#+END_SRC

* Built-in Modules

** uniquify

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package uniquify
    :demand t
    :init (setq uniquify-buffer-name-style 'forward))

#+end_src

** autorevert

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package autorevert
    ;; revert buffers when their files/state have changed
    ;; :hook (focus-in . tx-auto-revert-buffers)
    ;; :hook (after-save . tx-auto-revert-buffers)
    ;; :hook (tx-switch-buffer . tx-auto-revert-buffer)
    ;; :hook (tx-switch-window . tx-auto-revert-buffer)
    :config
    (setq auto-revert-verbose t ; let us know when it happens
      auto-revert-use-notify nil
      auto-revert-stop-on-user-input nil))

    ;; Instead of using `auto-revert-mode' or `global-auto-revert-mode', we employ
    ;; lazy auto reverting on `focus-in-hook' and `tx-switch-buffer-hook'.
    ;;
    ;; This is because autorevert abuses the heck out of inotify handles which can
    ;; grind Emacs to a halt if you do expensive IO (outside of Emacs) on the
    ;; files you have open (like compression). We only really need revert changes
    ;; when we switch to a buffer or when we focus the Emacs frame.
    ;; (defun tx-auto-revert-buffers ()
    ;;   "Auto revert's stale buffers (that are visible)."
    ;;   (unless auto-revert-mode
    ;;     (dolist (buf (tx-visible-buffers))
    ;;       (with-current-buffer buf
    ;;         (auto-revert-handler)))))

    ;; (defun tx-auto-revert-buffer ()
    ;;   "Auto revert current buffer, if necessary."
    ;;   (unless auto-revert-mode
    ;;     (auto-revert-handler))))

#+end_src

** recentf

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package recentf
    ;; Keep track of recently opened files
    :commands recentf-open-files
    :config
    (setq recentf-save-file (concat user-emacs-directory "recentf")
	  recentf-auto-cleanup 'never
	  recentf-max-menu-items 0
	  recentf-max-saved-items 200
	  recentf-exclude
	  (list "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\)$" "^/tmp/" "^/ssh:"
		"\\.?ido\\.last$" "\\.revive$" "/TAGS$" "^/var/folders/.+$"
		;; ignore private DOOM temp files
		(lambda (path)
		  (ignore-errors (file-in-directory-p path tx-local-dir)))))

    (defun tx-recent-file-truename (file)
      (if (or (file-remote-p file nil t)
	      (not (file-remote-p file)))
	  (file-truename file)
	file))
    (setq recentf-filename-handlers '(tx-recent-file-truename abbreviate-file-name))

    (defun tx-recentf-touch-buffer ()
      "Bump file in recent file list when it is switched or written to."
      (when buffer-file-name
	(recentf-add-file buffer-file-name))
      ;; Return nil for `write-file-functions'
      nil)
    (add-hook 'tx-switch-window-hook #'tx-recentf-touch-buffer)
    (add-hook 'write-file-functions #'tx-recentf-touch-buffer)

    (defun tx-recentf-add-dired-directory ()
      "Add dired directory to recentf file list."
      (recentf-add-file default-directory))
    (add-hook 'dired-mode-hook #'tx-recentf-add-dired-directory)

    (unless noninteractive
      (add-hook 'kill-emacs-hook #'recentf-cleanup)
      (quiet! (recentf-mode +1))))

#+end_src

** saveplace

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package saveplace
    ;; persistent point location in buffers
    :config
    (setq save-place-file (expand-file-name ".saveplace" user-emacs-directory)
	  save-place-forget-unreadable-files t
	  save-place-limit 200)
    (defun tx*recenter-on-load-saveplace (&rest _)
	"Recenter on cursor when loading a saved place."
	(if buffer-file-name (ignore-errors (recenter))))
      (advice-add #'save-place-find-file-hook
		  :after-while #'tx*recenter-on-load-saveplace)
      (save-place-mode +1))

#+end_src

** savehist

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package savehist
    ;; persist variables across sessions
    :config
    (setq savehist-file (concat user-emacs-directory "savehist")
	  savehist-save-minibuffer-history t
	  savehist-autosave-interval nil ; save on kill only
	  savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
    (savehist-mode +1)

    (defun tx-unpropertize-kill-ring ()
      "Remove text properties from `kill-ring' in the interest of shrinking the
  savehist file."
      (setq kill-ring (cl-loop for item in kill-ring
			       if (stringp item)
			       collect (substring-no-properties item)
			       else if item collect it)))
    (add-hook 'kill-emacs-hook #'tx-unpropertize-kill-ring))

#+end_src

** paren

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package paren
    :demand t
    :config
    (show-paren-mode 1))

#+end_src

** delset

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package delsel
    :demand
    :config
    (delete-selection-mode))

#+end_src

** global-prettify-symbols-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (when (fboundp 'global-prettify-symbols-mode)
    (global-prettify-symbols-mode))

#+end_src

** Enable some disabled modes

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-defun 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)

  (transient-mark-mode t)

#+END_SRC

** Line Numbers

#+begin_src emacs-lisp :tangle tangle-init.el
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)

#+end_src

** Electric Pair Mode

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (when (fboundp 'electric-pair-mode)
    (electric-pair-mode))

#+END_SRC

** Goto Address

Lets make addresses action buttons when we find them in comments in
programming buffers

#+BEGIN_SRC emacs-lisp :tangle no
  (dolist (hook (if (fboundp 'prog-mode)
                    '(prog-mode-hook ruby-mode-hook)
                  '(find-file-hooks)))
    (add-hook hook 'goto-address-prog-mode))

#+END_SRC

* Editor
** Line Editing Tweaks

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (bind-key "RET" 'newline-and-indent)

  (defun tx/newline-at-end-of-line ()
    "Move to end of line, enter a newline, and reindent."
    (interactive)
    (move-end-of-line 1)
    (newline-and-indent))

  (bind-key "S-RET" 'tx/newline-at-end-of-line)

  (bind-key "C-c j" 'join-line)

  (bind-key "C-c J" (lambda ()
                     (interactive)
                     (join-line 1)))

  (defun kill-back-to-indentation ()
    "Kill from point back to the first non-whitespace character on the line."
    (interactive)
    (let ((prev-pos (point)))
      (back-to-indentation)
      (kill-region (point) prev-pos)))

  (bind-key "<C-M-backspace>" 'kill-back-to-indentation)

  (defun tx/open-line-with-reindent (n)
    "A version of `open-line' which reindents the start and end positions.
        If there is a fill prefix and/or a `left-margin', insert them
        on the new line if the line would have been blank.
        With arg N, insert N newlines."
    (interactive "*p")
    (let* ((do-fill-prefix (and fill-prefix (bolp)))
           (do-left-margin (and (bolp) (> (current-left-margin) 0)))
           (loc (point-marker))
           ;; Don't expand an abbrev before point.
           (abbrev-mode nil))
      (delete-horizontal-space t)
      (newline n)
      (indent-according-to-mode)
      (when (eolp)
        (delete-horizontal-space t))
      (goto-char loc)
      (while (> n 0)
        (cond ((bolp)
               (if do-left-margin (indent-to (current-left-margin)))
               (if do-fill-prefix (insert-and-inherit fill-prefix))))
        (forward-line 1)
        (setq n (1- n)))
      (goto-char loc)
      (end-of-line)
      (indent-according-to-mode)))

  (bind-key "C-o" 'tx/open-line-with-reindent)
#+END_SRC

** Determine Indent

 Need to work out how to implement this correctly

 #+begin_src emacs-lisp :tangle no
   (use-package dtrt-indent
     ;; Automatic detection of indent settings
     :ensure t
     :defer t
     :init
     (defun tx-detect-indentation ()
       (unless (or (not after-init-time)
           tx-inhibit-indent-detection
           (member (substring (buffer-name) 0 1) '(" " "*"))
           (memq major-mode tx-detect-indentation-excluded-modes))
     ;; Don't display messages in the echo area, but still log them
     (let ((inhibit-message (not tx-debug-mode)))
       (dtrt-indent-mode +1))))
     (add-hook 'change-major-mode-after-body-hook #'tx-detect-indentation)
     (add-hook 'read-only-mode-hook #'tx-detect-indentation)
     :config
     (setq dtrt-indent-run-after-smie t)

     ;; always keep tab-width up-to-date
     (push '(t tab-width) dtrt-indent-hook-generic-mapping-list)

     (defvar dtrt-indent-run-after-smie)
     (defun tx-fix-broken-smie-modes (orig-fn arg)
       "Some smie modes throw errors when trying to guess their indentation, like
   `nim-mode'. This prevents them from leaving Emacs in a broken state."
       (let ((dtrt-indent-run-after-smie dtrt-indent-run-after-smie))
     (cl-letf* ((old-smie-config-guess (symbol-function 'smie-config-guess))
            ((symbol-function 'smie-config-guess)
             (lambda ()
               (condition-case e (funcall old-smie-config-guess)
             (error (setq dtrt-indent-run-after-smie t)
                    (message "[WARNING] Indent detection: %s"
                     (error-message-string e))
                    (message "")))))) ; warn silently
       (funcall orig-fn arg))))
     (advice-add #'dtrt-indent-mode :around #'tx-fix-broken-smie-modes))

 #+end_src

** Browse Kill Ring

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package browse-kill-ring
    :ensure t
    :init
    (setq browse-kill-ring-separator "\f")
    :config
    (progn
      (bind-key "C-g" 'browse-kill-ring-quit browse-kill-ring-mode-map)
      (bind-key "M-n" 'browse-kill-ring-forward browse-kill-ring-mode-map)
      (bind-key "M-p" 'browse-kill-ring-previous browse-kill-ring-mode-map)
      (bind-key "M-Y" 'browse-kill-ring)))

#+END_SRC

** Undo Tree

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (use-package undo-tree
     :ensure t
     :diminish undo-tree-mode
     :config
     (setq
      ;; disable because unstable
      undo-tree-auto-save-history nil
      ;; undo-in-region is known to cause undo history
      ;; corruption, which can be very destructive! Disabling
      ;; it deters the error, but does not fix it entirely!
      undo-tree-enable-undo-in-region nil
      undo-tree-history-directory-alist
      `(("." . ,(concat user-emacs-directory "undo-tree-hist/"))))

     (when (executable-find "zstd")
       (defun tx-undo-tree-make-history-save-file-name (file)
	 (concat file ".zst"))
       (advice-add #'undo-tree-make-history-save-file-name :filter-return
		   #'tx-undo-tree-make-history-save-file-name))

     (defun tx-strip-text-properties-from-undo-history (&rest _)
       (dolist (item buffer-undo-list)
	 (and (consp item)
	      (stringp (car item))
	      (setcar item (substring-no-properties (car item))))))

     (advice-add #'undo-list-transfer-to-tree :before #'tx-strip-text-properties-from-undo-history)

     (global-undo-tree-mode))

 #+END_SRC

** WS Butler

 #+begin_src emacs-lisp :tangle tangle-init.el
   (use-package ws-butler
     ;; a less intrusive `delete-trailing-whitespaces' on save
     :ensure t
     :config
     (setq ws-butler-global-exempt-modes
       (append ws-butler-global-exempt-modes
           '(special-mode comint-mode term-mode eshell-mode)))
     (ws-butler-global-mode))

 #+end_src

** Move Or Duplicate Lines

While this seems like a really handy utility, I find I never seem to use it, so
commenting it out for now.

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package move-dup
    :ensure t
    :commands (md/move-lines-up
              md/move-lines-down
              md/duplicate-down
              md/duplicate-up)
    :bind (("M-S-<up>" . md/move-lines-up)
           ("M-S-<down>" . md/move-lines-down)
           ("C-c p" . md/duplicate-down)
           ("C-c P" . md/duplicate-up)))
#+END_SRC

** Whole Line or Region

Allow region oriented commands to work on the current line if no region is
defined.

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package whole-line-or-region
    :ensure t
    :delight
    :config
    (progn
      (whole-line-or-region-mode t)
      ;;(make-variable-buffer-local 'whole-line-or-region-mode)
      ))

#+END_SRC

** Dired

I like to have directories listed first. Easiest way to do this is use the
~ls-lisp~ library

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package diff-hl
    :ensure t
    :config
    (add-hook 'dired-mode-hook 'diff-hl-dir-mode))

  (use-package dired
    :init
    (setq dired-listing-switches "-la --group-directories-first"
          dired-auto-revert-buffer t
          dired-recursive-deletes 'always
          dired-recursive-copies 'always
          dired-dwim-target t)
    :config
    (require 'dired-x))

  (use-package find-dired
    :init
    (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld")))

#+END_SRC


** Exec Path
 Set up the exec path for emacs

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (use-package exec-path-from-shell
     :ensure t
     :init
     (setq exec-path-from-shell-check-startup-files nil)
     :config
     (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID"
                    "GPG_AGENT_INFO" "LANG" "LC_CTYPE"))
       (add-to-list 'exec-path-from-shell-variables var))
     (when (memq window-system '(mac ns x))
       (exec-path-from-shell-initialize)))

 #+END_SRC

** Browse Kill Ring

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (use-package browse-kill-ring
     :ensure t
     :init
     (setq browse-kill-ring-separator "\f")
     :config
     (progn
       (bind-key "C-g" 'browse-kill-ring-quit browse-kill-ring-mode-map)
       (bind-key "M-n" 'browse-kill-ring-forward browse-kill-ring-mode-map)
       (bind-key "M-p" 'browse-kill-ring-previous browse-kill-ring-mode-map)
       (bind-key "M-Y" 'browse-kill-ring)))
 #+END_SRC

** Ido Mode

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (use-package ido
     :demand t
     :init
     (setq ido-enable-flex-matching t
           ido-everywhere t
           ido-use-filename-at-point nil
           ido-auto-merge-work-directories-length 0
           ido-use-virtual-buffers t
           ido-create-new-buffer 'always
           ido-file-extensions-order '(".org" ".txt" ".clj" ".cljs" ".py"
                                       ".emacs" ".xml" ".el" ".cfg" ".cnf")
           ido-default-buffer-method 'selected-window
           ido-enable-dot-prefix t)

     :config
     (ido-mode 1))

   (use-package ido-completing-read+
     :ensure t
     :config
     (ido-ubiquitous-mode t))

 #+END_SRC

** SMEX

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
     (use-package smex
       :ensure t
       :demand t
       :init (setq smex-save-file (expand-file-name ".smex-items" user-emacs-directory))
       :bind (("M-x" . smex)
              ("M-X" . smex-major-mode-commands)
              ("C-c C-c M-x" . execute-extended-command))
       :config (smex-initialize))

 #+END_SRC

** IBuffer
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :commands 'ibuffer
    :config
    (progn 
      (define-ibuffer-column size-h
        (:name "Size" :inline t)
        (cond
         ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
         ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
         (t (format "%8d" (buffer-size)))))

      (use-package ibuffer-vc
        :ensure t
        :init
        (setq ibuffer-filter-group-name-face 'font-lock-doc-face
              ibuffer-formats '((mark modified read-only vc-status-mini " "
                                      (name 18 18 :left :elide)
                                      " "
                                      (size-h 9 -1 :right)
                                      " "
                                      (mode 16 16 :left :elide)
                                      " "
                                      filename-and-process)
                                (mark modified read-only vc-status-mini " "
                                      (name 18 18 :left :elide)
                                      " "
                                      (size-h 9 -1 :right)
                                      " "
                                      (mode 16 16 :left :elide)
                                      " "
                                      (vc-status 16 16 :left)
                                      " "
                                      filename-and-process)))
        :config
        (defun ibuffer-set-up-preferred-filters ()
          (ibuffer-vc-set-filter-groups-by-vc-root)
          (unless (eq ibuffer-sorting-mode 'filename/process)
            (ibuffer-do-sort-by-filename/process)))
        (add-hook 'ibuffer-hook 'ibuffer-set-up-preferred-filters))
      (bind-key "C-x C-b" 'ibuffer)))
#+END_SRC

* Programming Support
** Rainbow Mode

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (use-package rainbow-mode
     :ensure t
     :delight
     :config
     (add-hook 'prog-mode-hook 'rainbow-mode)
     (add-hook 'ielm-mode-hook 'rainbow-mode)
     (add-hook 'lisp-interaction-mode-hook 'rainbow-mode)
     (add-hook 'emacs-lisp-mode-hook 'rainbow-mode))

 #+END_SRC

** Rainbow Delimiters

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (use-package rainbow-delimiters
     :ensure t
     :delight
     :config
     (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
     (add-hook 'ielm-mode-hook 'rainbow-delimiters-mode)
     (add-hook 'lisp-interaction-mode-hook 'rainbow-delimiters-mode)
     (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))

 #+END_SRC

** Paredit
This mode was a little tricky at first, but now I'm use to it, I miss it when
it isn't there.

There are some issues with using this mode in conjunction with emacspeak. Need
to add some paredit specific advice to provide speech feedback for this mode.

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package paredit
    :ensure t
    :diminish paredit-mode
    :init
    (progn
      (defun maybe-map-paredit-newline ()
        (unless (or (memq major-mode '(inferior-emacs-lisp-mode
                                       cider-repl-mode))
                    (minibufferp))
          (local-set-key (kbd "RET") 'paredit-newline)))
      (add-hook 'paredit-mode-hook 'maybe-map-paredit-newline))
    :config
    (progn
      (defvar paredit-minibuffer-commands '(eval-expression
                                            pp-eval-expression
                                            eval-expression-with-eldoc
                                            ibuffer-do-eval
                                            ibuffer-do-view-and-eval)
        "Interactive commands where paredit should be enabled in minibuffer.")
      (defun conditionally-enable-paredit-mode ()
        "Enable paredit during lisp-related minibuffer commands."
        (if (memq this-command paredit-minibuffer-commands)
            (enable-paredit-mode)))
      (add-hook 'minibuffer-setup-hook 'conditionally-enable-paredit-mode)
      (dolist (binding (list (kbd "C-<left>") (kbd "C-<right>")
                             (kbd "C-M-<left>") (kbd "C-M-<right>")))
        (define-key paredit-mode-map binding nil))

      ;; Modify kill-sentence, which is easily confused with the kill-sexp
      ;; binding, but doesn't preserve sexp structure
      (bind-key [remap kill-sentence] 'paredit-kill paredit-mode-map)
      (bind-key [remap backward-kill-sentence] nil paredit-mode-map)
      (add-hook 'lisp-mode-hook #'enable-paredit-mode)
      (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
      (add-hook 'clojure-mode-hook #'enable-paredit-mode)
      (add-hook 'cider-repl-mode-hook #'enable-paredit-mode)
      (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
      (add-hook 'ielm-mode-hook #'enable-paredit-mode)))

  (use-package paredit-everywhere
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'paredit-everywhere-mode))
#+END_SRC

** Smartparens
Not sure I like this mode compared to paredit. Disabling it for now.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package smartparens-config
    :ensure smartparens
    :config
    (progn
      (sp-use-smartparens-bindings)
      (smartparens-global-mode)
      (show-smartparens-global-mode))
    (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
    (add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode))

#+END_SRC

** flycheck

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package flycheck
    :ensure t
    :config
    (setq-default flycheck-disabled-checkers
                  (append flycheck-disabled-checkers
                          '(javascript-jshint)))

    (setq flycheck-display-errors-function
          #'flycheck-display-error-messages-unless-error-list)
    (global-flycheck-mode))

  (use-package flycheck-color-mode-line
    :ensure t
    :config
    (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode))

#+END_SRC

** Highlight Symbol Mode

Highlight symbols and enable navigation by symbol in programming modes. See
[[http://nschum.de/src/emacs/highlight-symbol/]].

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package highlight-symbol
    :ensure t
    :diminish highlight-symbol-mode
    :config
    (progn
      (dolist (hook '(prog-mode-hook html-mode-hook css-mode-hook))
        (add-hook hook 'highlight-symbol-mode)
        (add-hook hook 'highlight-symbol-nav-mode))
      (defadvice highlight-symbol-temp-highlight (around sanityinc/maybe-suppress
                                                         activate)
        "Suppress symbol highlighting while isearching."
        (unless (or isearch-mode
                    (and (boundp 'multiple-cursors-mode)
                         multiple-cursors-mode))
          ad-do-it))))

#+END_SRC

** Imenu

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package imenu-anywhere
    :ensure t)

#+END_SRC

** Version Control

Setup version control stuff

*** Git Commit

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package git-commit
    :ensure t)
    :config
    (global-git-commit-mode)

#+end_src

*** Git Timemachine

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package git-timemachine
    :ensure t
    :commands (git-timemachine-toggle git-timemachine
               git-timemachine-switch-browser))
#+END_SRC

*** Gitignore

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package gitignore-mode
    :ensure t)

#+end_src

*** Magit

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package magit
    :ensure t
    :commands (magit-status magit-dispatch-popup)
    :bind (("C-x g" . magit-status)
           ("C-x M-g" . magit-dispatch-popup)))

#+end_src

*** Magit Popup

#+begin_src emacs-lisp :tangle no
  (use-package magit-popup
    :ensure t)

#+end_src

*** Diff-hl

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package diff-hl
    :ensure t
    :config
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
    (add-hook 'after-init-hook 'global-diff-hl-mode))

#+end_src

** Projectile

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (use-package projectile
     :ensure t
     :delight '(:eval (concat " " (projectile-project-name)))
     ;;:diminish projectile-mode
     ;; :commands (projectile-mode
     ;;            projectile-mode)
     :bind (:map projectile-mode-map ("C-c p" . projectile-command-map))
     :init
     ;; (add-hook 'prog-mode-hook 'projectile-mode)
     (projectile-mode +1))

 #+END_SRC

* Prog Modes

** Emacs Lisp
Configure lisp modes.

*** Add the ~elisp-slime-nave~ package to get some nice nav functions.

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package elisp-slime-nav
    :ensure t
    ;; :diminish elisp-slime-nav-mode
    :config
    (dolist (hook '(emacs-lisp-mode-hook
                    ielm-mode-hook
                    lisp-mode-hook
                    clojure-mode-hook))
           (add-hook hook 'turn-on-elisp-slime-nav-mode)))

#+END_SRC

*** Use ~ipretty~ to improve display of eval results

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package ipretty
    :ensure t
    :init
    (defadvice pp-display-expression (after tx/make-read-only (expression out-buffer-name) activate)
      "Enable `view-mode' in the output buffer - if any - so it can be closed with `\"q\"."
      (when (get-buffer out-buffer-name)
        (with-current-buffer out-buffer-name
          (view-mode 1))))
    :config
    (add-hook 'emacs-lisp-mode-hook 'ipretty-mode))

#+END_SRC

*** Setup Emacs Lisp

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (defun setup-hippie-expand-for-elisp ()
    "Locally set `hippie-expand' completion functions for use with Emacs Lisp."
    (make-local-variable 'hippie-expand-try-functions-list)
    (add-to-list 'hippie-expand-try-functions-list
                 'try-complete-lisp-symbol t)
    (add-to-list 'hippie-expand-try-functions-list
                 'try-complete-lisp-symbol-partially t))

  (defun tx/eval-last-sexp-or-region (prefix)
    "Eval region from BEG to END if active, otherwise the last sexp."
    (interactive "P")
    (if (and (mark) (use-region-p))
        (eval-region (min (point) (mark)) (max (point) (mark)))
      (pp-eval-last-sexp prefix)))

  (add-hook 'emacs-lisp-mode-hook 'setup-hippie-expand-for-elisp)
  (add-hook 'emacs-lisp-mode-hook (lambda () (setq mode-name "ELisp")))

  (bind-key "M-:" 'pp-eval-expression)
  (bind-key "C-x C-e" 'tx/eval-last-sexp-or-region emacs-lisp-mode-map)

#+END_SRC

** Auctex
  Use the ~auctex~ package for writing LaTeX.

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (use-package tex
     :ensure auctex)

 #+END_SRC

** Lua

No time for any Lua programming just now, so commenting out configuration as it
is not required at this time.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lua-mode
    :ensure t
    :commands (lua-mode)
    :mode "\\.lua\\'"
    :interpreter "lua")

#+END_SRC

** Clojure

Setup ~clojure-mode~ and ~cider~.

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  ;; (use-package clojure-cheatsheet
  ;;   :ensure t
  ;;   :commands clojure-cheatsheet)

  (use-package clojure-snippets
    :ensure t)

  (use-package cider-hydra
    :ensure t
    :commands cider-hydra-mode)

  (use-package clojure-mode
    :ensure t
    :init
    (setq clojure-align-forms-automatically t)
    :config
    (add-hook 'clojure-mode-hook #'subword-mode)
    (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode))

  (use-package flycheck-joker
     :ensure t)

  (use-package cider
    :ensure t
    :commands (cider-mode cider-connect cider-jack-in cider-jack-in-clojurescript)
    :init
    (setq
     ;; cider-prompt-for-symbol nil
     ;; cider-font-lock-dynamically '(macro core function var)
     cider-eldoc-display-for-symbol-at-point nil
     eldoc-echo-area-use-multiline-p t
     cider-overlays-use-font-lock t
     cider-use-overlays t
     cider-show-error-buffer nil
     cider-repl-display-help-banner nil
     cider-repl-history-file (expand-file-name "repl-history"))
    :config
    (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'cider-mode-hook #'cider-hydra-mode))

  (use-package clj-refactor
    :ensure t
    :commands clj-refactor-mode
    :init
    (setq cljr-warn-on-eval nil)
    :config
    (add-hook 'clojure-mode-hook (lambda ()
                                   (clj-refactor-mode 1)
                                   ;; insert keybinding setup here
                                   (cljr-add-keybindings-with-prefix "C-c C-m"))))


  ;; (use-package inf-clojure
  ;;   :ensure t
  ;;   :commands (inf-clojure inf-clojure-minor-mode inf-clojure-connect))

#+END_SRC

** SQL

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  ;; (use-package sql-indent
  ;;   :ensure t
  ;;   :config
  ;;   (eval-after-load 'sql
  ;;     (load-library "sql-indent")))


  (use-package sqlup-mode
    :ensure t
    :config
    (add-hook 'sql-mode-hook 'sqlup-mode)
    (add-hook 'sql-interactive-mode-hook 'sqlup-mode))

  (use-package sql
    :init
    (progn
      (setq-default sql-input-ring-file-name
                    (expand-file-name ".sqli_history" user-emacs-directory))
      (setq sql-product 'postgres
            sql-connection-alist '(("playground"
                                    (sql-product 'postgres)
                                    (sql-server "localhost")
                                    (sql-database "playground")
                                    (sql-port 5432))
                                   ("wdp-dev"
                                    (sql-product 'postgres)
                                    (sql-server "localhost")
                                    (sql-database "wdp")
                                    (sql-port 3330))
                                   ("wdp-prod"
                                    (sql-product 'postgres)
                                    (sql-server "localhost")
                                    (sql-database "wdp")
                                    (sql-port 3331))))
      (defun tx/pop-to-sqli-buffer ()
        "Switch to the corresponding sqli buffer."
        (interactive)
        (if sql-buffer
            (progn
              (pop-to-buffer sql-buffer)
              (goto-char (point-max)))
          (sql-set-sqli-buffer)
          (when sql-buffer
            (tx/pop-to-sqli-buffer)))))
    :config
    (bind-key "C-c C-z" 'tx/pop-to-sqli-buffer sql-mode-map))

#+END_SRC

** Web

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package web-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.jsp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.xhtml?\\'" . web-mode))

    (defun my-web-mode-hook ()
      "Hooks for Web mode."
      (setq web-mode-enable-auto-closing t
            web-mode-enable-auto-quoting t
            web-mode-markup-indent-offset 2))

    (add-hook 'web-mode-hook  'my-web-mode-hook))

  (use-package less-css-mode
    :ensure t)

  (use-package emmet-mode
    :ensure t)

#+END_SRC

** JavaScript

*** js2-mode

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package js2-mode
    :ensure t
    :delight
    :mode "\\.js\\'"
    :interpreter ("node" . js2-mode)
    :init
    (flycheck-add-mode 'javascript-eslint 'js2-mode)
    (setq-default js2-bounce-indent-p nil)
    (setq js-indent-level 2
          js2-include-node-externs t
          js2-mode-assume-strict t
          js2-highlight-level 3
          js2-global-externs '("describe" "it" "before"
                               "after" "beforeEach" "afterEach"))
    :config
    (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
    (js2-imenu-extras-setup)
    (define-key js2-mode-map (kbd "M-.") nil))

#+END_SRC

*** xref-js2

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package xref-js2
    :ensure t
    :delight
    :config
    (add-hook 'js2-mode-hook
              (lambda ()
                (add-hook 'xref-backend-functions
                          #'xref-js2-xref-backend nil t))))

#+end_src

*** js2-refactor

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package js2-refactor
    :ensure t
    :config
    (add-hook 'js2-mode-hook #'js2-refactor-mode)
    (js2r-add-keybindings-with-prefix "C-c C-r")
    (define-key js2-mode-map (kbd "C-k") #'js2r-kill))

#+end_src

*** tern

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package tern
    :ensure t
    :delight
    :config
    (add-hook 'js2-mode-hook #'tern-mode))

#+end_src

*** company-tern

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package company-tern
    :ensure t
    :config
    (add-to-list 'company-backends 'company-tern)
    (add-hook 'js2-mode-hook (lambda ()
                               (tern-mode)
                               (company-mode)))

    ;; Disable completion keybindings, as we use xref-js2 instead
    (define-key tern-mode-keymap (kbd "M-.") nil)
    (define-key tern-mode-keymap (kbd "M-,") nil))

#+end_src

*** Indium

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package indium
    :ensure t
    :delight
    ('indium-interaction-mode "JSI")
    :config
    (add-hook 'js2-mode-hook #'indium-interaction-mode))

#+end_src

*** prettier-js

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package prettier-js
    :ensure t
    :init
    (setq prettier-js-args '("--print-width" "80"
                             "--tab-width" "2"
                             "--no-bracket-spacing")
          prettier-js-width-mode 'fill)
    :config
    (add-hook 'js2-mode-hook #'prettier-js-mode))

#+end_src

*** json-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package json-mode
    :ensure t)

#+end_src

*** ng2-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package ng2-mode
    :ensure t)

#+end_src

*** js-doc

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package js-doc
    :ensure t
    :init
    (setq js-doc-mail-address "tcross8@une.edu.au"
          js-doc-author (format "Tim Cross <%s>" js-doc-mail-address))
    :config
    (add-hook 'js2-mode-hook
              (lambda ()
                (define-key js2-mode-map "\C-ci" 'js-doc-insert-function-doc)
                (define-key js2-mode-map "@" 'js-doc-insert-tag))))

#+end_src

*** tide

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package tide
    :ensure t)

#+end_src

** Powershell

Have been blessed with no need to do powershell scripting at this time, so
disabling this support for now.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package powershell
    :ensure t)

#+END_SRC

** Python

No time to continue with learning Python programming at this time, so disabling
this support for now.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package jedi
    :ensure t
    :mode ("\\.py\\'" . python-mode)
    :init
    (setq jedi:complete-on-dot t)
    :config
    (add-hook 'python-mode-hook 'jedi:setup))

  (use-package company-jedi
    :ensure t)

  (use-package importmagic
    :ensure t)

  (use-package elpy
    :ensure t
    :init
    (setq elpy-rpc-backend "jedi")
    :config
    (elpy-enable))

#+END_SRC

** Scheme

No need for scheme support at this time. Disabling for now.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package geiser
    :ensure t)

#+END_SRC

** CL

Moved back to Gnome from Stumpwn for now. Until time permits for full stumpwm
setup, comment out for now.

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (when (not *is-a-mac*)
    (use-package slime
      :ensure t
      :init
      (setq slime-contribs '(slime-fancy)
            slime-complete-symbol-function 'slime-fuzzy-complete-symbol
            slime-net-coding-system 'utf-8-unix
            slime-lisp-implementations '((sbcl ("/usr/local/bin/sbcl" "--noinform")))
            slime-default-lisp 'sbcl)
      :config
      (setq common-lisp-hyperspec-root "/usr/share/doc/hyperspec/"
            common-lisp-hyperspec-symbols-table
            (concat common-lisp-hyperspec-root "Data/Map_Sym.txt")
            common-lisp-hyperspec-issuex-table
            (concat common-lisp-hyperspec-root "Data/Map_IssX.txt"))
      (when (file-exists-p (expand-file-name "~/quicklisp/slime-helper.el"))
        (load (expand-file-name "~/quicklisp/slime-helper.el")))
      (add-to-list 'Info-additional-directory-list
                   (expand-file-name "~/git/stumpwm")))
    (use-package slime-company
      :ensure t
      :config
      (slime-setup '(slime-company))))

#+END_SRC

** Elm

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package elm-mode
    :ensure t
    :config
    (setq elm-tags-on-save t
          elm-sort-imports-on-save t
          elm-format-on-save t))

#+END_SRC

* Org Mode
Start by getting required package. I'm using the org-plus-contrib package from
the org repository.

*Note*: Occasionally, you may run into problems when installing org from a
repository. Essentially the problem can occur if you have some of the bundled
org files loaded when you try to install a repo version. The easiest way to fix
this is to reload org mode using the command

  : C-u M-x org-reload

Then remove the repo package version and re-install. This will
normally ensure a 'stable' environment.

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package org
    :pin org
    :ensure org-plus-contrib 
    :init
    (setq org-agenda-show-outline-path nil
          org-catch-invisible-edits 'smart
          org-ctrl-k-protect-subtree t
          org-default-notes-file "~/Dropbox/org/notes.org"
          org-directory "~/Dropbox/org"
          org-ellipsis ""
          org-list-allow-alphabetical t
          org-list-indent-offset 2
          org-pretty-entities t
          org-startup-align-all-tables t
          org-startup-with-inline-images (display-graphic-p)
          org-support-shift-select t
          org-use-sub-superscripts (quote {}))
    (setq org-modules '(org-bibtex
                        org-crypt
                        org-docview
                        org-eww
                        org-info
                        org-irc
                        org-protocol))
    (setq org-capture-templates
          (quote
           (("t" "todo" entry
             (file "~/Dropbox/org/refile.org")
             "* TODO %?\n\n  %a"
             :empty-lines-after 1 :clock-in t :clock-resume t)
            ("r" "respond" entry
             (file "~/Dropbox/org/refile.org")
             "* NEXT Respond to %:from on %:subject\n  SCHEDULED: %t\n  %a"
             :empty-lines-after 1 :clock-in t :clock-resume t)
            ("n" "note" entry
             (file "~/Dropbox/org/notes.org")
             "* %? :NOTE:\n\n  %a"
             :empty-lines-after 1 :clock-in t :clock-resume t)
            ("j" "journal" entry
             (file+olp+datetree "~/Dropbox/org/journal.org")
             "* %?\n  "
             :empty-lines-after 1 :clock-in t :clock-resume t)
            ("p" "phone" entry
             (file "~/Dropbox/org/refile.org")
             "* PHONE %? :PHONE:\n  "
             :empty-lines-after 1 :clock-in t :clock-resume t)
            ("m" "mail" entry
             (file "~/Dropbox/org/refile.org")
             "* MAIL from %:from on %:subject\n\n  %a"
             :empty-lines-after 1 :clock-in t :clock-resume t))))
    (setq org-enforce-todo-checkbox-dependencies t
          org-enforce-todo-dependencies t
          org-log-done 'time
          org-log-into-drawer t)
    (setq org-todo-keywords
          (quote
           ((sequence "TODO(t)"
                      "NEXT(n)"
                      "STARTED(s!)"
                      "DELEGATED(w@/!)"
                      "HOLD(h@/!)"
                      "|"
                      "CANCELLED(c@)"
                      "DONE(d!)"))))
    (setq org-log-refile 'time
          org-refile-allow-creating-parent-nodes 'confirm
          org-refile-targets (quote ((nil :maxlevel . 5)
                                     (org-agenda-files :maxlevel . 5)))
          org-refile-use-outline-path (quote file))
    (setq org-clock-in-resume t
          org-clock-out-remove-zero-time-clocks t
          org-clock-persist 'clock
          org-time-clocksum-format '(:hours "%d" :require-hours t
                                            :minutes ":%02d" :require-minutes t))
    (setq org-agenda-files '("~/Dropbox/org")
          org-agenda-remove-tags t)
	  
    (setq org-agenda-custom-commands
          (quote
           (("n" "Agenda and all TODO's"
             ((agenda "" nil)
              (alltodo "" nil))
             nil)
            ("wr" "Weekly Report"
             ((todo "DONE|CANCELLED"
                    ((org-agenda-overriding-header "Completed and Cancelled : Last Week")))
              (todo "STARTED|NEXT"
                    ((org-agenda-overriding-header "WIP")))
              (todo "HOLD|DELEGATED"
                    ((org-agenda-overriding-header "On Hold and Delegated Tasks")))
              (todo "TODO"
                    ((org-agenda-overriding-header "Task Backlog"))))
             nil nil))))
    (setq org-src-tab-acts-natively t
          org-hide-block-startup t
          org-src-window-setup 'current-window)
    (setq org-confirm-babel-evaluate nil)
    (setq org-babel-clojure-backend 'cider
          org-babel-clojure-sync-nrepl-timeout 0)
    (setq org-plantuml-jar-path (expand-file-name "~/.emacs.d/jars/plantuml.jar")
          org-ditaa-jar-path (expand-file-name "~/.emacs.d/jars/ditaa.jar")
          org-ditaa-eps-jar-path (expand-file-name "~/.emacs.d/jars/DitaaEps.jar"))
    (setq org-export-backends '(ascii beamer html
                                      latex texinfo
                                      md odt org)
          org-export-coding-system 'utf-8)
    (setq org-latex-classes
          '(("beamer"
             "\\documentclass[presentation]{beamer}"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
            ("hitec-article"
             "\\documentclass[12pt]{hitec}
    [DEFAULT-PACKAGES]
    [PACKAGES]
    [NO-EXTRA]
    \\settextfraction{0.95}\n"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
            ("article" "\\documentclass[11pt]{article}"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
            ("korma-article" "\\documentclass[11pt]{scrartcl}"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
            ("report"
             "\\documentclass[11pt]{report}"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
            ("korma-report"
             "\\documentclass[11pt]{scrreport}"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
            ("korma-book"
             "\\documentclass[11pt]{scrbook}"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
            ("book"
             "\\documentclass[11pt]{book}"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
    (setq org-latex-hyperref-template
          "\\hypersetup{pdfauthor={%a},
                        pdftitle={%t},
                        pdfkeywords={%k},
                        pdfsubject={%d},
                        pdfcreator={%c},
                        pdflang={%L},
                        colorlinks=true,
                        linkcolor=blue}")
    (setq org-latex-listings t
          org-latex-listings-options '(("basicstyle" "\\tiny")
                                       ("frame" "single")
                                       ("stringstyle" "\\color{orange}")
                                       ("commentstyle" "\\color{cyan}")
                                       ("keywordstyle" "\\color{blue}")
                                       ("showstringspaces" "false")
                                       ("breakatwhitespace" "false")
                                       ("breaklines" "true")))
    (setq org-latex-pdf-process
          '("lualatex -interaction nonstopmode -output-directory %o %f"
            "lualatex -interaction nonstopmode -output-directory %o %f"
            "lualatex -interaction nonstopmode -output-directory %o %f"))
    (setq org-latex-packages-alist
          '(("" "parskip")
            ("" "xcolor")
            ("" "listings")))
    (setq org-html-checkbox-type 'unicode
          org-html-html5-fancy t
          org-html-doctype "html5")
    (setq org-ascii-charset 'utf-8
          org-ascii-text-width 79)
    :config
    (org-element-update-syntax)
    (org-clock-persistence-insinuate)

    ;; (add-to-list 'org-structure-template-alist
    ;;              '("p" "#+BEGIN_SRC python\n?\n#+END_SRC"
    ;;                "<src lang=\"python\">\n?\n</src>"))

    ;; (add-to-list 'org-structure-template-alist
    ;;              '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"
    ;;                "<src lang=\"emacs-lisp\">\n?\n</src>"))

    ;; (add-to-list 'org-structure-template-alist
    ;;              '("clj" "#+BEGIN_SRC clojure-mode\n?\n#+END_SRC"
    ;;                "<src lang=\"clojure-mode\">\n?\n</src>"))
    ;; (add-to-list 'org-structure-template-alist
    ;;              '("cl" "#+BEGIN_SRC lisp\n?\n#+END_SRC"
    ;;                "<src lang=\"lisp-mode\">\n?\n</src>"))
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (clojure . t)
       (css . t)
       (dot . t)
       (java . t)
       (js . t)
       (latex . t)
       (ledger . t)
       (lisp . t)
       (makefile . t)
       (org . t)
       (perl . t)
       (python . t)
       (ruby . t)
       (scheme . t)
       (shell . t)
       (sql . t)
       (C . t)
       (ditaa . t)
       (plantuml . t)
       (gnuplot . t)))
    (bind-key "C-c l" 'org-store-link)
    (bind-key "C-c a" 'org-agenda)
    (bind-key "C-c b" 'org-switchb)
    (bind-key "C-c r" 'org-capture))

#+END_SRC

* Utility Modes
** Alert

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package alert
    :ensure t)

#+end_src

** Spelling
When running on OSX it is necessary to

  - Install a spell checker. I prefer to use /homebrew/ to install both emacs and
    associated programs i.e
    : brew install hunspell

  - Note that you also need to install the dictionaries. I use the dictionaries from
    openOffice. These are distributed in /*.oxt/ files, which are just /zip/
    archives. Unzip them and put the /*.aff/ and /*.dic/ files in
    /~/Library/Spelling/ directory.

  - I also setup symbolic links from the dictionaries I want to /default.aff/
    and /default.dic/

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
    (when *spell-check-support-enabled*
      (use-package ispell
        :init
        ;;; Spell checking using hunspell
        (setq ispell-local-dictionary-alist
              '((nil "[A-Za-z]" "[^A-Za-z]" "[']" t
                     ("-d" "en_US" "-i" "utf-8") nil utf-8)
                ("american"
                 "[A-Za-z]" "[^A-Za-z]" "[']" nil
                 ("-d" "en_US") nil utf-8)
                ("english"
                 "[A-Za-z]" "[^A-Za-z]" "[']" nil
                 ("-d" "en_GB") nil utf-8)
                ("en_GB"
                 "[A-Za-z]" "[^A-Za-z]" "[']" nil
                 ("-d" "en_GB") nil utf-8)
                ("en_AU"
                 "[A-Za-z]" "[^A-Za-z]" "[']" nil
                 ("-d" "en_AU") nil utf-8))
              ispell-extra-args '("-a" "-i" "utf-8")
              ispell-silently-savep t)
        (if *is-a-mac*
            (progn
              (setenv "DICPATH" (concat (getenv "HOME") "/Library/Spelling"))
              (setq ispell-dictionary "en_AU"
                    ispell-program-name "/usr/local/bin/hunspell"))
          ;;(setq ispell-dictionary "british-ise")
          (setq ispell-program-name "/usr/bin/hunspell"
                ispell-dictionary "en_AU"))
        :config
        (add-to-list 'ispell-skip-region-alist '("^#\\+begin_src ". "#\\+end_src$"))
        (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC ". "#\\+END_SRC$"))
        (add-to-list 'ispell-skip-region-alist '("^#\\+begin_example ". "#\\+end_example$"))
        (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_EXAMPLE ". "#\\+END_EXAMPLE$"))
        (add-to-list 'ispell-skip-region-alist '("\:PROPERTIES\:$" . "\:END\:$"))
        (add-to-list 'ispell-skip-region-alist '("\\[fn:.+:" . "\\]"))
        (add-to-list 'ispell-skip-region-alist '("^http" . "\\]"))
        (add-to-list 'ispell-skip-region-alist '("=.*" . ".*="))
        (add-to-list 'ispell-skip-region-alist '("- \\*.+" . ".*\\*: "))
        (when (executable-find ispell-program-name)
          (use-package flyspell
            :diminish flyspell-mode
            :init
            (setq flyspell-use-meta-tab nil)
            (defun try-flyspell (arg)
              (if (nth 4 (syntax-ppss))
                  (call-interactively 'flyspell-correct-word-before-point)
                nil))
            :config
            (add-hook 'prog-mode-hook 'flyspell-prog-mode)
            (add-hook 'text-mode-hook 'flyspell-mode)))))

#+END_SRC

** Timestamps

Surprises me how often people ask for this functionality without realizing it is
already built-in.

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package time-stamp
     :init
     (setq time-stamp-active t
           time-stamp-format "%:a, %02d %:b %:y %02I:%02M %#P %Z"
           time-stamp-start "\\(Time-stamp:[         ]+\\\\?[\"<]+\\|Last Modified:[
              ]\\)"
           time-stamp-end "\\\\?[\">]\\|$"
           time-stamp-line-limit 10)
     :config
     (add-hook 'write-file-hooks 'time-stamp))

#+END_SRC

** Regex Tool

Add the handy ~regex-tool~ package

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package regex-tool
    :ensure t
    :commands (regex-tool))

#+END_SRC

** Crontab

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package crontab-mode
    :mode ("\\.?cron\\(tab\\)?\\'" . crontab-mode))

#+END_SRC

** CSV

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package csv-mode
    :ensure t
    :init
    (setq csv-separators '("," ";" "|" " "))
    :config
    :mode ("\\.[Cc][Ss][Vv]\\'" . csv-mode))

#+END_SRC

** Grep and Wgrep
The ~wgrep~ package allows for writing of grep buffers back to file. See [[http://github.com/mhayashi1120/Emacs-wgrep][wgrep
on GitHub]]

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package grep
    :init
    (setq-default grep-highlight-matches t
                 grep-scroll-output t)
    (when *is-a-mac*
      (setq-default locate-command "mdfind"))
    :config
    (progn
        (use-package wgrep
          :ensure t)
        (add-hook 'grep-setup-hook 'wgrep-setup)))

#+END_SRC

** REST Client

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package restclient
    :ensure t)

#+END_SRC

** Alert

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package alert
    :ensure t
    :config
    (setq alert-fade-time 10)
    (when *is-a-mac*
      (setq alert-default-style 'growl))
    (setq alert-reveal-idle-time 120))

#+END_SRC

** Write Good

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package writegood-mode
    :ensure t
    :bind ("C-M-g" . writegood-mode))

#+END_SRC

** Lorem Ipsum

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package lorem-ipsum
    :ensure t
    :commands (lorem-ipsum-insert-paragraph
               lorem-ipsum-insert-sentence
               lorem-ipsum-insert-list))

#+END_SRC

** Htmlize

Add the ~htmlize~ package to provide an easy way to turn buffer contents into
HTML. See [[http://fly.srk.fer.hr/~hniksic/emacs/htmlize.git]].

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package htmlize
    :ensure t
    :commands (htmlize-buffer htmlize-region htmlize-file
                              htmlize-many-files htmlize-many-files-dired))
#+END_SRC

** Browse-url

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package browse-url
    :commands (browse-url-at-point
               browse-url-of-buffer
               browse-url-of-region
               browse-url
               browse-url-of-file)
    :init
    ;; (if *is-a-mac*
    ;;     (setq browse-url-browser-function 'browse-url-default-macosx-browser)
    ;;   (setq browse-url-browser-function 'eww-browse-url))
    (setq browse-url-browser-function 'eww-browse-url)
    (defhydra my-hydra-browse-url ()
      "Browse URL"
      ("." browse-url-at-point "at point")
      ("b" browse-url-of-buffer "buffer")
      ("r" browse-url-of-region "region")
      ("u" browse-url "URL")
      ("f" browse-url-of-file "File")
      ("d" emacspeak-wizards-unhex-uri "Decode")
      ("q" nil "Quit"))
    :bind ("<f6>" . my-hydra-browse-url/body))

#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package markdown-mode
    :ensure t
    :defer t
    :commands (markdown-mode gfm-mode)
    :mode (("\\.markdown\\'" . markdown-mode)
           ("\\.md\\'" . markdown-mode)))


  (use-package gh-md
    :ensure t
    :commands (gh-md-render-buffer gh-md-render-region))

  (use-package markdown-preview-eww
    :ensure t
    :commands (markdown-peview-eww))

  (use-package markdown-toc
    :ensure t
    :commands (markdown-toc-generate-toc))

#+END_SRC

* Application Modes
Modes relating to emacs applications

** Calendar
Configure the calendar

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package calendar
    :init
    (setq calendar-date-style 'iso
          calendar-location-name "Armidale"
          calendar-longitude 151.617222
          calendar-mark-diary-entries-flag t
          calendar-mark-holidays-flag t
          calendar-time-zone 600
          calendar-view-holidays-initially-flag t
          icalendar-import-format "%s%l"
          icalendar-import-format-location " (%s)"
          icalendar-recurring-start-year 2013))

#+END_SRC

** Stack Exchange
When I'm a bit bored or want a break from my own problems, I sometimes like to
look at stack overflow. See [[https://github.com/vermiculus/sx.el/][sx on GitHub]].

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package sx
    :ensure t
    :commands (sx-bug-report sx-authenticate sx-inbox sx-inbox-notifications
                             sx-org-get-link sx-ask sx-search
                             sx-search-tag-at-point sx-tab-all-questions
                             sx-tab-unanswered sx-tab-unanswered-my-tags
                             sx-tab-featured sx-tab-starred
                             sx-tab-frontpage sx-tab-newest
                             sx-tab-topvoted sx-tab-hot
                             sx-tab-week sx-tab-month))

#+END_SRC

** ERC

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package erc
    :commands 'erc
    :preface
    (defun tx/erc-browse-last-url ()
      "Searchs backwards through an ERC buffer, looking for a URL. When a URL is
       found, it prompts you to open it."
      (interactive)
      (save-excursion
        (let ((ffap-url-regexp "\\(https?://\\)."))
          (ffap-next-url t t))))

    (defun tx/erc-count-users ()
      "Displays the number of users and ops connected on the current channel."
      (interactive)
      (if (get-buffer "irc.freenode.net:6667")
          (let ((channel (erc-default-target)))
            (if (and channel (erc-channel-p channel))
                (let ((hash-table (with-current-buffer (erc-server-buffer)
                                    erc-server-users))
                      (users 0)
                      (ops 0))
                  (maphash (lambda (k v)
                             (when (member (current-buffer)
                                           (erc-server-user-buffers v))
                               (incf users))
                             (when (erc-channel-user-op-p k)
                               (incf ops)))
                           hash-table)
                  (message "%d users (%s ops) are online on %s" users ops channel))
              (user-error "The current buffer is not a channel")))
        (user-error "You must first be connected on IRC")))

    (defun tx/erc-get-ops ()
      "Displays the names of ops users on the current channel."
      (interactive)
      (if (get-buffer "irc.freenode.net:6667")
          (let ((channel (erc-default-target)))
            (if (and channel (erc-channel-p channel))
                (let (ops)
                  (maphash (lambda (nick cdata)
                             (if (and (cdr cdata)
                                      (erc-channel-user-op (cdr cdata)))
                                 (setq ops (cons nick ops))))
                           erc-channel-users)
                  (if ops
                      (message "The online ops users are: %s"  (mapconcat 'identity ops " "))
                    (message "There are no ops users online on %s" channel)))
              (user-error "The current buffer is not a channel")))
        (user-error "You must first be connected on IRC")))

    (defun tx/erc-notify (nickname message)
      "Displays a notification message for ERC."
      (let* ((channel (buffer-name))
             (nick (erc-hl-nicks-trim-irc-nick nickname))
             (title (if (string-match-p (concat "^" nickname) channel)
                        nick
                      (concat nick " (" channel ")")))
             (msg (s-trim (s-collapse-whitespace message))))
        (alert (concat nick ": " msg) :title title)))

    (defun tx/erc-preprocess (string)
      "Avoids channel flooding."
      (setq str (string-trim (replace-regexp-in-string "\n+" " " str))))

    (defun tx/erc-reset-track-mode ()
      "Resets ERC track mode."
      (interactive)
      (setq erc-modified-channels-alist nil)
      (erc-modified-channels-update)
      (erc-modified-channels-display)
      (force-mode-line-update))

    (defun tx/erc-start-or-switch ()
      "Connects to ERC, or switch to last active buffer."
      (interactive)
      (if (get-buffer "irc.freenode.net:6667")
          (erc-track-switch-buffer 1)
        (erc-tls :server "irc.freenode.net" :port 7070 :nick "theophilusx")))

    :hook ((ercn-notify . tx/erc-notify)
           (erc-send-pre . tx/erc-preprocess))
    :init
    (setq erc-autojoin-channels-alist '(("freenode.net" "#emacs" "#org-mode"
                                         "#stumpwm" "#clojure" "#clojurescript"
                                         "#clojure-emacs"))
          erc-autojoin-delay 60
          erc-autojoin-timing 'ident
          erc-fill-variable-maximum-indentation 5
          erc-hide-list '("JOIN" "PART" "QUIT")
          erc-insert-away-timestamp-function 'erc-insert-timestamp-right
          erc-insert-timestamp-function 'erc-insert-timestamp-right
          erc-join-buffer 'bury
          erc-kill-buffer-on-part t
          erc-kill-queries-on-quit t
          erc-kill-server-buffer-on-quit t
          erc-lurker-hide-list '("JOIN" "PART" "QUIT")
          erc-lurker-threshold-time 43200
          erc-nick "theophilusx"
          erc-prompt-for-nickserv-password nil
          erc-server-reconnect-attempts 5
          erc-server-reconnect-timeout 3
          erc-timestamp-format "[%H:%M] "
          erc-timestamp-only-if-changed-flag t
          erc-track-exclude-types '("JOIN" "MODE" "NICK" "PART" "QUIT")
          erc-truncate-mode t
          erc-user-full-name "Tim X")
    :config
    (add-to-list 'erc-modules 'notifications)
    (add-to-list 'erc-modules 'spelling)
    (add-to-list 'erc-modules 'autoaway)
    (erc-services-mode 1)
    (erc-update-modules)
    (add-hook
     'window-configuration-change-hook
     (lambda ()
       (setq erc-fill-column (- (window-width) 2)))))

  (use-package erc-hl-nicks
    :ensure t
    :after erc)

  (use-package erc-image
    :ensure t
    :after erc)

#+END_SRC

** Eshell

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package eshell
    :commands 'eshell
    :init
    (setq eshell-buffer-shorthand t
          eshell-cmpl-ignore-case t
          eshell-cmpl-cycle-completions nil
          eshell-history-size 10000
          eshell-hist-ignoredups t
          eshell-error-if-no-glob t
          eshell-glob-case-insensitive t
          eshell-scroll-to-bottom-on-input 'all)
    :config
    (progn
      (defun jcf-eshell-here ()
        (interactive)
        (eshell "here"))

      (defun pcomplete/sudo ()
        (let ((prec (pcomplete-arg 'last -1)))
          (cond ((string= "sudo" prec)
                 (while (pcomplete-here*
                         (funcall pcomplete-command-completion-function)
                         (pcomplete-arg 'last) t))))))

      (add-hook 'eshell-mode-hook
                (lambda ()
                  (eshell/export "NODE_NO_READLINE=1")))))

#+END_SRC

** Elfeed

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (use-package elfeed
    :ensure t
    :init
    (setq elfeed-db-directory "~/Dropbox/.elfeed"
          elfeed-enclosure-default-dir "~/.emacs.d/elfeed"
          elfeed-save-multiple-enclosures-without-asking t)

    (defun elfeed-mark-all-as-read ()
      (interactive)
      (mark-whole-buffer)
      (elfeed-search-untag-all-unread))

    ;;functions to support syncing .elfeed between machines
    ;;makes sure elfeed reads index from disk before launching
    (defun tx/elfeed ()
      "Wrapper to load the elfeed db from disk before opening"
      (interactive)
      (elfeed-db-load)
      (elfeed)
      (elfeed-search-update--force))

    ;;write to disk when quiting
    (defun tx/elfeed-save-db-and-bury ()
      "Wrapper to save the elfeed db to disk before burying buffer"
      (interactive)
      (elfeed-db-save)
      (quit-window))

    (defhydra hydra-elfeed ()
     "filter"
     ("s" (elfeed-search-set-filter "@6-months-ago +sec +unread") "sec")
     ("n" (elfeed-search-set-filter "@6-months-ago +news +unread") "news")
     ("e" (elfeed-search-set-filter "@6-months-ago +emacs +unread") "emacs")
     ("p" (elfeed-search-set-filter "@6-months-ago +prog +unread") "programming")
     ("c" (elfeed-search-set-filter "@6-months-ago +clojure +unread") "clojure")
     ("*" (elfeed-search-set-filter "@6-months-ago +star") "Starred")
     ("u" (elfeed-search-set-filter "@6-months-ago +totag +unread") "un-tagged")
     ("f" (elfeed-search-set-filter "@6-months-ago +fun +unread") "fun")
     ("M" elfeed-toggle-star "Mark")
     ("A" (elfeed-search-set-filter "@6-months-ago") "All")
     ("T" (elfeed-search-set-filter "@1-day-ago +unread") "Today")
     ("Q" bjm/elfeed-save-db-and-bury "Quit Elfeed" :color blue)
     ("q" nil "quit" :color blue))

    :config
    (defalias 'elfeed-toggle-star
      (elfeed-expose #'elfeed-search-toggle-all 'star))
    :bind (:map elfeed-search-mode-map
	        ("q" . tx/elfeed-save-db-and-bury)
	        ("Q" . tx/elfeed-save-db-and-bury)
	        ("m" . elfeed-toggle-star)
	        ("M" . elfeed-toggle-star)
	        ("j" . hydra-elfeed/body)
	        ("J" . hydra-elfeed/body)))

  (use-package elfeed-org
    :ensure t
    :init
    (setq rmh-elfeed-org-files (list "~/Dropbox/org/my-feeds.org"))
    :config
    (elfeed-org))

#+END_SRC

** Gnuplot

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package gnuplot
    :ensure t)

#+END_SRC

** Mail
*** Google Contacts

 Ability to access google contacts is useful.

 #+BEGIN_SRC emacs-lisp :tangle no
   (use-package google-contacts
     :ensure t
     :init
     (setq plstore-cache-passphrase-for-symmetric-encryption t)
     :config
     ;; (require 'google-contacts-message)
     (require 'google-org-contacts))

 #+END_SRC

*** Mu4e

 First, setup some load paths.

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (require 'info)

   (if *is-a-mac*
       (progn
         (setq mu4e-lisp "/usr/local/share/emacs/site-lisp/mu/mu4e")
         (setq mu4e-info "/usr/local/share/info"))
     (setq mu4e-lisp "/usr/share/emacs/site-lisp/mu4e")
     (setq mu4e-info "/usr/share/info"))

   (add-to-list 'load-path (expand-file-name mu4e-lisp))
   (add-to-list 'Info-additional-directory-list (expand-file-name mu4e-info))

 #+END_SRC

 Next, load some additional packages we need.

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (when *run_emacspeak*
       (require 'emacspeak-mu4e))

   (require 'org-mu4e)

   (use-package "org-mime"
     :ensure t)

 #+END_SRC

 Now setup mu4e.

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (use-package mu4e
     :init
     (setq tx-gmail-email "theophilusx@gmail.com"
           tx-sheepcrc-email "tcross8@une.edu.au"
           tx-hotmail-email "blind-bat@hotmail.com")
     (setq mu4e-maildir (expand-file-name "~/Maildir")
           mu4e-attachment-dir (expand-file-name "~/Desktop")
           mu4e-get-mail-command "mbsync -a"
           mu4e-headers-include-related nil
           mu4e-change-filenames-when-moving t
           mu4e-context-policy 'pick-first
           mu4e-compose-context-policy nil
           mu4e-view-fields '(:from :to :cc :subject :date :attachments)
           mu4e-view-scroll-to-next nil
           mu4e-view-show-addresses t
           mu4e-view-use-gnus t
           mu4e-update-interval nil
           mu4e-user-mail-address-list '("theophilusx@gmail.com"
                                         "tcross8@une.edu.au"
                                         "tcross@une.edu.au"
                                         "blind-bat@hotmail.com"))
     (setq org-mu4e-link-query-in-headers-mode nil)
     :config
     (add-hook 'message-mode-hook 'turn-on-orgtbl)
     ;;(add-hook 'message-mode-hook 'outline-minor-mode)
     (setq mu4e-bookmarks '())
     (add-to-list 'mu4e-bookmarks
                     (make-mu4e-bookmark
                              :name  "Unread messages"
                              :query "flag:unread AND NOT flag:trashed"
                              :key ?u))
     (add-to-list 'mu4e-bookmarks
                     (make-mu4e-bookmark
                              :name "Today's messages"
                              :query "date:today..now AND NOT flag:trashed"
                              :key ?t))
     (add-to-list 'mu4e-bookmarks
                     (make-mu4e-bookmark
                              :name "Last 7 days"
                              :query "date:7d..now AND NOT flag:trashed"
                              :key ?w))
     (add-to-list 'mu4e-bookmarks
                     (make-mu4e-bookmark
                              :name "Messages with images"
                              :query "mime:image/* AND NOT flag:trashed"
                              :key ?p))
     (setq mu4e-contexts '())
     (add-to-list 'mu4e-contexts
                  (make-mu4e-context
                   :name "Private"
                   :enter-func (lambda ()
                                 (mu4e-message "Entering Private context"))
                   :leave-func
                   (lambda ()
                     (mu4e-message "Leaving Private context"))
                   ;; we match based on the contact-fields of the message
                   :match-func
                   (lambda (msg)
                     (when msg
                       (mu4e-message-contact-field-matches msg :to "theophilusx@gmail.com")))
                   :vars '((user-mail-address . "theophilusx@gmail.com")
                           (user-full-name . "Tim Cross")
                           (mu4e-compose-signature . (concat "Tim Cross\n"))
                           (mu4e-drafts-folder . "/gmail/Drafts")
                           (mu4e-sent-folder . "/gmail/Sent Mail")
                           (mu4e-trash-folder . "/gmail/Bin")
                           (mu4e-refile-folder . "/gmail/All Mail")
                           (mu4e-maildir-shortcuts . (("/gmail/INBOX" . ?i)
                                                      ("/gmail/Sent Mail" . ?s)
                                                      ("/gmail/All Mail" . ?a)
                                                      ("/gmail/Drafts" . ?d)
                                                      ("/gmail/Starred" . ?f)))
                           (smtpmail-smtp-server . "smtp.gmail.com")
                           (smtpmail-smtp-service . 587)
                           (mu4e-sent-messages-behavior . delete))))
     ;; (add-to-list 'mu4e-contexts
     ;;          (make-mu4e-context
     ;;           :name "Sheep"
     ;;           :enter-func
     ;;           (lambda ()
     ;;             (mu4e-message "Entering Sheep context"))
     ;;           :leave-func
     ;;           (lambda ()
     ;;             (mu4e-message "Leaving Sheep context"))
     ;;           ;; we match based on the contact-fields of the message
     ;;           :match-func
     ;;           (lambda (msg)
     ;;             (when msg
     ;;               (mu4e-message-contact-field-matches msg :to "tcross8@une.edu.au")))
     ;;           :vars '((user-mail-address . "tcross8@une.edu.au")
     ;;                   (user-full-name . "Tim Cross")
     ;;                   (mu4e-compose-signature . (concat
     ;;                                              "Tim Cross\n"
     ;;                                              "DBA/Developer - Livestock App Building\n"
     ;;                                              "School of Science and Technology\n"
     ;;                                              "Room 253 Booth Block (C027), Univrsity of New England\n"))
     ;;                   (mu4e-drafts-folder . "/sheep/Drafts")
     ;;                   (mu4e-sent-folder . "/sheep/Sent Items")
     ;;                   (mu4e-trash-folder . "/sheep/Deleted Items")
     ;;                   (mu4e-refile-folder . "/sheep/Archive")
     ;;                   (mu4e-maildir-shortcuts . (("/sheep/INBOX" . ?i)
     ;;                                              ("/sheep/Sent Items" . ?s)
     ;;                                              ("/sheep/Archive" . ?a)
     ;;                                              ("/sheep/Drafts" . ?d)))
     ;;                   (smtpmail-smtp-server . "mailhub.une.edu.au")
     ;;                   (smtpmail-smtp-service . 25)
     ;;                   (mu4e-sent-messages-behavior . sent))))
     (add-to-list 'mu4e-contexts
              (make-mu4e-context
               :name "Outlook"
               :enter-func
               (lambda ()
                 (mu4e-message "Entering Outlook context"))
               :leave-func
               (lambda ()
                 (mu4e-message "Leaving Outlook context"))
               ;; we match based on the contact-fields of the message
               :match-func
               (lambda (msg)
                 (when msg
                   (mu4e-message-contact-field-matches msg :to "blind-bat@hotmail.com")))
               :vars '((user-mail-address . "blind-bat@hotmail.com")
                       (user-full-name . "Tim Cross")
                       (mu4e-compose-signature . (concat "Tim Cross\n"))
                       (mu4e-drafts-folder . "/outlook/Drafts")
                       (mu4e-sent-folder . "/outlook/Sent Mail")
                       (mu4e-trash-folder . "/outlook/Deleted Items")
                       (mu4e-refile-folder . "/outlook/Archive")
                       (mu4e-maildir-shortcuts . (("/outlook/INBOX" . ?i)
                                                  ("/outlook/Sent Mail" . ?s)
                                                  ("/outlook/Archive" . ?a)
                                                  ("/outlook/Drafts" . ?d)))
                       (smtpmail-smtp-server . "smtp-mail.outlook.com")
                       (smtpmail-smtp-service . 587)
                       (mu4e-sent-messages-behavior . delete)))))

 #+END_SRC

 I no longer have a UNE staff account, so have removed the associated context for
 that account. However, may still need it if I want to look at the messages I
 have archived on this system, so keeping it below for reference.

 #+BEGIN_EXAMPLE
   (make-mu4e-context
               :name "Work"
               :enter-func (lambda ()
                             (mu4e-message "Switch to the Work context"))
               ;; we match based on the contact-fields of the message
               :match-func (lambda (msg)
                             (when msg
                               (mu4e-message-contact-field-matches msg :to "tcross@une.edu.au")))
               :vars '((user-mail-address . "tcross@une.edu.au")
                       (user-full-name . "Tim Cross")
                       (mu4e-compose-signature . (concat "Tim Cross\n"
                                                         "www.une.edu.au\n"
                                                         "CRICOS Provider Number: 00003G"))
                       (mu4e-drafts-folder . "/une/Drafts")
                       (mu4e-sent-folder . "/une/Sent")
                       (mu4e-trash-folder . "/une/Deleted Items")
                       (mu4e-refile-folder . "/une/Archive")
                       (mu4e-maildir-shortcuts . (("/une/Inbox" . ?i)
                                                  ("/une/Sent" . ?s)
                                                  ("/une/Drafts" . ?d)))
                       (smtpmail-smtp-server . "smtp.office365.com")
                       (smtpmail-smtp-service . 587)
                       (mu4e-sent-messages-behavior . sent)))

 #+END_EXAMPLE

 #+BEGIN_SRC emacs-lisp :tangle tangle-init.el
   (use-package smtpmail
     :config
     (setq message-send-mail-function 'smtpmail-send-it
           smtpmail-stream-type 'starttls
           smtpmail-debug-info nil
           smtpmail-debug-verb nil
           smtpmail-default-smtp-server "smtp.gmail.com")
     (setq smtpmail-queue-mail nil  ;; start in normal mode
           smtpmail-queue-dir   (expand-file-name "~/Maildir/queue/cur"))
     ;; don't keep message buffers around
     (setq message-kill-buffer-on-exit t))

 #+END_SRC

*** Test out VM again

 Looks like there has been no work done on VM since 2016. Suspect the client may
 have reached end-of-life!

 #+BEGIN_SRC emacs-lisp :tangle no
   (add-to-list 'load-path (expand-file-name "~/bzr/vm/new-trunk/lisp"))
   (add-to-list 'Info-additional-directory-list
                (expand-file-name "~/bzr/vm/new-trunk/info"))

   (require 'vm-autoloads)

   ;; Some hacks to make VM use shr for HTML messages

   (defun vm-mime-display-internal-shr-text/html (start end layout)
     "Use shr to inline HTML mails in the VM presentation buffer."
     (shr-render-region start (1- end))
     (put-text-property start end
                        'text-rendered-by-shr t))

   ;; has to be done indirectly
   ;; Fake emacs-w3m, though we actually use shr

   (defalias 'vm-mime-display-internal-emacs-w3m-text/html
        'vm-mime-display-internal-shr-text/html)

 #+END_SRC

* Local Packages
I put locally managed packages i.e. those not installed via elpa into the lib
directory.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ipcalc
    :commands (ipcalc))

#+END_SRC

* Keymaps

*** read-write-toggle

#+begin_src emacs-lisp :tangle tangle-init.el
  (defun tx/read-write-toggle ()
    "Toggles read-only in any relevant mode: ag-mode, Dired, or
  just any file at all."
    (interactive)
    (if (equal major-mode 'ag-mode)
        ;; wgrep-ag can support ag-mode
        (wgrep-change-to-wgrep-mode)
      ;; dired-toggle-read-only has its own conditional:
      ;; if the mode is Dired, it will make the directory writable
      ;; if it is not, it will just toggle read only, as desired
      (dired-toggle-read-only)))

#+end_src

*** Scratch

#+begin_src emacs-lisp :tangle tangle-init.el
  (defun tx/scratch ()
      (interactive)
      (switch-to-buffer-other-window (get-buffer-create "*scratch*")))

#+end_src

#+begin_src emacs-lisp :tangle tangle-init.el
  (defun tx/make-org-scratch ()
    (interactive)
    (find-file "~/Dropbox/org/scratch.org"))

#+end_src

** Toggle Map

#+begin_src emacs-lisp :tangle tangle-init.el
  (bind-keys :prefix-map toggle-map
             :prefix "C-x t"
             ("d" . toggle-debug-on-error)
             ("f" . tx/toggle-fold)
             ("l" . linum-mode)
             ("n" . tx/narrow-or-widen-dwim)
             ("o" . org-mode)
             ("r" . tx/read-write-toggle)
             ("t" . text-mode)
             ("w" . whitespace-mode))

#+end_src

** Launcher Map

#+begin_src emacs-lisp :tangle tangle-init.el
  (bind-keys :prefix-map launcher-map
             :prefix "C-x l"
             ("A" . terminal) ;; save "a" for open-agenda
             ("c" . calc)
             ("C" . calendar)
             ("d" . ediff-buffers)
             ("e" . eshell)
             ("E" . eww)
             ("h" . man)
             ("P" . proced)
             ("s" . tx/scratch)
             ("S" . tx/make-org-scratch))

  (if *is-a-mac*
    (use-package counsel-osx-app
      :bind (:map launcher-map
                  ("." . counsel-osx-app)))
    (bind-keys :map launcher-map
               ("." . counsel-linux-app)))

#+end_src

* Coding System

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))

#+END_SRC

* Emacs Server
Start the emacs server so that we can use emacsclient

** Emacs Server

#+BEGIN_SRC emacs-lisp :tangle tangle-init.el
(use-package server
  :init
  (when-let (name (getenv "EMACS_SERVER_NAME"))
    (setq server-name name))
  :config
  (unless (server-running-p)
    (server-start)))

#+END_SRC

