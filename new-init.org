#+TITLE: Emacs init.el File
#+DATE: \today
#+AUTHOR: Tim Cross

* Early Init

Emacs 27 introduces an early init file. This is a good place to set some frame defaults and tweak the gc to speed up init process
The below has been borrowed from Doom Emacs.

** Set Some Constants
 I set a couple of constants which can then be used to control configuration
 settings in my init file.

*** Mac or Linux?

 I run emacs on both OSX and Linux. To handle differences in configuration
 settings for the two platforms, I set a constant which determines if emacs is
 running on OSX or not. 

 #+begin_src emacs-lisp :tangle tangle-early-init.el
   (defconst *is-a-mac* (eq system-type 'darwin)
     "T if emacs is running under OSX, nil otherwise.")

 #+end_src

*** Do Spell Checking?

 Set a constant to determine if spell checking is to be enabled. Not sure if I
 really need this, but leaving it in place for now.

 #+begin_src emacs-lisp :tangle tangle-early-init.el
   (defconst *spell-check-support-enabled* t
     "T if we want spell checking support enabled, nil otherwise.")

 #+end_src

*** Silence Warnings

 Some ELISP packages don't necessarily define variables correctly and can
 generate warnings. This section lists such variables to quieten things down a
 bit.

 #+begin_src emacs-lisp :tangle tangle-early-init.el
   (defvar url-http-extra-headers nil)
   (defvar oauth--token-data nil)
   (defvar url-callback-function nil)
   (defvar url-callback-arguments nil)
   (defvar emacspeak-we-url-executor nil)
   (defvar org-ans2 nil)
   (defvar ido-process-ignore-lists nil)
   (defvar select-object nil)
   (defvar *slime-inspector* nil)

 #+end_src

*** Load Emacspeak

 #+begin_src emacs-lisp :tangle tangle-early-init.el
   (defconst *run_emacspeak* (if (string= (getenv "RUN_EMACSPEAK") "yes")
                                 t
                               nil))


 #+end_src

** GC

Defer garbage collection further back in the startup process

#+begin_src emacs-lisp :tangle tangle-early-init.el
  (setq gc-cons-threshold 268435456)

#+end_src

** Package 

Package initialize occurs automatically, before `user-init-file' is
loaded, but after `early-init-file'. We handles package
initialization, so we must prevent Emacs from doing it early!

#+begin_src emacs-lisp :tangle tangle-early-init.el
  ;;; (setq package-enable-at-startup nil)

#+end_src

Silence the package warnings for now

#+begin_src emacs-lisp :tangle tangle-early-init.el
  (setq warning-suppress-log-types '((package reinitialization)))

#+end_src

** Frames

Prevent the glimpse of un-styled Emacs by setting these early.

#+begin_src emacs-lisp :tangle tangle-early-init.el
  (setq initial-frame-alist '((vertical-scroll-bars)
                               (horizontal-scroll-bars)
                               (tool-bar-lines . 0)
                               (menu-bar-lines . 0)
                               (width . 90)
                               (height . 34)))
  (setq default-frame-alist '((tool-bar-lines . 0)
                               (menu-bar-lines . 0)
                               (vertical-scroll-bars)
                               (top . 10)
                               (left . 10)
                               (width . 90)
                               (height . 34)))

  (if *is-a-mac*
      (add-to-list 'default-frame-alist '(fullscreen . fullboth)))

#+end_src

** site-run

One less file to load at startup

#+begin_src emacs-lisp :tangle tangle-early-init.el
(setq site-run-file nil)

#+end_src

* GC Settings

#+begin_src emacs-lisp :tangle tangle-init.el
  (defvar tx-gc-cons-threshold 16777216 ; 16mb
    "The default value to use for `gc-cons-threshold'. If you experience freezing,
  decrease this. If you experience stuttering, increase this.")

  (defvar tx-gc-cons-upper-limit 536870912 ; 512mb
    "The temporary value for `gc-cons-threshold' to defer it.")

  (defvar tx-file-name-handler-alist file-name-handler-alist)

#+end_src

Function to restore default gc etc after init.

#+begin_src emacs-lisp :tangle tangle-init.el
  (defun tx-restore-startup-optimizations ()
    "Resets garbage collection settings to reasonable defaults (a large
  `gc-cons-threshold' can cause random freezes otherwise) and resets
  `file-name-handler-alist'."
    (setq file-name-handler-alist tx-file-name-handler-alist)
    ;; Do this on idle timer to defer a possible GC pause that could result; also
    ;; allows deferred packages to take advantage of these optimizations.
    (run-with-idle-timer
     3 nil
     (lambda ()
       (setq-default gc-cons-threshold tx-gc-cons-threshold)
       ;; To speed up minibuffer commands (like helm and ivy), we defer garbage
       ;; collection while the minibuffer is active.
       (defun tx-defer-garbage-collection ()
	 (setq gc-cons-threshold tx-gc-cons-upper-limit))
       (defun tx-restore-garbage-collection ()
	 ;; Defer it so that commands launched from the minibuffer can enjoy the
	 ;; benefits.
	 (run-at-time 1 nil (lambda ()
			      (setq gc-cons-threshold tx-gc-cons-threshold))))
       (add-hook 'minibuffer-setup-hook #'tx-defer-garbage-collection)
       (add-hook 'minibuffer-exit-hook  #'tx-restore-garbage-collection)
       ;; GC all sneaky breeky like
       (add-hook 'focus-out-hook #'garbage-collect))))


  (if (ignore-errors (or after-init-time noninteractive))
      (setq gc-cons-threshold tx-gc-cons-threshold)
    ;; A big contributor to startup times is garbage collection. We up the gc
    ;; threshold to temporarily prevent it from running, then reset it later in
    ;; `tx-restore-startup-optimizations'.
    (setq gc-cons-threshold tx-gc-cons-upper-limit)
    ;; This is consulted on every `require', `load' and various path/io functions.
    ;; You get a minor speed up by nooping this.
    (setq file-name-handler-alist nil)
    ;; Not restoring these to their defaults will cause stuttering/freezes.
    (add-hook 'after-init-hook #'tx-restore-startup-optimizations))

#+end_src

Set things for fast load

#+begin_src emacs-lisp :tangle tangle-init.el
  (if (ignore-errors (or after-init-time noninteractive))
      (setq gc-cons-threshold tx-gc-cons-threshold)
    ;; A big contributor to startup times is garbage collection. We up the gc
    ;; threshold to temporarily prevent it from running, then reset it later in
    ;; `tx-restore-startup-optimizations'.
    (setq gc-cons-threshold tx-gc-cons-upper-limit)
    ;; This is consulted on every `require', `load' and various path/io functions.
    ;; You get a minor speed up by nooping this.
    (setq file-name-handler-alist nil)
    ;; Not restoring these to their defaults will cause stuttering/freezes.
    (add-hook 'after-init-hook #'tx-restore-startup-optimizations))

  (setq load-prefer-newer noninteractive)

#+end_src

* Emacs < 27 stuff

Emacs < 27 does not have the early init file.

#+begin_src emacs-lisp :tangle tangle-init.el
  (when (< emacs-major-version 27)
    (defconst *is-a-mac* (eq system-type 'darwin)
      "T if emacs is running under OSX, nil otherwise.")

    (defconst *spell-check-support-enabled* t
      "T if we want spell checking support enabled, nil otherwise.")

    (defvar url-http-extra-headers nil)
    (defvar oauth--token-data nil)
    (defvar url-callback-function nil)
    (defvar url-callback-arguments nil)
    (defvar emacspeak-we-url-executor nil)
    (defvar org-ans2 nil)
    (defvar ido-process-ignore-lists nil)
    (defvar select-object nil)
    (defvar *slime-inspector* nil)

    (defconst *run_emacspeak* (if (getenv "RUN_EMACSPEAK") t nil))


    (setq initial-frame-alist '((vertical-scroll-bars)
                                 (horizontal-scroll-bars)
                                 (tool-bar-lines . 0)
                                 (menu-bar-lines . 0)
                                 (width . 90)
                                 (height . 29)))
    (setq default-frame-alist '((tool-bar-lines . 0)
                                 (menu-bar-lines . 0)
                                 (vertical-scroll-bars)
                                 (top . 10)
                                 (left . 10)
                                 (width . 90)
                                 (height . 29)))
    (if *is-a-mac*
        (add-to-list 'default-frame-alist '(fullscreen . fullboth))))

#+end_src

* Load Path
The following adds additional directories to the emacs load-path so that
emacs can find various additional libraries etc

Any small third party libraries I use which are not packaged in an ELPA
repository go in the ~.emacs.d/lib~  subdirectory.

#+begin_src emacs-lisp :tangle tangle-init.el
  (add-to-list 'load-path (expand-file-name "lib" user-emacs-directory))

#+end_src

* Emacspeak

Now load Emacspeak. As Emacspeak makes extensive use of Emacs' =defacvice=
facility, it is important that it is loaded as early as possible in the Emacs
boot process.

First, setup a constant which tells emacs where to look for the emacspeak distro

** Emacspeak Loading Constants

#+begin_src emacs-lisp :tangle tangle-init.el
  (when *run_emacspeak*
    (defconst *emacspeak-src-dir* (if (getenv "EMACSPEAK_DIR")
                                      (expand-file-name (getenv "EMACSPEAK_DIR"))
                                    (expand-file-name "~/git/emacspeak/trunk"))
      "Where emacs will find the emacspeak distro")

    (defconst *dtk-program* (if (getenv "DTK_PROGRAM")
                                (getenv "DTK_PROGRAM")
                              (if *is-a-mac*
                                  "mac"
                                "espeak")))
  
    (require 'info)
    (add-to-list 'Info-additional-directory-list
                 (expand-file-name "info"  *emacspeak-src-dir*)))

#+end_src

** Load Emacspeak

When emacs is not being run in batch mode and when emacspeak is not yet loaded,
then load it

#+begin_src emacs-lisp :tangle tangle-init.el
  (when (and *run_emacspeak*
             (not noninteractive)
             (not (featurep 'emacspeak)))
    (add-to-list 'load-path *emacspeak-src-dir*)
    (setenv "EMACSPEAK_DIR" *emacspeak-src-dir*)
    (setenv "DTK_PROGRAM" *dtk-program*)
    (setq dtk-program *dtk-program*
          dtk-use-tones nil
          emacspeak-auditory-icon-function 'emacspeak-soxplay-auditory-icon
          emacspeak-erc-my-nick "theophilusx"
          emacspeak-erc-speak-all-participants t
          emacspeak-mail-alert nil
          emacspeak-play-emacspeak-startup-icon nil
          emacspeak-vm-use-raman-settings nil
          emacspeak-play-program (expand-file-name "~/bin/play")
          emacpseak-play-args nil
          mac-default-speech-rate 360        
          outloud-default-speech-rate 90
          espeak-default-speech-rate 250
          sox-play (if *is-a-mac*
                       "/usr/local/bin/play"
                     "/usr/bin/play")
          emacspeak-soxplay-command (if *is-a-mac*
                                        "/usr/local/bin/play -v 1.2 %s earwax &"
                                      "/usr/bin/play -v 1.2 %s earwax &")
          tts-default-speech-rate 90)

    (add-hook 'emacspeak-startup-hook
              (lambda ()
                ;; (dtk-set-rate tts-default-speech-rate 1)
                (dtk-interp-sync)
                (emacspeak-sounds-select-theme "3d/")))

    (load-file (concat *emacspeak-src-dir* "/lisp/emacspeak-setup.el")))

#+end_src

I like to set my own key bindings and there are a lot of emacspeak key bindings
I don't need/want. However, emacspeak does a key binding /refresh/ at the end of
the init process by adding some emacspeak setup functions to the
=after-init-hook=. This means we need to make our setup changes in this hook and
ensure our changes are added /after/ emacspeak hook functions run by appending
them.

** Emacspeak Key Bindings

#+begin_src emacs-lisp :tangle no
  (when *run_emacspeak*
    (defun my-esp-bindings ()
      (message "Loading my emacspeak key bindings...")
      ;; (unbind-key "<S-left>")
      ;; (unbind-key "<S-right>")
      ;; (unbind-key "<C-left>")
      ;; (unbind-key "<C-right>")
      ;; (unbind-key "<C-down>")
      ;; (unbind-key "<C-up>")
      ;; (unbind-key "<S-up>")
      ;; (unbind-key "<S-down>")
      (bind-key "<f5>" 'my-hydra-window/body)
      (bind-key "<f7>" 'my-hydra-wizards/body)
      (bind-key "C-z" 'my-hydra-zoom/body))

    (add-hook 'after-init-hook #'my-esp-bindings t))

#+end_src

 I've added a little of my own extensions/enhancements to Emacspeak. Once I feel
 they are mature enough, I will generally submit them for inclusion 

** Experimental 

#+begin_src emacs-lisp :tangle no
  ;;;Require my emacspeak-smartparens.el
  (when (featurep 'emacspeak)
    (require 'emacspeak-smartparens))

#+end_src

* Custom 

#+begin_src emacs-lisp :tangle tangle-init.el
  (if *is-a-mac*
      (setq custom-file (expand-file-name "mac-custom.el" user-emacs-directory))
    (setq custom-file (expand-file-name "linux-custom.el" user-emacs-directory)))

  (when (file-exists-p custom-file)
    (load custom-file))

#+end_src

* ELPA

ELPA has made managing add-on elisp packages *much* easier than it use to
be. The trick is to only load packages you really want/need and not get carried
away loading lots of additional packages /just in case/.


First, we need to load package.el and then we need to add some additional
package repositories. I add

   - The Org repository so that I can use most recent org-plus-contrib package
   - The melpa repository

#+begin_src emacs-lisp :tangle tangle-init.el
  (require 'package)

  (setq package-enable-at-startup nil
        package-archive-priorities '(("org" . 2) ("melpa" . 1) ("gnu" . 0)))

  (add-to-list 'package-archives `("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (when (< emacs-major-version 27)
    (package-initialize))

#+end_src

* Use Package

I just found John Wiegley's use-package macro, which I think is a really
convenient way to manage the installation and configuration of ELPA
packages. Therefore, I plan to migrate my configuration to use that package.

We have a slight bootstrap or /chicken and egg/ problem, we need the use-package
package from ELPA before we can use it, but it is what we want to use to install
the package. Therefore, need a simple light weight way to get that package. Lets
do the simple way

#+begin_src emacs-lisp :tangle tangle-init.el
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'diminish)
    (package-install 'delight)
    (package-install 'bind-key)
    (package-install 'use-package))

  (setq use-package-verbose nil)

  ;; melpa version of use-package currently broken. Load from git clone instead
  ;; (eval-when-compile
  ;;   ;; Following line is not needed if use-package.el is in ~/.emacs.d
  ;;   (add-to-list 'load-path "~/git/github/use-package")
  ;;   (require 'use-package))

  ;; (eval-when-compile
  ;;   (require 'use-package))
  ;; (require 'diminish)
  ;; (require 'bind-key)

#+end_src

* Org Mode

Start by getting required package. I'm using the org-plus-contrib package from
the org repository.

*Note*: Occasionally, you may run into problems when installing org from a
repository. Essentially the problem can occur if you have some of the bundled
org files loaded when you try to install a repo version. The easiest way to fix
this is to reload org mode using the command

  : C-u M-x org-reload

Then remove the repo package version and re-install. This will
normally ensure a 'stable' environment.

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package org
    ;;;:pin org
    :ensure org-plus-contrib 
    :init
    (setq
     org-agenda-files '("~/Dropbox/org")
     org-agenda-remove-tags t
     org-agenda-show-outline-path nil
     org-babel-clojure-backend 'cider
     org-babel-clojure-sync-nrepl-timeout 0
     org-catch-invisible-edits 'smart
     org-clock-in-resume t
     org-clock-out-remove-zero-time-clocks t
     org-clock-persist 'clock
     org-confirm-babel-evaluate nil
     org-ctrl-k-protect-subtree t
     org-default-notes-file "~/Dropbox/org/notes.org"
     org-directory "~/Dropbox/org"
     org-ditaa-jar-path (expand-file-name "~/.emacs.d/jars/ditaa.jar")
     org-ditaa-eps-jar-path (expand-file-name "~/.emacs.d/jars/DitaaEps.jar")
     org-ellipsis "â€¦"
     org-enforce-todo-checkbox-dependencies t
     org-enforce-todo-dependencies t
     org-export-backends '(ascii beamer html
                                 latex texinfo
                                 md odt org)
     org-export-coding-system 'utf-8
     org-hide-block-startup t
     org-log-done 'time
     org-log-into-drawer t
     org-list-allow-alphabetical t
     org-list-indent-offset 2
     org-log-refile 'time
     org-modules '(org-bibtex
                   org-crypt
                   org-docview
                   org-eww
                   org-info
                   org-irc
                   org-protocol)
     org-plantuml-jar-path (expand-file-name "~/.emacs.d/jars/plantuml.jar")
     org-pretty-entities t
     org-refile-allow-creating-parent-nodes 'confirm
     org-refile-targets (quote ((nil :maxlevel . 5)
                                (org-agenda-files :maxlevel . 5)))
     org-refile-use-outline-path (quote file)
     org-src-tab-acts-natively t
     org-src-window-setup 'current-window
     org-startup-align-all-tables t
     org-startup-with-inline-images (display-graphic-p)
     org-support-shift-select t
     org-time-clocksum-format '(:hours "%d" :require-hours t
                                       :minutes ":%02d" :require-minutes t)
     org-use-sub-superscripts (quote {}))
  
    (setq
     org-capture-templates
     (quote
      (("t" "todo" entry
        (file "~/Dropbox/org/refile.org")
        "* TODO %?\n\n  %a"
        :empty-lines-after 1 :clock-in t :clock-resume t)
       ("r" "respond" entry
        (file "~/Dropbox/org/refile.org")
        "* NEXT Respond to %:from on %:subject\n  SCHEDULED: %t\n  %a"
        :empty-lines-after 1 :clock-in t :clock-resume t)
       ("n" "note" entry
        (file "~/Dropbox/org/notes.org")
        "* %? :NOTE:\n\n  %a"
        :empty-lines-after 1 :clock-in t :clock-resume t)
       ("j" "journal" entry
        (file+olp+datetree "~/Dropbox/org/journal.org")
        "* %?\n  "
        :empty-lines-after 1 :clock-in t :clock-resume t)
       ("p" "phone" entry
        (file "~/Dropbox/org/refile.org")
        "* PHONE %? :PHONE:\n  "
        :empty-lines-after 1 :clock-in t :clock-resume t)
       ("m" "mail" entry
        (file "~/Dropbox/org/refile.org")
        "* MAIL from %:from on %:subject\n\n  %a"
        :empty-lines-after 1 :clock-in t :clock-resume t))))

    (setq
     org-todo-keywords (quote
                        ((sequence "TODO(t)"
                                   "NEXT(n)"
                                   "STARTED(s!)"
                                   "DELEGATED(w@/!)"
                                   "HOLD(h@/!)"
                                   "|"
                                   "CANCELLED(c@)"
                                   "DONE(d!)"))))

    (setq
     org-agenda-custom-commands
     (quote
      (("n" "Agenda and all TODO's"
        ((agenda "" nil)
         (alltodo "" nil))
        nil)
       ("wr" "Weekly Report"
        ((todo "DONE|CANCELLED"
               ((org-agenda-overriding-header "Completed and Cancelled : Last Week")))
         (todo "STARTED|NEXT"
               ((org-agenda-overriding-header "WIP")))
         (todo "HOLD|DELEGATED"
               ((org-agenda-overriding-header "On Hold and Delegated Tasks")))
         (todo "TODO"
               ((org-agenda-overriding-header "Task Backlog"))))
        nil nil))))

     (setq org-latex-classes
          '(("beamer"
             "\\documentclass[presentation]{beamer}"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
            ("hitec-article"
             "\\documentclass[12pt]{hitec}
    [DEFAULT-PACKAGES]
    [PACKAGES]
    [NO-EXTRA]
    \\settextfraction{0.95}\n"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
            ("article" "\\documentclass[11pt]{article}"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
            ("korma-article" "\\documentclass[11pt]{scrartcl}"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
            ("report"
             "\\documentclass[11pt]{report}"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
            ("korma-report"
             "\\documentclass[11pt]{scrreport}"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
            ("korma-book"
             "\\documentclass[11pt]{scrbook}"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
            ("book"
             "\\documentclass[11pt]{book}"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
    (setq org-latex-hyperref-template
          "\\hypersetup{pdfauthor={%a},
                        pdftitle={%t},
                        pdfkeywords={%k},
                        pdfsubject={%d},
                        pdfcreator={%c},
                        pdflang={%L},
                        colorlinks=true,
                        linkcolor=blue}")
    (setq org-latex-listings t
          org-latex-listings-options '(("basicstyle" "\\tiny")
                                       ("frame" "single")
                                       ("stringstyle" "\\color{orange}")
                                       ("commentstyle" "\\color{cyan}")
                                       ("keywordstyle" "\\color{blue}")
                                       ("showstringspaces" "false")
                                       ("breakatwhitespace" "false")
                                       ("breaklines" "true")))
    (setq org-latex-pdf-process
          '("lualatex -interaction nonstopmode -output-directory %o %f"
            "lualatex -interaction nonstopmode -output-directory %o %f"
            "lualatex -interaction nonstopmode -output-directory %o %f"))
    (setq org-latex-packages-alist
          '(("" "parskip")
            ("" "xcolor")
            ("" "listings")))
    (setq org-html-checkbox-type 'unicode
          org-html-html5-fancy t
          org-html-doctype "html5")
    (setq org-ascii-charset 'utf-8
          org-ascii-text-width 79)
    :config
    (org-element-update-syntax)
    (org-clock-persistence-insinuate)

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (clojure . t)
       (css . t)
       (dot . t)
       (java . t)
       (js . t)
       (latex . t)
       (ledger . t)
       (lisp . t)
       (makefile . t)
       (org . t)
       (perl . t)
       (python . t)
       (ruby . t)
       (scheme . t)
       (shell . t)
       (sql . t)
       (C . t)
       (ditaa . t)
       (plantuml . t)
       (gnuplot . t)))
    (bind-key "C-c l" 'org-store-link)
    (bind-key "C-c a" 'org-agenda)
    (bind-key "C-c b" 'org-switchb)
    (bind-key "C-c r" 'org-capture))

#+end_src

* Hydra

 #+begin_src emacs-lisp :tangle tangle-init.el
   (use-package winner
     :config
     (winner-mode 1))

   (use-package windmove
     :config
     (windmove-default-keybindings))

   (use-package hydra
     :ensure t
     :config
     (defun hydra-move-splitter-left (arg)
       "Move window splitter left."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (shrink-window-horizontally arg)
         (enlarge-window-horizontally arg)))

     (defun hydra-move-splitter-right (arg)
       "Move window splitter right."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (enlarge-window-horizontally arg)
         (shrink-window-horizontally arg)))

     (defun hydra-move-splitter-up (arg)
       "Move window splitter up."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (enlarge-window arg)
         (shrink-window arg)))

     (defun hydra-move-splitter-down (arg)
       "Move window splitter down."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (shrink-window arg)
         (enlarge-window arg)))

     (when *run_emacspeak*
       (defhydra my-hydra-wizards ()
         "Emacspeak Wizards"
         ("c" emacspeak-wizards-byte-compile-current-buffer "Byte")
         ;; ("b" emacspeak-wizards-cycle-browser "Browser")
         ("e" emacspeak-wizards-eww-buffer-list "eww")
         ("r" emacspeak-wizards-find-file-as-root "root")
         ("g" emacspeak-wizards-find-grep "Grep")
         ("f" emacspeak-wizards-finder-find "Find")
         ("F" emacspeak-wizards-generate-finder "Finder")
         ("!" emacspeak-wizards-shell-command-on-current-file "cmd")
         ("s" emacspeak-wizards-spot-words "Spot")
         ("t" emacspeak-wizards-tramp-open-location "Tramp")
         ("q" nil "Quit"))

       )

     (defhydra my-hydra-zoom ()
       "zoom"
       ("-" text-scale-decrease "out")
       ("+" text-scale-increase "in")
       ("0" (text-scale-adjust 0) "reset")
       ("q" nil "quit" :color blue))

     ;;  (defhydra my-hydra-error ()
     ;;     "goto-error"
     ;;     ("h" first-error "first")
     ;;     ("j" next-error "next")
     ;;     ("k" previous-error "prev")
     ;;     ("v" recenter-top-bottom "recenter")
     ;;     ("q" nil "quit"))
     ;; -
     (require 'winner)
     (defhydra my-hydra-window (:color red :hint nil)
       "
    Split: _v_ert _x_:horz
   Delete: _o_nly  _da_ce  _dw_indow  _db_uffer  _df_rame
     Move: _s_wap
   Frames: _f_rame new  _df_ delete
     Misc: _m_ark _a_ce  _u_ndo  _r_edo"
       ("h" windmove-left)
       ("j" windmove-down)
       ("k" windmove-up)
       ("l" windmove-right)
       ("H" hydra-move-splitter-left)
       ("J" hydra-move-splitter-down)
       ("K" hydra-move-splitter-up)
       ("L" hydra-move-splitter-right)
       ("|" (lambda ()
              (interactive)
              (split-window-right)
              (windmove-right)))
       ("_" (lambda ()
              (interactive)
              (split-window-below)
              (windmove-down)))
       ("v" split-window-right)
       ("x" split-window-below)
       ;;("t" transpose-frame "'")
       ;; winner-mode must be enabled
       ("u" winner-undo)
       ("r" winner-redo) ;;Fixme, not working?
       ("o" delete-other-windows :exit t)
       ("a" ace-window :exit t)
       ("f" make-frame :exit t)
       ("s" ace-swap-window)
       ("da" ace-delete-window)
       ("dw" delete-window)
       ("db" kill-this-buffer)
       ("df" delete-frame :exit t)
       ("q" nil)
       ;;("i" ace-maximize-window "ace-one" :color blue)
       ;;("b" ido-switch-buffer "buf")
       ("m" headlong-bookmark-jump)))

 #+end_src

* OSX Tweaks 

Some tweaks to make emacs and OSX get on better. Note that I also install the
coreutils package from homebrew to get some GNU flavoured utilities. These tend
to start with 'g', so we need to do some additional variable settings.

#+begin_src emacs-lisp :tangle tangle-init.el
  (when *is-a-mac*
    (setq mac-command-modifier 'meta)
    (setq mac-option-modifier 'none)
    (setq dired-free-space-program "gdf")
    (setq insert-directory-program "gls")
    (setq default-input-method "MacOSX")
    ;; Make mouse wheel / trackpad scrolling less jerky
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 5)
                                        ((control))))
    (dolist (multiple '("" "double-" "triple-"))
      (dolist (direction '("right" "left"))
        (global-set-key (read-kbd-macro
                         (concat "<" multiple "wheel-" direction ">")) 'ignore)))
    (bind-key "M-'" 'ns-next-frame)
    (bind-key "M-h" 'ns-do-hide-emacs)
    (bind-key "M-`" 'ms-do-hide-others)
    (use-package applescript-mode
      :ensure t
      :mode ("\\.applescript" . applescript-mode))
    ;; (use-package osx-plist
    ;;   :ensure t)
    (use-package osx-trash
      :ensure t
      :config (osx-trash-setup))
    (use-package grab-mac-link
      :ensure t
      :bind (:map org-mode-map ("C-c g" . grab-mac-link))))

#+end_src

* Basic defaults 
Some basic defaults and customizations 

** Disabled Features 

#+begin_src emacs-lisp :tangle tangle-init.el
  (when (fboundp 'tool-bar-mode)
      (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))

#+end_src

** Zap up to char

#+begin_src emacs-lisp :tangle tangle-init.el
  (autoload 'zap-up-to-char "misc"
    "Kill up to, but not including ARGth occurrence of CHAR." t)

  (global-set-key (kbd "M-z") 'zap-up-to-char)  

#+end_src

** Enable some useful minor modes
*** uniquify

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package uniquify
    :demand t
    :init (setq uniquify-buffer-name-style 'post-forward-angle-brackets))

#+end_src

*** saveplace

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package saveplace
    :demand t
    :init 
    (setq save-place-file (expand-file-name ".saveplace" user-emacs-directory))
    :config
    (save-place-mode 1))

#+end_src

*** paren

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package paren
    :demand t
    :config
    (setq show-paren-delay 0.1
          show-paren-highlight-openparen t
          show-paren-when-point-inside-paren t)
    (show-paren-mode 1))

#+end_src

*** delsel

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package delsel
    :demand
    :config
    (delete-selection-mode))

#+end_src

*** autorevert

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package autorevert
    :demand t
    :config
    (global-auto-revert-mode))

#+end_src

*** transient-mark-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (transient-mark-mode t)

#+end_src

*** global-prettify-symbols-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (when (fboundp 'global-prettify-symbols-mode)
    (global-prettify-symbols-mode))

#+end_src

*** yes-or-no-p

#+begin_src emacs-lisp :tangle tangle-init.el
  (fset 'yes-or-no-p 'y-or-n-p)

#+end_src
  
** Enable some disabled modes

#+begin_src emacs-lisp :tangle tangle-init.el
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-defun 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)

#+end_src

** Set some setq defaults

#+begin_src emacs-lisp :tangle tangle-init.el
  (setq
   apropos-do-all t
   auth-sources '("~/.authinfo.gpg" "~/.authinfo" "~/.netrc")
   backup-directory-alist `(("." . ,(concat user-emacs-directory "backups")))
   delete-by-moving-to-trash t
   ediff-window-setup-function 'ediff-setup-windows-plain
   eldoc-idle-delay 1.5
   inhibit-startup-message t
   line-move-visual nil
   load-prefer-newer t
   ;; max-mini-window-height 0.50
   message-log-max 2048
   require-final-newline t
   save-interprogram-paste-before-kill t
   visible-bell t
   select-enable-clipboard t
   select-enable-primary t
   show-paren-delay 0
   show-paren-style 'mixed
   tab-always-indent 'complete
   truncate-lines t)

#+end_src

** Set some setq-defaults

#+begin_src emacs-lisp :tangle tangle-init.el
  (setq-default
   ansi-color-for-comint-mode t
   bidi-display-reordering nil ; disable bidirectional text for tiny perf boost
   blink-matching-paren nil    ; don't blink--too distracting
   compilation-always-kill t        ; kill compilation process before starting another
   compilation-ask-about-save nil   ; save all buffers on `compile'
   compilation-scroll-output 'first-error
   confirm-nonexistent-file-or-buffer t
   fill-column 80
   frame-resize-pixelwise t
   image-animate-loop t
   indent-tabs-mode nil
   indicate-buffer-boundaries nil
   indicate-empty-lines nil
   mode-line-default-help-echo nil ; disable mode-line mouseovers
   mouse-yank-at-point t           ; middle-click paste at point, not at click
   pos-tip-internal-border-width 6
   pos-tip-border-width 1
   ring-bell-function #'ignore
   save-place t
   show-help-function nil          ; hide :help-echo text
   show-trailing-whitespace nil
   tab-width 4
   use-dialog-box nil              ; always avoid GUI
   visible-bell nil
   x-stretch-cursor nil)

#+end_src

* Mode Line
** Hide modeline

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package hide-mode-line
    :ensure t
    :config
    (add-hook 'completion-list-mode-hook #'hide-mode-line-mode)
    (add-hook 'Man-mode-hook #'hide-mode-line-mode))

#+end_src

** doom-modeline

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package doom-modeline
    :ensure t
    :hook (after-init . doom-modeline-mode)
    :config
    (setq  doom-modeline-height 20
           doom-modeline-buffer-file-name-style 'truncate-all))

#+end_src

* Fonts

Set the default font

** Font Variables

#+begin_src emacs-lisp :tangle tangle-init.el
  (defvar tx-font (font-spec :family "Fira Code" :size 24))
  (defvar tx-variable-pitch-font (cond
                                  (*is-a-mac* (font-spec :family "Helvetica"))
                                  ((string= system-name "tim-desktop")
                                   (font-spec :family "Noto Sans"))
                                  (t (font-spec :family "DejaVu Serif"))))

  (defvar tx-serif-font (cond
                         (*is-a-mac* (font-spec :family "Times"))
                         ((string= system-name "tim-desktop")
                          (font-spec :family "Noto Serif Display"))
                         (t (font-spec :family "DejaVu Serif"))))

  (defvar tx-unicode-font
    (if *is-a-mac*
        (font-spec :family "Apple Color Emoji")
      (font-spec :family "Noto Color Emoji")))

#+end_src

** Set Fonts

#+begin_src emacs-lisp :tangle tangle-init.el
  (set-face-attribute 'default nil :font tx-font)
  (set-face-attribute 'fixed-pitch-serif nil :font tx-serif-font)
  (set-face-attribute 'variable-pitch nil :font tx-variable-pitch-font)
  (set-fontset-font t 'unicode tx-unicode-font nil 'prepend)

  (when *is-a-mac*
    (mac-auto-operator-composition-mode))

#+end_src

** Font Scaling

Setup some font scaling support

#+begin_src emacs-lisp :tangle no
  (use-package default-text-scale
    :ensure t
    :config
    (bind-key "C-M-=" 'default-text-scale-increase)
    (bind-key "C-M--" 'default-text-scale-decrease))

#+end_src

** Emoji

Setup emoji support

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package emojify
    :ensure t
    :config
    (setq
     emojify-company-tooltips-p nil
     emojify-display-style 'unicode
     emojify-program-contexts '(comments string))
    :init
    (add-hook 'after-init-hook #'global-emojify-mode))

#+end_src

* Commands et. al 
Some basic configuration relating to commands 

** Exec Path
Set up the exec path for emacs

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package exec-path-from-shell
    :ensure t
    :init
    (setq exec-path-from-shell-check-startup-files nil)
    :config
    (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID"
                   "GPG_AGENT_INFO" "LANG" "LC_CTYPE"))
      (add-to-list 'exec-path-from-shell-variables var))
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))

#+end_src

** Browse Kill Ring

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package browse-kill-ring
    :ensure t
    :init
    (setq browse-kill-ring-separator "\f")
    :config
    (progn
      (bind-key "C-g" 'browse-kill-ring-quit browse-kill-ring-mode-map)
      (bind-key "M-n" 'browse-kill-ring-forward browse-kill-ring-mode-map)
      (bind-key "M-p" 'browse-kill-ring-previous browse-kill-ring-mode-map)
      (bind-key "M-Y" 'browse-kill-ring)))

#+end_src

** Undo Tree

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :config
    (global-undo-tree-mode))

#+end_src

** Ido Mode

*** ido

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package ido
    :demand t
    :init
    (setq ido-enable-flex-matching t
          ido-everywhere t
          ido-use-filename-at-point nil
          ido-auto-merge-work-directories-length 0
          ido-use-virtual-buffers t
          ido-create-new-buffer 'always
          ido-file-extensions-order '(".org" ".txt" ".clj" ".cljs" ".py" 
                                      ".emacs" ".xml" ".el" ".cfg" ".cnf")
          ido-default-buffer-method 'selected-window
          ido-enable-dot-prefix t)

    :config
    (ido-mode 1))

#+end_src

*** ido-completing-read+

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package ido-completing-read+
    :ensure t
    :config
    (ido-ubiquitous-mode t))

#+end_src

** SMEX

#+begin_src emacs-lisp :tangle tangle-init.el
    (use-package smex
      :ensure t
      :demand t
      :init (setq smex-save-file (expand-file-name ".smex-items" user-emacs-directory))
      :bind (("M-x" . smex)
             ("M-X" . smex-major-mode-commands)
             ("C-c C-c M-x" . execute-extended-command))
      :config (smex-initialize))

#+end_src

** IBuffer Mode

*** ibuffer

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package ibuffer
    :commands 'ibuffer
    :config
    (progn 
      (define-ibuffer-column size-h
        (:name "Size" :inline t)
        (cond
         ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
         ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
         (t (format "%8d" (buffer-size)))))
      (bind-key "C-x C-b" 'ibuffer)))

#+end_src

*** ibuffer-vc

#+begin_src emacs-lisp :tangle no
  (use-package ibuffer-vc
    :ensure t
    :init
    (setq ibuffer-filter-group-name-face 'font-lock-doc-face
          ibuffer-formats '((mark modified read-only vc-status-mini " "
                                  (name 18 18 :left :elide)
                                  " "
                                  (size-h 9 -1 :right)
                                  " "
                                  (mode 16 16 :left :elide)
                                  " "
                                  filename-and-process)
                            (mark modified read-only vc-status-mini " "
                                  (name 18 18 :left :elide)
                                  " "
                                  (size-h 9 -1 :right)
                                  " "
                                  (mode 16 16 :left :elide)
                                  " "
                                  (vc-status 16 16 :left)
                                  " "
                                  filename-and-process)))
    :config
    (defun ibuffer-set-up-preferred-filters ()
      (ibuffer-vc-set-filter-groups-by-vc-root)
      (unless (eq ibuffer-sorting-mode 'filename/process)
        (ibuffer-do-sort-by-filename/process)))
    (add-hook 'ibuffer-hook 'ibuffer-set-up-preferred-filters))

#+end_src

** Recentf

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package recentf
    :init
    (setq recentf-max-saved-items 50)
    :config
    (defun ido-recentf-open ()
      "Use `ido-completing-read' to \\[find-file] a recent file"
      (interactive)
      (if (find-file (ido-completing-read "Find recent file: " recentf-list))
          (message "Opening file...")
        (message "Aborting")))
    (recentf-mode)
    (bind-key "C-x C-r" 'ido-recentf-open))

#+end_src

** Counsel

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package counsel
    :ensure t
    :bind (("C-x C-m" . counsel-M-x)
           ("C-h f" . counsel-describe-function)
           ("C-h v" . counsel-describe-variable)
           ("M-i" . counsel-imenu)
           ("C-c i" . counsel.unicode-char)
           :map read-expression-map
           ("C-r" . counsel-expression-history)))

#+end_src

** Swiper

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package swiper
    :ensure t
    :bind ("C-s".  swiper))

#+end_src

** Free Keys
The ~free-keys~ package provides a convenient way to identify keys which are
potential bind candidates. Combine this with the ~describe-personal-keybindings~
function from the ~bind-keys~ package and you can go to town with customising
your emacs!

#+begin_src emacs-lisp :tangle no
  (use-package free-keys
    :ensure t
    :commands (free-keys))

#+end_src 

* Editing 
  Text editing stuff

** Basic Tweaks 
Some simple functions and bindings stolen from [[http://github.com/purcell/emacs.d]]
which adds some editing tweaks

*** Linie editing tweaks

#+begin_src emacs-lisp :tangle tangle-init.el
  (bind-key "RET" 'newline-and-indent)

  (defun tx/newline-at-end-of-line ()
    "Move to end of line, enter a newline, and reindent."
    (interactive)
    (move-end-of-line 1)
    (newline-and-indent))

  (bind-key "S-RET" 'tx/newline-at-end-of-line)

  (bind-key "C-c j" 'join-line)

  (bind-key "C-c J" (lambda ()
                     (interactive)
                     (join-line 1)))

  (defun kill-back-to-indentation ()
    "Kill from point back to the first non-whitespace character on the line."
    (interactive)
    (let ((prev-pos (point)))
      (back-to-indentation)
      (kill-region (point) prev-pos)))

  (bind-key "<C-M-backspace>" 'kill-back-to-indentation)

  (defun tx/open-line-with-reindent (n)
    "A version of `open-line' which reindents the start and end positions.
        If there is a fill prefix and/or a `left-margin', insert them
        on the new line if the line would have been blank.
        With arg N, insert N newlines."
    (interactive "*p")
    (let* ((do-fill-prefix (and fill-prefix (bolp)))
           (do-left-margin (and (bolp) (> (current-left-margin) 0)))
           (loc (point-marker))
           ;; Don't expand an abbrev before point.
           (abbrev-mode nil))
      (delete-horizontal-space t)
      (newline n)
      (indent-according-to-mode)
      (when (eolp)
        (delete-horizontal-space t))
      (goto-char loc)
      (while (> n 0)
        (cond ((bolp)
               (if do-left-margin (indent-to (current-left-margin)))
               (if do-fill-prefix (insert-and-inherit fill-prefix))))
        (forward-line 1)
        (setq n (1- n)))
      (goto-char loc)
      (end-of-line)
      (indent-according-to-mode)))

  (bind-key "C-o" 'tx/open-line-with-reindent)

#+end_src

*** Page Break Lines
 Display lines to show where page breaks are. Useful in making the
 browse-kill-ring mode look a little better. See [[https://github.com/purcell/page-break-lines][page-break-lines on GitHub]]

 #+begin_src emacs-lisp :tangle no
   (use-package page-break-lines
     :ensure t
     :diminish page-break-lines-mode
     :config
     (progn 
       (global-page-break-lines-mode)
       (push 'browse-kill-ring-mode page-break-lines-modes)
       (push 'sql-mode page-break-lines-modes)
       (push 'text-mode page-break-lines-modes)))

 #+end_src

*** Move Or Duplicate Lines

 While this seems like a really handy utility, I find I never seem to use it, so
 commenting it out for now.

 #+begin_src emacs-lisp :tangle tangle-init.el
   (use-package move-dup
     :ensure t
     :commands (md/move-lines-up
               md/move-lines-down
               md/duplicate-down
               md/duplicate-up)
     :bind (("M-S-<up>" . md/move-lines-up)
            ("M-S-<down>" . md/move-lines-down)
            ("C-c p" . md/duplicate-down)
            ("C-c P" . md/duplicate-up)))

 #+end_src

*** Whole Line or Region
 Allow region oriented commands to work on the current line if no region is
 defined.

 #+begin_src emacs-lisp :tangle tangle-init.el
   (use-package whole-line-or-region
     :ensure t
     :delight
     :config
     (progn
       (whole-line-or-region-mode t)
       ;;(make-variable-buffer-local 'whole-line-or-region-mode)
       ))

 #+end_src

** Filling et. al. 

*** Enable fill mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (add-hook 'text-mode-hook 'turn-on-auto-fill)

#+end_src

*** Unfill mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package unfill
    :ensure t
    :commands (unfill-paragraph unfill-region unfill-toggle))

#+end_src

*** Fill Column Indicator

Stopped using this package as it is not compatible with org src block editing

#+begin_src emacs-lisp :tangle no
    (use-package fill-column-indicator
      :ensure t
      :diminish fci-mode
      :init
      (setq fci-rule-width 3)
      :config
      (progn
        (add-hook 'prog-mode-hook (lambda () (fci-mode +1)))
        (add-hook 'text-mode-hook (lambda () (fci-mode +1)))
        (add-hook 'org-mode-hook (lambda () (fci-mode +1)))))

#+end_src

** Whitespace Cleanup
Cleanup whitespace

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package whitespace-cleanup-mode
    :ensure t
    :diminish whitespace-cleanup-mode
    :init
    (setq whitespace-cleanup-mode-only-if-initially-clean nil
          whitespace-line-column 80
          whitespace-style '(face lines-tail))
    :config
    (add-hook 'prog-mode-hook #'whitespace-mode)
    (add-hook 'prog-mode-hook #'whitespace-cleanup-mode)
    (add-hook 'text-mode-hook #'whitespace-mode)
    (add-hook 'text-mode-hook #'whitespace-cleanup-mode)
    (add-hook 'org-mode-hook #'whitespace-mode))

#+end_src

** Fix the mark
Enable setting of mark without setting of transient mark mode. While this seems
like a good idea, I don't seem to use it. Commenting it out for now.

#+begin_src emacs-lisp :tangle no
  (defun push-mark-no-activate ()
    "Pushes `point' to `mark-ring' and does not activate the region
     Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
    (interactive)
    (push-mark (point) t nil)
    (message "Pushed mark to ring"))

  (bind-key "C-`" 'push-mark-no-activate)

  (defun jump-to-mark ()
    "Jumps to the local mark, respecting the `mark-ring' order.
    This is the same as using \\[set-mark-command] with the prefix argument."
    (interactive)
    (set-mark-command 1))

  (bind-key "M-`" 'jump-to-mark)

  (defun exchange-point-and-mark-no-activate ()
    "Identical to \\[exchange-point-and-mark] but will not activate the region."
    (interactive)
    (exchange-point-and-mark)
    (deactivate-mark nil))

  (bind-key [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)
#+end_src

** Searching
Using ~ag~ package for searches. This needs some OS support

  - On Linux ~apt-get install silversearcher-ag~
  - On OSX ~brew install the_silver_searcher~

*** ag

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package ag
    :ensure t
    :commands
    (ag ag-files ag-regex ag-project ag-project-files ag-project-regexp)
    :config
    (bind-key "M-?" 'ag-project))

#+end_src

** Templates
*** yasnippet

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package yasnippet
    :ensure t
    :init
    (setq yas-prompt-functions '(yas-dropdown-prompt
                                 yas-ido-prompt))
    :config
    (progn
      (unbind-key "<tab>" yas-minor-mode-map)
      (unbind-key "TAB" yas-minor-mode-map)
      (bind-key "C-M-/" 'yas-expand yas-minor-mode-map)
      ;;(yas-load-directory "~/.emacs.d/snippets")
      (yas-global-mode 1)))

#+end_src

*** yasnippet-snippets

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package yasnippet-snippets
    :ensure t)

#+end_src

** Completions
*** Set completion style

#+begin_src emacs-lisp :tangle tangle-init.el
  (add-to-list 'completion-styles 'initials t)

#+end_src

*** Company
**** Company

 #+begin_src emacs-lisp :tangle tangle-init.el
   (use-package company
     :ensure t
     :init
     (setq company-idle-delay 3.0
           company-selection-wrap-around t)
     :bind (("C-M-i" . company-complete)
            ("TAB" . company-indent-or-complete-common))
     :config
     (global-company-mode 1)
     (dolist (backend '(company-eclim company-semantic))
       (delq backend company-backends)))

 #+end_src

**** company-auctex

 #+begin_src emacs-lisp :tangle tangle-init.el
   (use-package company-auctex
     :ensure t
     :config
     (company-auctex-init))

 #+end_src

**** company-quickhelp

 #+begin_src emacs-lisp :tangle tangle-init.el
   (use-package company-quickhelp
     :ensure t
     :config
     (company-quickhelp-mode 1))

 #+end_src

**** company-web

 #+begin_src emacs-lisp :tangle tangle-init.el
   (use-package company-web
     :ensure t
     :config
     (add-to-list 'company-backends 'company-web-html)
     (add-to-list 'company-backends 'company-web-jade)
     (add-to-list 'company-backends 'company-web-slim))

 #+end_src

*** Hippie Expand

 #+begin_src emacs-lisp :tangle tangle-init.el
   (use-package hippie-expand
     :init
     (setq hippie-expand-try-functions-list
           '(try-expand-dabbrev
             try-expand-dabbrev-all-buffers
             try-expand-dabbrev-from-kill
             try-flyspell
             try-complete-file-name-partially
             try-complete-file-name))
      :bind ("M-/" . hippie-expand))

 #+end_src

** Outlining 

Some addditional outlining support to make more things work like org-mode.

*** Narrow/widern

#+begin_src emacs-lisp :tangle no
  (defun tx/narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows
  intelligently.  Intelligently means: region, org-src-block,
  org-subtree, or defun, whichever applies first.  Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((and (boundp 'org-src-mode) org-src-mode (not p))
           (org-edit-src-exit))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'prog-mode) (narrow-to-defun))
          (t (error "Please select a region to narrow to"))))

  (eval-after-load 'org-src
    '(bind-key "C-x C-s" 'org-edit-src-exit org-src-mode-map))
#+end_src

*** Outshine

#+begin_src emacs-lisp :tangle no
  (use-package outline
    :config
    (defvar outline-minor-mode-prefix "\M-#"))

  (use-package outorg
    :ensure t)

  (use-package outshine
    :ensure t
    :init
    (setq outshine-use-speed-commands t)
    :config
    (add-hook 'emacs-lisp-mode-hook 'outshine-mode)
    (add-hook 'clojure-mode-hook 'outshine-mode)
    (add-hook 'jst-mode-hook 'outshine-mode)
    (add-hook 'message-mode-hook 'outshine-mode))

  (use-package navi-mode
    :ensure t)

#+end_src

*** orgalist

#+begin_src emacs-lisp :tangle no
  (use-package orgalist
    :ensure t
    :init
    (add-hook 'message-mode 'orgalist-mode))

#+end_src

*** hideshow

#+begin_src emacs-lisp :tangle no
  (use-package hideshow
    :ensure t
    :hook ((prog-mode . hs-minor-mode)))

  (defun tx/toggle-fold ()
    (interactive)
    (save-excursion
      (end-of-line)
      (hs-toggle-hiding)))

#+end_src

*** origami

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package origami
    :ensure t
    :bind (:map origami-mode-map
           ("C-c f" . origami-recursively-toggle-node)
           ("C-c F" . origami-toggle-all-nodes))
    :commands (origami-mode))

#+end_src

* Programming Tweaks 

Configuration relating to programming

** Highlight Symbol Mode

Highlight symbols and enable navigation by symbol in programming modes. See
[[http://nschum.de/src/emacs/highlight-symbol/]].

#+begin_src emacs-lisp :tangle no
  (use-package highlight-symbol
    :ensure t
    :diminish highlight-symbol-mode
    :config
    (progn 
      (dolist (hook '(prog-mode-hook html-mode-hook css-mode-hook))
        (add-hook hook 'highlight-symbol-mode)
        (add-hook hook 'highlight-symbol-nav-mode))
      (defadvice highlight-symbol-temp-highlight (around sanityinc/maybe-suppress
                                                         activate)
        "Suppress symbol highlighting while isearching."
        (unless (or isearch-mode
                    (and (boundp 'multiple-cursors-mode)
                         multiple-cursors-mode))
          ad-do-it))))

#+end_src

** Electric Pair Mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (when (fboundp 'electric-pair-mode)
    (electric-pair-mode))

#+end_src

** Goto Address

Lets make addresses action buttons when we find them in comments in
programming buffers

#+begin_src emacs-lisp :tangle no
  (dolist (hook (if (fboundp 'prog-mode)
                    '(prog-mode-hook ruby-mode-hook)
                  '(find-file-hooks)))
    (add-hook hook 'goto-address-prog-mode))

#+end_src

** Rainbow Mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package rainbow-mode
    :ensure t
    :delight
    :config
    (add-hook 'prog-mode-hook 'rainbow-mode)
    (add-hook 'ielm-mode-hook 'rainbow-mode)
    (add-hook 'lisp-interaction-mode-hook 'rainbow-mode)
    (add-hook 'emacs-lisp-mode-hook 'rainbow-mode))

#+end_src

** Rainbow Delimiters 

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package rainbow-delimiters 
    :ensure t
    :delight
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'ielm-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'lisp-interaction-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))

#+end_src

** Paredit 

This mode was a little tricky at first, but now I'm use to it, I miss it when
it isn't there. 

There are some issues with using this mode in conjunction with emacspeak. Need
to add some paredit specific advice to provide speech feedback for this mode.

*** paredit

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package paredit
    :ensure t
    :diminish paredit-mode
    :init
    (progn 
      (defun maybe-map-paredit-newline ()
        (unless (or (memq major-mode '(inferior-emacs-lisp-mode
                                       cider-repl-mode))
                    (minibufferp))
          (local-set-key (kbd "RET") 'paredit-newline)))
      (add-hook 'paredit-mode-hook 'maybe-map-paredit-newline))
    :config
    (progn 
      (defvar paredit-minibuffer-commands '(eval-expression
                                            pp-eval-expression
                                            eval-expression-with-eldoc
                                            ibuffer-do-eval
                                            ibuffer-do-view-and-eval)
        "Interactive commands where paredit should be enabled in minibuffer.")
      (defun conditionally-enable-paredit-mode ()
        "Enable paredit during lisp-related minibuffer commands."
        (if (memq this-command paredit-minibuffer-commands)
            (enable-paredit-mode)))
      (add-hook 'minibuffer-setup-hook 'conditionally-enable-paredit-mode)
      (dolist (binding (list (kbd "C-<left>") (kbd "C-<right>")
                             (kbd "C-M-<left>") (kbd "C-M-<right>")))
        (define-key paredit-mode-map binding nil))

      ;; Modify kill-sentence, which is easily confused with the kill-sexp
      ;; binding, but doesn't preserve sexp structure
      (bind-key [remap kill-sentence] 'paredit-kill paredit-mode-map)
      (bind-key [remap backward-kill-sentence] nil paredit-mode-map)
      (add-hook 'lisp-mode-hook #'enable-paredit-mode)
      (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
      (add-hook 'clojure-mode-hook #'enable-paredit-mode)
      (add-hook 'cider-repl-mode-hook #'enable-paredit-mode)
      (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
      (add-hook 'ielm-mode-hook #'enable-paredit-mode)))

#+end_src

*** paredit-everywhere

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package paredit-everywhere
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'paredit-everywhere-mode))

#+end_src

** Smartparens
Not sure I like this mode compared to paredit. Disabling it for now.

#+begin_src emacs-lisp :tangle no
  (use-package smartparens-config
    :ensure smartparens
    :config
    (progn
      (sp-use-smartparens-bindings)
      (smartparens-global-mode)
      (show-smartparens-global-mode))
    (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
    (add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode))

#+end_src

** Imenu

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package imenu-anywhere
    :ensure t)

#+end_src

** Line numbers

#+begin_src emacs-lisp :tangle tangle-init.el
  (add-hook 'prog-mode-hook (lambda ()
                              (display-line-numbers-mode)
                              (line-number-mode)
                              (column-number-mode)))

#+end_src

** Flycheck Mode

*** flycheck

#+begin_src emacs-lisp :tangle tangle-init.el
  (defvar tx-flycheck-lazy-idle-delay 3.0
    "The delay before flycheck checks the buffer, after a check that produces no
  errors.")

  (use-package flycheck
    :ensure t
    :commands (flycheck-list-errors flycheck-buffer)
    :config
    (setq flycheck-check-syntax-automatically
          (delq 'new-line flycheck-check-syntax-automatically)
          flycheck-emacs-lisp-load-path 'inherit)

    (defun tx-flycheck-adjust-syntax-check-eagerness ()
      "Check for errors less often when there aren't any."
      (if flycheck-current-errors
          (kill-local-variable 'flycheck-idle-change-delay)
        (setq-local flycheck-idle-change-delay tx-flycheck-lazy-idle-delay)))

    (add-hook 'flycheck-after-syntax-check-hook
              #'+flycheck|adjust-syntax-check-eagerness)

    (setq-default flycheck-disabled-checkers
                  (append flycheck-disabled-checkers
                          '(javascript-jshint)))

    (setq flycheck-display-errors-function
          #'flycheck-display-error-messages-unless-error-list)
    (global-flycheck-mode +1))

#+end_src

*** flycheck-color-mode-line

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package flycheck-color-mode-line
    :ensure t

    :config
    (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode))

#+end_src

** Highlight Indentation 

Highlight the indentation level in programming modes.

There are a few modes which provide this type of functionality. Experimenting
with two of them ~highlight-indentation~ and ~highlight-indent-guide~. Problem
is that highlight-indent-guide looks better, but causes some problems with some
modes (like org's edit block mode). It can also be a pain with TTS. On the other
hand ~highlight-indentation~ does not cause problems with other modes, but is
ugly.


Can't wait until Emacs has this as native functionality, which should be at a
layer which does not mess with editing etc.

#+begin_src emacs-lisp :tangle no
  (use-package highlight-indentation
    :ensure t
    :config
    (add-hook 'prog-mode-hook #'highlight-indentation-current-column-mode))

#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package highlight-indent-guides
    :ensure t
    :hook ((prog-mode text-mode conf-mode) . highlight-indent-guides-mode)
    :init
    (setq highlight-indent-guides-method 'character)
    :config
    (add-hook 'focus-in-hook #'highlight-indent-guides-auto-set-faces)

    (defun tx/indent-guides-disable-maybe ()
      (when highlight-indent-guides-mode
        (highlight-indent-guides-mode -1)))
    ;; `highlight-indent-guides' breaks in these modes
    (add-hook 'visual-line-mode-hook #'tx/indent-guides-disable-maybe)
    (add-hook 'org-indent-mode-hook #'tx/indent-guides-disable-maybe))

#+end_src

** ediff

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package ediff
    :defer t
    :init
    (setq ediff-diff-options "-w" ; turn off whitespace checking
          ediff-split-window-function #'split-window-horizontally
          ediff-window-setup-function #'ediff-setup-windows-plain)
    :config
    (defvar tx--ediff-saved-wconf nil)
    ;; Restore window config after quitting ediff
    (defun tx|ediff-save-wconf ()
      (setq tx--ediff-saved-wconf (current-window-configuration)))
    (add-hook 'ediff-before-setup-hook #'tx|ediff-save-wconf)

    (defun tx|ediff-restore-wconf ()
      (when (window-configuration-p tx--ediff-saved-wconf)
        (set-window-configuration tx--ediff-saved-wconf)))
    (add-hook 'ediff-quit-hook #'tx|ediff-restore-wconf 'append)
    (add-hook 'ediff-suspend-hook #'tx|ediff-restore-wconf 'append))

#+end_src

** diff-hl 

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package diff-hl
    :ensure t
    :config
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
    (add-hook 'dired-mode-hook 'diff-hl-dir-mode)
    (add-hook 'after-init-hook 'global-diff-hl-mode))

#+end_src

** Quickrun

#+begin_src emacs-lisp :tangle no
  (use-package quickrun
    :ensure t
    :commands (quickrun)
    :init
    (setq
     eval-expression-print-length nil
     eval-expression-print-level  nil)
    :config
    (setq quickrun-focus-p nil)

    (defun tx-quickrun-auto-close (&rest _)
      "Allows us to silently re-run quickrun from within the quickrun buffer."
      (when-let (win (get-buffer-window quickrun--buffer-name))
        (let ((inhibit-message t))
          (quickrun--kill-running-process)
          (message ""))
        (delete-window win)))
    (advice-add #'quickrun :before #'tx-quickrun-auto-close)
    (advice-add #'quickrun-region :before #'tx-quickrun-auto-close)
  
    (defun tx-quickrun-shrink-window ()
      "Shrink the quickrun output window once code evaluation is complete."
      (when-let (win (get-buffer-window quickrun--buffer-name))
        (with-selected-window (get-buffer-window quickrun--buffer-name)
          (let ((ignore-window-parameters t))
            (shrink-window-if-larger-than-buffer)))))
    (add-hook 'quickrun-after-run-hook #'tx-quickrun-shrink-window)

    (defun tx-quickrun-scroll-to-bof ()
      "Ensures window is scrolled to BOF on invocation."
      (when-let (win (get-buffer-window quickrun--buffer-name))
        (with-selected-window win
          (goto-char (point-min)))))
    (add-hook 'quickrun-after-run-hook #'tx-quickrun-scroll-to-bof))

#+end_src

** Projectile 

 #+begin_src emacs-lisp :tangle tangle-init.el
   (use-package projectile
     :ensure t
     :delight '(:eval (concat " " (projectile-project-name)))
     ;;:diminish projectile-mode
     ;; :commands (projectile-mode
     ;;            projectile-mode)
     :bind (:map projectile-mode-map ("C-c p" . projectile-command-map))
     :init
     ;; (add-hook 'prog-mode-hook 'projectile-mode)
     (projectile-mode +1))

 #+end_src

** lsp-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package lsp-mode
    :ensure t
    :hook (prog-mode-hook . lsp-deferred)
    :commands (lsp lsp-deferred)
    :config
    (add-to-list 'lsp-language-id-configuration '(clojure-mode . "clojure-mode"))
    :init
    (setq lsp-enable-indentation nil))

  (use-package company-lsp
    :ensure t
    :commands company-lsp)

#+end_src

* Utility Modes 
** Spelling

When running on OSX it is necessary to

  - Install a spell checker. I prefer to use /homebrew/ to install both emacs and
    associated programs i.e
    : brew install hunspell

  - Note that you also need to install the dictionaries. I use the dictionaries from
    openOffice. These are distributed in /*.oxt/ files, which are just /zip/
    archives. Unzip them and put the /*.aff/ and /*.dic/ files in
    /~/Library/Spelling/ directory.

  - I also setup symbolic links from the dictionaries I want to /default.aff/
    and /default.dic/

#+begin_src emacs-lisp :tangle tangle-init.el
    (when *spell-check-support-enabled*
      (use-package ispell
        :init
        ;;; Spell checking using hunspell
        (setq ispell-local-dictionary-alist
              '((nil "[A-Za-z]" "[^A-Za-z]" "[']" t
                     ("-d" "en_US" "-i" "utf-8") nil utf-8)
                ("american"
                 "[A-Za-z]" "[^A-Za-z]" "[']" nil
                 ("-d" "en_US") nil utf-8)
                ("english"
                 "[A-Za-z]" "[^A-Za-z]" "[']" nil
                 ("-d" "en_GB") nil utf-8)
                ("en_GB"
                 "[A-Za-z]" "[^A-Za-z]" "[']" nil
                 ("-d" "en_GB") nil utf-8)
                ("en_AU"
                 "[A-Za-z]" "[^A-Za-z]" "[']" nil
                 ("-d" "en_AU") nil utf-8))
              ispell-extra-args '("-a" "-i" "utf-8")
              ispell-silently-savep t)
        (if *is-a-mac*
            (progn
              (setenv "DICPATH" (concat (getenv "HOME") "/Library/Spelling"))
              (setq ispell-dictionary "en_AU"
                    ispell-program-name "/usr/local/bin/hunspell"))
          ;;(setq ispell-dictionary "british-ise")
          (setq ispell-program-name "/usr/bin/hunspell"
                ispell-dictionary "en_AU"))
        :config
        (add-to-list 'ispell-skip-region-alist '("^#\\+begin_src ". "#\\+end_src$"))
        (add-to-list 'ispell-skip-region-alist '("^#\\+begin_src ". "#\\+end_src$"))
        (add-to-list 'ispell-skip-region-alist '("^#\\+begin_example ". "#\\+end_example$"))
        (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_EXAMPLE ". "#\\+END_EXAMPLE$"))
        (add-to-list 'ispell-skip-region-alist '("\:PROPERTIES\:$" . "\:END\:$"))
        (add-to-list 'ispell-skip-region-alist '("\\[fn:.+:" . "\\]"))
        (add-to-list 'ispell-skip-region-alist '("^http" . "\\]"))
        (add-to-list 'ispell-skip-region-alist '("=.*" . ".*="))
        (add-to-list 'ispell-skip-region-alist '("- \\*.+" . ".*\\*: "))
        (when (executable-find ispell-program-name)
          (use-package flyspell
            :diminish flyspell-mode
            :init
            (setq flyspell-use-meta-tab nil)
            (defun try-flyspell (arg)
              (if (nth 4 (syntax-ppss))
                  (call-interactively 'flyspell-correct-word-before-point)
                nil))
            :config
            (add-hook 'prog-mode-hook 'flyspell-prog-mode)
            (add-hook 'text-mode-hook 'flyspell-mode)))))

#+end_src

** Timestamps

Surprises me how often people ask for this functionality without realizing it is
already built-in.

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package time-stamp
     :init
     (setq time-stamp-active t
           time-stamp-format "%:a, %02d %:b %:y %02I:%02M %#P %Z"
           time-stamp-start "\\(Time-stamp:[         ]+\\\\?[\"<]+\\|Last Modified:[
              ]\\)"
           time-stamp-end "\\\\?[\">]\\|$"
           time-stamp-line-limit 10)
     :config
     (add-hook 'write-file-hooks 'time-stamp))

#+end_src

** Regex Tool

Add the handy ~regex-tool~ package

#+begin_src emacs-lisp :tangle no
  (use-package regex-tool
    :ensure t
    :commands (regex-tool))

#+end_src

** Crontab

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package crontab-mode
    :mode ("\\.?cron\\(tab\\)?\\'" . crontab-mode))

#+end_src

** CSV

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package csv-mode
    :ensure t
    :init
    (setq csv-separators '("," ";" "|" " "))
    :config
    :mode ("\\.[Cc][Ss][Vv]\\'" . csv-mode))

#+end_src

** Grep and Wgrep

The ~wgrep~ package allows for writing of grep buffers back to file. See [[http://github.com/mhayashi1120/Emacs-wgrep][wgrep
on GitHub]]

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package grep
    :init
    (setq-default grep-highlight-matches t
                 grep-scroll-output t)
    (when *is-a-mac* 
      (setq-default locate-command "mdfind"))
    :config
    (progn
        (use-package wgrep
          :ensure t)
        (add-hook 'grep-setup-hook 'wgrep-setup)))

#+end_src

** REST Client

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package restclient
    :ensure t)

#+end_src

** Alert

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package alert
    :ensure t
    :config
    (setq alert-fade-time 10)
    (when *is-a-mac*
      (setq alert-default-style 'growl))
    (setq alert-reveal-idle-time 120))

#+end_src

** Write Good

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package writegood-mode
    :ensure t
    :bind ("C-M-g" . writegood-mode))

#+end_src

** Lorem Ipsum 

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package lorem-ipsum
    :ensure t
    :commands (lorem-ipsum-insert-paragraph
               lorem-ipsum-insert-sentence
               lorem-ipsum-insert-list))

#+end_src

* Application Modes 
Modes relating to emacs applications 
 
** Calendar

Configure the calendar

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package calendar
    :init
    (setq calendar-date-style 'iso
          calendar-location-name "Armidale"
          calendar-longitude 151.617222
          calendar-mark-diary-entries-flag t
          calendar-mark-holidays-flag t
          calendar-time-zone 600
          calendar-view-holidays-initially-flag t
          icalendar-import-format "%s%l"
          icalendar-import-format-location " (%s)"
          icalendar-recurring-start-year 2013))

#+end_src

** Directory Edit

I like to have directories listed first. Easiest way to do this is use the
~ls-lisp~ library

*** dired

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package dired
    :init
    (setq dired-listing-switches "-la --group-directories-first"
          dired-auto-revert-buffer t
          dired-recursive-deletes 'always
          dired-recursive-copies 'always
          dired-dwim-target t)
    :config
    (require 'dired-x))

#+end_src

*** find-dired

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package find-dired
    :init
    (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld")))

#+end_src

** Stack Exchange

When I'm a bit bored or want a break from my own problems, I sometimes like to
look at stack overflow. See [[https://github.com/vermiculus/sx.el/][sx on GitHub]].

#+begin_src emacs-lisp :tangle no
  (use-package sx
    :ensure t
    :commands (sx-bug-report sx-authenticate sx-inbox sx-inbox-notifications
                             sx-org-get-link sx-ask sx-search
                             sx-search-tag-at-point sx-tab-all-questions
                             sx-tab-unanswered sx-tab-unanswered-my-tags
                             sx-tab-featured sx-tab-starred
                             sx-tab-frontpage sx-tab-newest
                             sx-tab-topvoted sx-tab-hot
                             sx-tab-week sx-tab-month))

#+end_src

** Version Control

Setup version control stuff

*** git-commit

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package git-commit
    :ensure t)
    :config
    (global-git-commit-mode)

#+end_src

*** git-timemachine

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package git-timemachine
    :ensure t
    :commands (git-timemachine-toggle git-timemachine 
               git-timemachine-switch-browser))

#+end_src

*** gitignore-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package gitignore-mode
    :ensure t)

#+end_src

*** magit

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package magit
    :ensure t
    :commands (magit-status magit-dispatch-popup)
    :bind (("C-x g" . magit-status)
           ("C-x M-g" . magit-dispatch-popup)))

#+end_src

*** magit-popup

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package magit-popup
    :ensure t)

#+end_src

** ERC

*** erc

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package erc
    :commands 'erc
    :preface
    (defun tx/erc-browse-last-url ()
      "Searchs backwards through an ERC buffer, looking for a URL. When a URL is
       found, it prompts you to open it."
      (interactive)
      (save-excursion
        (let ((ffap-url-regexp "\\(https?://\\)."))
          (ffap-next-url t t))))

    (defun tx/erc-count-users ()
      "Displays the number of users and ops connected on the current channel."
      (interactive)
      (if (get-buffer "irc.freenode.net:6667")
          (let ((channel (erc-default-target)))
            (if (and channel (erc-channel-p channel))
                (let ((hash-table (with-current-buffer (erc-server-buffer)
                                    erc-server-users))
                      (users 0)
                      (ops 0))
                  (maphash (lambda (k v)
                             (when (member (current-buffer)
                                           (erc-server-user-buffers v))
                               (incf users))
                             (when (erc-channel-user-op-p k)
                               (incf ops)))
                           hash-table)
                  (message "%d users (%s ops) are online on %s" users ops channel))
              (user-error "The current buffer is not a channel")))
        (user-error "You must first be connected on IRC")))

    (defun tx/erc-get-ops ()
      "Displays the names of ops users on the current channel."
      (interactive)
      (if (get-buffer "irc.freenode.net:6667")
          (let ((channel (erc-default-target)))
            (if (and channel (erc-channel-p channel))
                (let (ops)
                  (maphash (lambda (nick cdata)
                             (if (and (cdr cdata)
                                      (erc-channel-user-op (cdr cdata)))
                                 (setq ops (cons nick ops))))
                           erc-channel-users)
                  (if ops
                      (message "The online ops users are: %s"  (mapconcat 'identity ops " "))
                    (message "There are no ops users online on %s" channel)))
              (user-error "The current buffer is not a channel")))
        (user-error "You must first be connected on IRC")))

    (defun tx/erc-notify (nickname message)
      "Displays a notification message for ERC."
      (let* ((channel (buffer-name))
             (nick (erc-hl-nicks-trim-irc-nick nickname))
             (title (if (string-match-p (concat "^" nickname) channel)
                        nick
                      (concat nick " (" channel ")")))
             (msg (s-trim (s-collapse-whitespace message))))
        (alert (concat nick ": " msg) :title title)))

    (defun tx/erc-preprocess (string)
      "Avoids channel flooding."
      (setq str (string-trim (replace-regexp-in-string "\n+" " " str))))

    (defun tx/erc-reset-track-mode ()
      "Resets ERC track mode."
      (interactive)
      (setq erc-modified-channels-alist nil)
      (erc-modified-channels-update)
      (erc-modified-channels-display)
      (force-mode-line-update))

    (defun tx/erc-start-or-switch ()
      "Connects to ERC, or switch to last active buffer."
      (interactive)
      (if (get-buffer "irc.freenode.net:6667")
          (erc-track-switch-buffer 1)
        (erc-tls :server "irc.freenode.net" :port 7070 :nick "theophilusx")))

    :hook ((ercn-notify . tx/erc-notify)
           (erc-send-pre . tx/erc-preprocess))
    :init
    (setq erc-autojoin-channels-alist '(("freenode.net" "#emacs" "#org-mode" 
                                         "#stumpwm" "#clojure" "#clojurescript"
                                         "#clojure-emacs"))
          erc-autojoin-delay 60 
          erc-autojoin-timing 'ident
          erc-fill-variable-maximum-indentation 5
          erc-hide-list '("JOIN" "PART" "QUIT")
          erc-insert-away-timestamp-function 'erc-insert-timestamp-right
          erc-insert-timestamp-function 'erc-insert-timestamp-right
          erc-join-buffer 'bury
          erc-kill-buffer-on-part t
          erc-kill-queries-on-quit t
          erc-kill-server-buffer-on-quit t
          erc-lurker-hide-list '("JOIN" "PART" "QUIT")
          erc-lurker-threshold-time 43200
          erc-nick "theophilusx"
          erc-prompt-for-nickserv-password nil
          erc-server-reconnect-attempts 5
          erc-server-reconnect-timeout 3
          erc-timestamp-format "[%H:%M] "
          erc-timestamp-only-if-changed-flag t
          erc-track-exclude-types '("JOIN" "MODE" "NICK" "PART" "QUIT")
          erc-truncate-mode t
          erc-user-full-name "Tim X")
    :config
    (add-to-list 'erc-modules 'notifications)
    (add-to-list 'erc-modules 'spelling)
    (add-to-list 'erc-modules 'autoaway)
    (erc-services-mode 1)
    (erc-update-modules)
    (add-hook
     'window-configuration-change-hook
     (lambda ()
       (setq erc-fill-column (- (window-width) 2)))))

#+end_src

*** erc-hl-nicks

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package erc-hl-nicks
    :ensure t
    :after erc)

#+end_src

*** erc-image

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package erc-image
    :ensure t
    :after erc)

#+end_src

** Eshell

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package eshell
    :commands 'eshell
    :init
    (setq eshell-buffer-shorthand t
          eshell-cmpl-ignore-case t
          eshell-cmpl-cycle-completions nil
          eshell-history-size 10000
          eshell-hist-ignoredups t
          eshell-error-if-no-glob t
          eshell-glob-case-insensitive t
          eshell-scroll-to-bottom-on-input 'all)
    :config
    (progn
      (defun jcf-eshell-here ()
        (interactive)
        (eshell "here"))

      (defun pcomplete/sudo ()
        (let ((prec (pcomplete-arg 'last -1)))
          (cond ((string= "sudo" prec)
                 (while (pcomplete-here*
                         (funcall pcomplete-command-completion-function)
                         (pcomplete-arg 'last) t))))))

      (add-hook 'eshell-mode-hook
                (lambda ()
                  (eshell/export "NODE_NO_READLINE=1")))))

#+end_src

** Elfeed

*** elfeed

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package elfeed
    :ensure t
    :init
    (setq elfeed-db-directory "~/Dropbox/.elfeed"
          elfeed-enclosure-default-dir "~/.emacs.d/elfeed"
          elfeed-save-multiple-enclosures-without-asking t)

    (defun elfeed-mark-all-as-read ()
      (interactive)
      (mark-whole-buffer)
      (elfeed-search-untag-all-unread))

    ;;functions to support syncing .elfeed between machines
    ;;makes sure elfeed reads index from disk before launching
    (defun tx/elfeed ()
      "Wrapper to load the elfeed db from disk before opening"
      (interactive)
      (elfeed-db-load)
      (elfeed)
      (elfeed-search-update--force))

    ;;write to disk when quiting
    (defun tx/elfeed-save-db-and-bury ()
      "Wrapper to save the elfeed db to disk before burying buffer"
      (interactive)
      (elfeed-db-save)
      (quit-window))

    (defhydra hydra-elfeed ()
     "filter"
     ("s" (elfeed-search-set-filter "@6-months-ago +sec +unread") "sec")
     ("n" (elfeed-search-set-filter "@6-months-ago +news +unread") "news")
     ("e" (elfeed-search-set-filter "@6-months-ago +emacs +unread") "emacs")
     ("p" (elfeed-search-set-filter "@6-months-ago +prog +unread") "programming")
     ("c" (elfeed-search-set-filter "@6-months-ago +clojure +unread") "clojure")
     ("*" (elfeed-search-set-filter "@6-months-ago +star") "Starred")
     ("u" (elfeed-search-set-filter "@6-months-ago +totag +unread") "un-tagged")
     ("f" (elfeed-search-set-filter "@6-months-ago +fun +unread") "fun")
     ("M" elfeed-toggle-star "Mark")
     ("A" (elfeed-search-set-filter "@6-months-ago") "All")
     ("T" (elfeed-search-set-filter "@1-day-ago +unread") "Today")
     ("Q" bjm/elfeed-save-db-and-bury "Quit Elfeed" :color blue)
     ("q" nil "quit" :color blue))
  
    :config
    (defalias 'elfeed-toggle-star
      (elfeed-expose #'elfeed-search-toggle-all 'star))
    :bind (:map elfeed-search-mode-map
	        ("q" . tx/elfeed-save-db-and-bury)
	        ("Q" . tx/elfeed-save-db-and-bury)
	        ("m" . elfeed-toggle-star)
	        ("M" . elfeed-toggle-star)
	        ("j" . hydra-elfeed/body)
	        ("J" . hydra-elfeed/body)))

#+end_src

*** elfeed-org

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package elfeed-org
    :ensure t
    :init
    (setq rmh-elfeed-org-files (list "~/Dropbox/org/my-feeds.org"))
    :config
    (elfeed-org))

#+end_src

** Gnuplot

#+begin_src emacs-lisp :tangle no
  (use-package gnuplot
    :ensure t)

#+end_src

* Keymaps

*** read-write-toggle

#+begin_src emacs-lisp :tangle tangle-init.el
  (defun tx/read-write-toggle ()
    "Toggles read-only in any relevant mode: ag-mode, Dired, or
  just any file at all."
    (interactive)
    (if (equal major-mode 'ag-mode)
        ;; wgrep-ag can support ag-mode
        (wgrep-change-to-wgrep-mode)
      ;; dired-toggle-read-only has its own conditional:
      ;; if the mode is Dired, it will make the directory writable
      ;; if it is not, it will just toggle read only, as desired
      (dired-toggle-read-only)))

#+end_src

*** Scratch

#+begin_src emacs-lisp :tangle tangle-init.el
  (defun tx/scratch ()
      (interactive)
      (switch-to-buffer-other-window (get-buffer-create "*scratch*")))

#+end_src

#+begin_src emacs-lisp :tangle tangle-init.el
  (defun tx/make-org-scratch ()
    (interactive)
    (find-file "~/Dropbox/org/scratch.org"))

#+end_src

** Toggle Map

#+begin_src emacs-lisp :tangle tangle-init.el
  (bind-keys :prefix-map toggle-map
             :prefix "C-x t"
             ("d" . toggle-debug-on-error)
             ("f" . tx/toggle-fold)
             ("l" . linum-mode)
             ("n" . tx/narrow-or-widen-dwim)
             ("o" . org-mode)
             ("r" . tx/read-write-toggle)
             ("t" . text-mode)
             ("w" . whitespace-mode))

#+end_src

** Launcher Map

#+begin_src emacs-lisp :tangle tangle-init.el
  (bind-keys :prefix-map launcher-map
             :prefix "C-x l"
             ("A" . terminal) ;; save "a" for open-agenda
             ("c" . calc)
             ("C" . calendar)
             ("d" . ediff-buffers)
             ("e" . eshell)
             ("E" . eww)
             ("h" . man)
             ("P" . proced)
             ("s" . tx/scratch)
             ("S" . tx/make-org-scratch))

  (if *is-a-mac*
    (use-package counsel-osx-app
      :bind (:map launcher-map
                  ("." . counsel-osx-app)))
    (bind-keys :map launcher-map
               ("." . counsel-linux-app)))

#+end_src

* Auctex 
 Use the ~auctex~ package for writing LaTeX.

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package tex
    :ensure auctex)

#+end_src

* Web 
** Htmlize
Add the ~htmlize~ package to provide an easy way to turn buffer contents into
HTML. See [[http://fly.srk.fer.hr/~hniksic/emacs/htmlize.git]].

#+begin_src emacs-lisp :tangle no
  (use-package htmlize
    :ensure t
    :commands (htmlize-buffer htmlize-region htmlize-file
                              htmlize-many-files htmlize-many-files-dired))
#+end_src

** Browse-url

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package browse-url
    :commands (browse-url-at-point
               browse-url-of-buffer
               browse-url-of-region
               browse-url
               browse-url-of-file)
    :init
    ;; (if *is-a-mac*
    ;;     (setq browse-url-browser-function 'browse-url-default-macosx-browser)
    ;;   (setq browse-url-browser-function 'eww-browse-url))
    (setq browse-url-browser-function 'eww-browse-url)
    (defhydra my-hydra-browse-url ()
      "Browse URL"
      ("." browse-url-at-point "at point")
      ("b" browse-url-of-buffer "buffer")
      ("r" browse-url-of-region "region")
      ("u" browse-url "URL")
      ("f" browse-url-of-file "File")
      ("d" emacspeak-wizards-unhex-uri "Decode")
      ("q" nil "Quit"))
    :bind ("<f6>" . my-hydra-browse-url/body))

#+end_src

** Markdown

*** markdown-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package markdown-mode
    :ensure t
    :defer t
    :commands (markdown-mode gfm-mode)
    :mode (("\\.markdown\\'" . markdown-mode)
           ("\\.md\\'" . markdown-mode)))

#+end_src

*** gh-md

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package gh-md
    :ensure t
    :commands (gh-md-render-buffer gh-md-render-region))

#+end_src

*** markdown-preview-eww

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package markdown-preview-eww
    :ensure t
    :commands (markdown-peview-eww))

#+end_src

*** markdown-toc

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package markdown-toc
    :ensure t
    :commands (markdown-toc-generate-toc))

#+end_src

* Programming Modes 
** Lua

No time for any Lua programming just now, so commenting out configuration as it
is not required at this time. 

#+begin_src emacs-lisp :tangle no
  (use-package lua-mode
    :ensure t
    :commands (lua-mode)
    :mode "\\.lua\\'"
    :interpreter "lua")

#+end_src

** Emacs Lisp
Configure lisp modes. 

*** elisp-slime-nav

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package elisp-slime-nav
    :ensure t
    ;; :diminish elisp-slime-nav-mode
    :config
    (dolist (hook '(emacs-lisp-mode-hook
                    ielm-mode-hook
                    lisp-mode-hook
                    clojure-mode-hook))
           (add-hook hook 'turn-on-elisp-slime-nav-mode)))

#+end_src

*** ipretty

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package ipretty
    :ensure t
    :init
    (defadvice pp-display-expression (after tx/make-read-only (expression out-buffer-name) activate)
      "Enable `view-mode' in the output buffer - if any - so it can be closed with `\"q\"."
      (when (get-buffer out-buffer-name)
        (with-current-buffer out-buffer-name
          (view-mode 1))))
    :config
    (add-hook 'emacs-lisp-mode-hook 'ipretty-mode))

#+end_src

*** Setup Emacs Lisp

#+begin_src emacs-lisp :tangle tangle-init.el
  (defun setup-hippie-expand-for-elisp ()
    "Locally set `hippie-expand' completion functions for use with Emacs Lisp."
    (make-local-variable 'hippie-expand-try-functions-list)
    (add-to-list 'hippie-expand-try-functions-list
                 'try-complete-lisp-symbol t)
    (add-to-list 'hippie-expand-try-functions-list
                 'try-complete-lisp-symbol-partially t))

  (defun tx/eval-last-sexp-or-region (prefix)
    "Eval region from BEG to END if active, otherwise the last sexp."
    (interactive "P")
    (if (and (mark) (use-region-p))
        (eval-region (min (point) (mark)) (max (point) (mark)))
      (pp-eval-last-sexp prefix)))

  (add-hook 'emacs-lisp-mode-hook 'setup-hippie-expand-for-elisp)
  (add-hook 'emacs-lisp-mode-hook (lambda () (setq mode-name "ELisp")))

  (bind-key "M-:" 'pp-eval-expression)
  (bind-key "C-x C-e" 'tx/eval-last-sexp-or-region emacs-lisp-mode-map)

#+end_src

** Clojure
Setup ~clojure-mode~ and ~cider~. 

*** clojure cheatsheet

#+begin_src emacs-lisp :tangle no
  (use-package clojure-cheatsheet
    :ensure t
    :commands clojure-cheatsheet)

#+end_src

*** clojure-snippets

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package clojure-snippets
    :ensure t)

#+end_src

*** clojure-hydra

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package cider-hydra
    :ensure t
    :commands cider-hydra-mode)

#+end_src

*** clojure-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package clojure-mode
    :ensure t
    :init
    (setq clojure-align-forms-automatically t)
    :config
    (add-hook 'clojure-mode-hook #'subword-mode)
    (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode))

#+end_src

*** flycheck-joker

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package flycheck-joker
     :ensure t)

#+end_src

*** cider

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package cider
    :ensure t
    :commands (cider-mode cider-connect cider-jack-in cider-jack-in-clojurescript)
    :init
    (setq
     ;; cider-prompt-for-symbol nil
     ;; cider-font-lock-dynamically '(macro core function var)
     cider-eldoc-display-for-symbol-at-point nil
     eldoc-echo-area-use-multiline-p t
     cider-overlays-use-font-lock t
     cider-use-overlays t
     cider-show-error-buffer nil
     cider-repl-display-help-banner nil
     cider-repl-history-file (expand-file-name "repl-history"))
    :config
    (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'cider-mode-hook #'cider-hydra-mode))

#+end_src

*** clj-refactor

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package clj-refactor
    :ensure t
    :commands clj-refactor-mode
    :init
    (setq cljr-warn-on-eval nil)
    :config
    (add-hook 'clojure-mode-hook (lambda ()
                                   (clj-refactor-mode 1)
                                   ;; insert keybinding setup here
                                   (cljr-add-keybindings-with-prefix "C-c C-m"))))

#+end_src

*** inf-clojure

#+begin_src emacs-lisp :tangle no
  (use-package inf-clojure
    :ensure t
    :commands (inf-clojure inf-clojure-minor-mode inf-clojure-connect))

#+end_src

** SQL

*** sql-indent

#+begin_src emacs-lisp :tangle no
  (use-package sql-indent
    :ensure t
    :config
    (eval-after-load 'sql
      (load-library "sql-indent")))

#+end_src

*** sqlup-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package sqlup-mode
    :ensure t
    :config
    (add-hook 'sql-mode-hook 'sqlup-mode)
    (add-hook 'sql-interactive-mode-hook 'sqlup-mode))

#+end_src

*** sql

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package sql
    :init
    (progn 
      (setq-default sql-input-ring-file-name
                    (expand-file-name ".sqli_history" user-emacs-directory))
      (setq sql-product 'postgres
            sql-connection-alist '(("playground"
                                    (sql-product 'postgres)
                                    (sql-server "localhost")
                                    (sql-database "playground")
                                    (sql-port 5432))
                                   ("wdp-dev"
                                    (sql-product 'postgres)
                                    (sql-server "localhost")
                                    (sql-database "wdp")
                                    (sql-port 3330))
                                   ("wdp-prod"
                                    (sql-product 'postgres)
                                    (sql-server "localhost")
                                    (sql-database "wdp")
                                    (sql-port 3331))))
      (defun tx/pop-to-sqli-buffer ()
        "Switch to the corresponding sqli buffer."
        (interactive)
        (if sql-buffer
            (progn
              (pop-to-buffer sql-buffer)
              (goto-char (point-max)))
          (sql-set-sqli-buffer)
          (when sql-buffer
            (tx/pop-to-sqli-buffer)))))
    :config
    (bind-key "C-c C-z" 'tx/pop-to-sqli-buffer sql-mode-map))

#+end_src

** Web

*** web-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package web-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.jsp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.xhtml?\\'" . web-mode))

    (defun my-web-mode-hook ()
      "Hooks for Web mode."
      (setq web-mode-enable-auto-closing t
            web-mode-enable-auto-quoting t
            web-mode-markup-indent-offset 2))

    (add-hook 'web-mode-hook  'my-web-mode-hook))

#+end_src

*** less-css-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package less-css-mode
    :ensure t)

#+end_src

*** emmet-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package emmet-mode
    :ensure t)

#+end_src

** JavaScript
*** js2-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package js2-mode
    :ensure t
    :delight
    :mode "\\.js\\'"
    :interpreter ("node" . js2-mode)
    :init
    (flycheck-add-mode 'javascript-eslint 'js2-mode)
    (setq-default js2-bounce-indent-p nil)
    (setq js-indent-level 2
          js2-include-node-externs t
          js2-mode-assume-strict t
          js2-highlight-level 3
          js2-global-externs '("describe" "it" "before"
                               "after" "beforeEach" "afterEach"))
    :config
    (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
    (js2-imenu-extras-setup)
    (define-key js2-mode-map (kbd "M-.") nil))

#+end_src

*** xref-js2

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package xref-js2
    :ensure t
    :delight
    :config
    (add-hook 'js2-mode-hook
              (lambda ()
                (add-hook 'xref-backend-functions
                          #'xref-js2-xref-backend nil t))))

#+end_src

*** js2-refactor

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package js2-refactor
    :ensure t
    :config
    (add-hook 'js2-mode-hook #'js2-refactor-mode)
    (js2r-add-keybindings-with-prefix "C-c C-r")
    (define-key js2-mode-map (kbd "C-k") #'js2r-kill))

#+end_src

*** tern

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package tern
    :ensure t
    :delight
    :config
    (add-hook 'js2-mode-hook #'tern-mode))

#+end_src

*** company-tern

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package company-tern
    :ensure t
    :config
    (add-to-list 'company-backends 'company-tern)
    (add-hook 'js2-mode-hook (lambda ()
                               (tern-mode)
                               (company-mode)))

    ;; Disable completion keybindings, as we use xref-js2 instead
    (define-key tern-mode-keymap (kbd "M-.") nil)
    (define-key tern-mode-keymap (kbd "M-,") nil))

#+end_src

*** indium

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package indium
    :ensure t
    :delight
    ('indium-interaction-mode "JSI")
    :config
    (add-hook 'js2-mode-hook #'indium-interaction-mode))

#+end_src

*** prettier-js

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package prettier-js
    :ensure t
    :init
    (setq prettier-js-args '("--print-width" "80"
                             "--tab-width" "2"
                             "--no-bracket-spacing")
          prettier-js-width-mode 'fill)
    :config
    (add-hook 'js2-mode-hook #'prettier-js-mode))

#+end_src

*** json-mode

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package json-mode
    :ensure t)

#+end_src

*** ng2

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package ng2-mode
    :ensure t)

#+end_src

*** js-doc

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package js-doc
    :ensure t
    :init
    (setq js-doc-mail-address "tcross8@une.edu.au"
          js-doc-author (format "Tim Cross <%s>" js-doc-mail-address))
    :config
    (add-hook 'js2-mode-hook
              (lambda ()
                (define-key js2-mode-map "\C-ci" 'js-doc-insert-function-doc)
                (define-key js2-mode-map "@" 'js-doc-insert-tag))))

#+end_src

*** tide

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package tide
    :ensure t)

#+end_src

** Powershell

Have been blessed with no need to do powershell scripting at this time, so
disabling this support for now. 

#+begin_src emacs-lisp :tangle no
  (use-package powershell
    :ensure t)

#+end_src

** Python

No time to continue with learning Python programming at this time, so disabling
this support for now. 

*** jedi

#+begin_src emacs-lisp :tangle no
  (use-package jedi
    :ensure t
    :mode ("\\.py\\'" . python-mode)
    :init
    (setq jedi:complete-on-dot t)
    :config
    (add-hook 'python-mode-hook 'jedi:setup))

#+end_src

*** company-jedi

#+begin_src emacs-lisp :tangle no
  (use-package company-jedi
    :ensure t)

#+end_src

*** importmagic

#+begin_src emacs-lisp :tangle no
  (use-package importmagic
    :ensure t)

#+end_src

*** elpy

#+begin_src emacs-lisp :tangle no
  (use-package elpy
    :ensure t
    :init
    (setq elpy-rpc-backend "jedi")
    :config
    (elpy-enable))

#+end_src

** Scheme

No need for scheme support at this time. Disabling for now.

*** geiser

#+begin_src emacs-lisp :tangle no
  (use-package geiser
    :ensure t)

#+end_src

** CL

Moved back to Gnome from Stumpwn for now. Until time permits for full stumpwm
setup, comment out for now.

#+begin_src emacs-lisp :tangle tangle-init.el
  (when (not *is-a-mac*)
    (use-package slime
      :ensure t
      :init
      (setq slime-contribs '(slime-fancy)
            slime-complete-symbol-function 'slime-fuzzy-complete-symbol
            slime-net-coding-system 'utf-8-unix
            slime-lisp-implementations '((sbcl ("/usr/local/bin/sbcl" "--noinform")))
            slime-default-lisp 'sbcl)
      :config
      (setq common-lisp-hyperspec-root "/usr/share/doc/hyperspec/"
            common-lisp-hyperspec-symbols-table
            (concat common-lisp-hyperspec-root "Data/Map_Sym.txt")
            common-lisp-hyperspec-issuex-table
            (concat common-lisp-hyperspec-root "Data/Map_IssX.txt"))
      (when (file-exists-p (expand-file-name "~/quicklisp/slime-helper.el"))
        (load (expand-file-name "~/quicklisp/slime-helper.el")))
      (add-to-list 'Info-additional-directory-list
                   (expand-file-name "~/git/stumpwm")))
    (use-package slime-company
      :ensure t
      :config
      (slime-setup '(slime-company))))

#+end_src

** Elm

#+begin_src emacs-lisp :tangle no
  (use-package elm-mode
    :ensure t
    :config
    (setq elm-tags-on-save t
          elm-sort-imports-on-save t
          elm-format-on-save t)
    (add-to-list 'company-backends 'company-elm))

#+end_src

* Theme 

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package night-owl-theme
    :ensure t
    :init 
    (setq-default custom-enabled-themes '(night-owl))
    (setq
     night-owl-background "#011627"
     night-owl-doc-face-as-comment t
     night-owl-foreground "goldenrod3"
     night-owl-foreground-muted "OrangeRed3"
     night-owl-foreground-slightly-muted "goldenrod4"
     night-owl-highlight "#1D1053"
     night-owl-highlight-alt "#3C0074"
     night-owl-highlight-line "#010F1D"
     night-owl-use-variable-pitch t)
    :config
    (load-theme 'night-owl))

#+end_src

** Diminish Mode
The ~diminish~ package allows us to remove or change minor mode entries in the
mode-line. See [[https://github.com/myrjola/diminish.el][diminish on GitHub]]

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package diminish
    :ensure t
    :config
    (progn 
      (diminish 'voice-lock-mode)
      (diminish 'auto-fill-function)
      (diminish 'hs-minor-mode)
      (diminish 'doc-view-minor-mode " DV")
      (diminish 'view-mode " RO")
      ;; (diminish 'elisp-slime-nav-mode)
      (diminish 'yas-minor-mode)
      ;; (diminish 'paredit-everywhere-mode " Par")
      ;; (diminish 'paredit-mode " Par")
      (diminish 'rainbow-mode "")
      (diminish 'company-mode)
      (diminish 'global-whitespace-newline-mode)
      (diminish 'global-whitespace-mode)
      (diminish 'whitespace-newline-mode)
      (diminish 'whitespace-mode)
      (diminish 'guide-key-mode)))

#+end_src

* Local Packages 
I put locally managed packages i.e. those not installed via elpa into the lib
directory.

#+begin_src emacs-lisp :tangle no
  (use-package ipcalc
    :commands (ipcalc))

#+end_src

* Mail
** google-contacts

Ability to access google contacts is useful. 

#+begin_src emacs-lisp :tangle no
  (use-package google-contacts
    :ensure t
    :init
    (setq plstore-cache-passphrase-for-symmetric-encryption t)
    :config
    ;; (require 'google-contacts-message)
    (require 'google-org-contacts))
#+end_src

** Mu4e

First, setup some load paths.

#+begin_src emacs-lisp :tangle tangle-init.el
  (require 'info)

  (if *is-a-mac*
      (progn
        (setq mu4e-lisp "/usr/local/share/emacs/site-lisp/mu/mu4e")
        (setq mu4e-info "/usr/local/share/info"))
    (setq mu4e-lisp "/usr/share/emacs/site-lisp/mu4e")
    (setq mu4e-info "/usr/share/info"))

  (add-to-list 'load-path (expand-file-name mu4e-lisp))
  (add-to-list 'Info-additional-directory-list (expand-file-name mu4e-info))

#+end_src

Next, load some additional packages we need.

#+begin_src emacs-lisp :tangle tangle-init.el
  (when *run_emacspeak*
      (require 'emacspeak-mu4e))

  (require 'org-mu4e)

  (use-package "org-mime"
    :ensure t)

#+end_src

Setup mu4e alert

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package mu4e-alert
    :ensure t
    :config
    (setq mu4e-alert-interesting-mail-query
          (if (string= system-name "arch-vbox")
              (concat
               "(maildir:/gmail/INBOX OR "
               "maildir:/outlook/INBOX) AND "
               "flag:unread AND NOT flag:trashed")
            (concat
             "(maildir:/gmail/INBOX OR "
             "maildir:/outlook/INBOX OR "
             "maildir:/sheep/INBOX) AND "
             "flag:unread AND NOT flag:trashed")))
    (mu4e-alert-enable-mode-line-display))

#+end_src

Now setup mu4e.

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package mu4e
    :init
    (setq tx-gmail-email "theophilusx@gmail.com"
          tx-sheepcrc-email "tcross8@une.edu.au"
          tx-hotmail-email "blind-bat@hotmail.com")
    (setq mu4e-maildir (expand-file-name "~/Maildir")
          mu4e-attachment-dir (expand-file-name "~/Desktop")
          mu4e-get-mail-command "mbsync -a"
          mu4e-hide-index-messages t
          mu4e-headers-include-related nil
          mu4e-change-filenames-when-moving t
          mu4e-context-policy 'pick-first
          mu4e-compose-context-policy nil
          mu4e-view-fields '(:from :to :cc :subject :date :attachments)
          mu4e-view-scroll-to-next nil
          mu4e-view-show-addresses t
          mu4e-view-use-gnus t
          mu4e-update-interval (* 60 10)
          mu4e-user-mail-address-list '("theophilusx@gmail.com"
                                        "tcross8@une.edu.au"
                                        "tcross@une.edu.au"
                                        "blind-bat@hotmail.com"))
    (setq org-mu4e-link-query-in-headers-mode nil)
    :config
    (add-hook 'message-mode-hook 'turn-on-orgtbl)
    ;;(add-hook 'message-mode-hook 'outline-minor-mode)
    (setq mu4e-bookmarks '())
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Last 7 days"
                  :query "date:7d..now AND NOT flag:trashed"
                  :key ?w))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Messages with images"
                  :query "mime:image/* AND NOT flag:trashed"
                  :key ?p))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Today's messages"
                  :query "date:today..now AND NOT flag:trashed"
                  :key ?t))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name  "Unread messages"
                  :query (if (string= system-name "arch-vbox")
                             (concat "(maildir:/gmail/INBOX OR "
                                     "maildir:/outlook/INBOX) AND "
                                     "flag:unread AND NOT flag:trashed")
                           (concat "(maildir:/gmail/INBOX OR "
                                   "maildir:/outlook/INBOX OR "
                                   "maildir:/sheep/INBOX) AND "
                                   "flag:unread AND NOT flag:trashed"))
                  :key ?u))
    (setq mu4e-contexts '())
    (add-to-list 'mu4e-contexts
                 (make-mu4e-context
                  :name "Outlook"
                  :enter-func
                  (lambda ()
                    (mu4e-message "Entering Outlook context"))
                  :leave-func
                  (lambda ()
                    (mu4e-message "Leaving Outlook context"))
                  ;; we match based on the contact-fields of the message
                  :match-func
                  (lambda (msg)
                    (when msg
                      (mu4e-message-contact-field-matches msg
                                                          :to
                                                          "blind-bat@hotmail.com")))
                  :vars '((user-mail-address . "blind-bat@hotmail.com")
                          (user-full-name . "Tim Cross")
                          (mu4e-compose-signature . (concat "Tim Cross\n"))
                          (mu4e-drafts-folder . "/outlook/Drafts")
                          (mu4e-sent-folder . "/outlook/Sent Mail")
                          (mu4e-trash-folder . "/outlook/Deleted Items")
                          (mu4e-refile-folder . "/outlook/Archive")
                          (mu4e-maildir-shortcuts . (("/outlook/INBOX" . ?i)
                                                     ("/outlook/Sent Mail" . ?s)
                                                     ("/outlook/Archive" . ?a)
                                                     ("/outlook/Drafts" . ?d)))
                          (smtpmail-smtp-server . "smtp-mail.outlook.com")
                          (smtpmail-smtp-service . 587)
                          (mu4e-sent-messages-behavior . delete))))
    (if (string= system-name "tim-desktop")
        (add-to-list 'mu4e-contexts
                     (make-mu4e-context
                      :name "Sheep"
                      :enter-func
                      (lambda ()
                        (mu4e-message "Entering Sheep context"))
                      :leave-func
                      (lambda ()
                        (mu4e-message "Leaving Sheep context"))
                      ;; we match based on the contact-fields of the message
                      :match-func
                      (lambda (msg)
                        (when msg
                          (mu4e-message-contact-field-matches msg
                                                              :to
                                                              "tcross8@une.edu.au")))
                      :vars
                      '((user-mail-address . "tcross8@une.edu.au")
                        (user-full-name . "Tim Cross")
                        (mu4e-compose-signature .
                                                (concat
                                                 "Tim Cross\n"
                                                 "DBA/Developer - "
                                                 "Livestock App Building\n"
                                                 "School of Science and "
                                                 "Technology\n"
                                                 "Room 253 Booth Block (C027), "
                                                 "Univrsity of New England\n"))
                        (mu4e-drafts-folder . "/sheep/Drafts")
                        (mu4e-sent-folder . "/sheep/Sent Items")
                        (mu4e-trash-folder . "/sheep/Deleted Items")
                        (mu4e-refile-folder . "/sheep/Archive")
                        (mu4e-maildir-shortcuts . (("/sheep/INBOX" . ?i)
                                                   ("/sheep/Sent Items" . ?s)
                                                   ("/sheep/Archive" . ?a)
                                                   ("/sheep/Drafts" . ?d)))
                        (smtpmail-smtp-server . "mailhub.une.edu.au")
                        (smtpmail-smtp-service . 25)
                        (mu4e-sent-messages-behavior . sent)))))
    (add-to-list 'mu4e-contexts
                 (make-mu4e-context
                  :name "Private"
                  :enter-func (lambda ()
                                (mu4e-message "Entering Private context"))
                  :leave-func
                  (lambda ()
                    (mu4e-message "Leaving Private context"))
                  ;; we match based on the contact-fields of the message
                  :match-func
                  (lambda (msg)
                    (when msg
                      (mu4e-message-contact-field-matches msg :to "theophilusx@gmail.com")))
                  :vars
                  '((user-mail-address . "theophilusx@gmail.com")
                    (user-full-name . "Tim Cross")
                    (mu4e-compose-signature . (concat "Tim Cross\n"))
                    (mu4e-drafts-folder . "/gmail/Drafts")
                    (mu4e-sent-folder . "/gmail/Sent Mail")
                    (mu4e-trash-folder . "/gmail/Bin")
                    (mu4e-refile-folder . "/gmail/All Mail")
                    (mu4e-maildir-shortcuts . (("/gmail/INBOX" . ?i)
                                               ("/gmail/Sent Mail" . ?s)
                                               ("/gmail/All Mail" . ?a)
                                               ("/gmail/Drafts" . ?d)
                                               ("/gmail/Starred" . ?f)))
                    (smtpmail-smtp-server . "smtp.gmail.com")
                    (smtpmail-smtp-service . 587)
                    (mu4e-sent-messages-behavior . delete)))))

#+end_src

I no longer have a UNE staff account, so have removed the associated context for
that account. However, may still need it if I want to look at the messages I
have archived on this system, so keeping it below for reference.

#+BEGIN_EXAMPLE
  (make-mu4e-context
              :name "Work"
              :enter-func (lambda ()
                            (mu4e-message "Switch to the Work context"))
              ;; we match based on the contact-fields of the message
              :match-func (lambda (msg)
                            (when msg
                              (mu4e-message-contact-field-matches msg :to "tcross@une.edu.au")))
              :vars '((user-mail-address . "tcross@une.edu.au")
                      (user-full-name . "Tim Cross")
                      (mu4e-compose-signature . (concat "Tim Cross\n"
                                                        "www.une.edu.au\n"
                                                        "CRICOS Provider Number: 00003G"))
                      (mu4e-drafts-folder . "/une/Drafts")
                      (mu4e-sent-folder . "/une/Sent")
                      (mu4e-trash-folder . "/une/Deleted Items")
                      (mu4e-refile-folder . "/une/Archive")
                      (mu4e-maildir-shortcuts . (("/une/Inbox" . ?i)
                                                 ("/une/Sent" . ?s)
                                                 ("/une/Drafts" . ?d)))
                      (smtpmail-smtp-server . "smtp.office365.com")
                      (smtpmail-smtp-service . 587)
                      (mu4e-sent-messages-behavior . sent)))

#+END_EXAMPLE

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package smtpmail
    :config
    (setq message-send-mail-function 'smtpmail-send-it
          smtpmail-stream-type 'starttls
          smtpmail-debug-info nil
          smtpmail-debug-verb nil
          smtpmail-default-smtp-server "smtp.gmail.com")
    (setq smtpmail-queue-mail nil  ;; start in normal mode
          smtpmail-queue-dir   (expand-file-name "~/Maildir/queue/cur"))
    ;; don't keep message buffers around
    (setq message-kill-buffer-on-exit t))

#+end_src

** Test out VM again

Looks like there has been no work done on VM since 2016. Suspect the client may
have reached end-of-life!

#+begin_src emacs-lisp :tangle no
  (add-to-list 'load-path (expand-file-name "~/bzr/vm/new-trunk/lisp"))
  (add-to-list 'Info-additional-directory-list
               (expand-file-name "~/bzr/vm/new-trunk/info"))

  (require 'vm-autoloads)

  ;; Some hacks to make VM use shr for HTML messages

  (defun vm-mime-display-internal-shr-text/html (start end layout)
    "Use shr to inline HTML mails in the VM presentation buffer."
    (shr-render-region start (1- end))
    (put-text-property start end
                       'text-rendered-by-shr t))

  ;; has to be done indirectly
  ;; Fake emacs-w3m, though we actually use shr

  (defalias 'vm-mime-display-internal-emacs-w3m-text/html
       'vm-mime-display-internal-shr-text/html)

#+end_src

* Emacs Server

Start the emacs server so that we can use emacsclient

** Edit Server

#+begin_src emacs-lisp :tangle no
  (use-package edit-server
    :ensure t
    :init
    (setq edit-server-url-major-mode-alist
          '(("mail.google.com" . org-mode)
            ("stackoverflow\\.com" . markdown-mode)
            (".*\\.stackexchange\\.com" . markdown-mode)
            ("github\\.com" . markdown-mode)))
    :config
    (edit-server-start))

#+end_src

** Emacs Server

#+begin_src emacs-lisp :tangle tangle-init.el
  (use-package server
    :config
    (server-start))

#+end_src

* Coding System

#+begin_src emacs-lisp :tangle tangle-init.el
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))

#+end_src

* Startup Window

My custom setup for initial window configuration. There is probably a better way
to do this!

#+begin_src emacs-lisp :tangle no
  (defun my-startup-window ()
    (interactive)
    (org-agenda nil "wr")
    (delete-other-windows))

  (setq warning-minimum-level :error
        warning-minimum-log-level :error)

  (add-hook 'after-init-hook 'my-startup-window t)

  (defun my-after-init-config ()
    (require 'ido-fix))

  (add-hook 'after-init-hook 'my-after-init-config)

#+end_src

